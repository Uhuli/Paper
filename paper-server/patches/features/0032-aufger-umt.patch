From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Mika <Mika@zestnik.de>
Date: Sat, 26 Apr 2025 19:33:50 +0200
Subject: [PATCH] =?UTF-8?q?aufger=C3=A4umt?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit


diff --git a/net/minecraft/commands/Commands.java b/net/minecraft/commands/Commands.java
index f8969a68cd352ce4fe5109205e78f5e19ab6e020..e591b8ffad810836dcd0af73c87e92027c693c7f 100644
--- a/net/minecraft/commands/Commands.java
+++ b/net/minecraft/commands/Commands.java
@@ -34,106 +34,40 @@ import net.minecraft.core.HolderLookup;
 import net.minecraft.core.HolderSet;
 import net.minecraft.core.Registry;
 import net.minecraft.data.registries.VanillaRegistries;
-import net.minecraft.gametest.framework.TestCommand;
 import net.minecraft.network.chat.ClickEvent;
 import net.minecraft.network.chat.CommonComponents;
 import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.ComponentUtils;
 import net.minecraft.network.chat.HoverEvent;
 import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.game.ClientboundCommandsPacket;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.server.MinecraftServer;
-import net.minecraft.server.commands.AdvancementCommands;
 import net.minecraft.server.commands.AttributeCommand;
-import net.minecraft.server.commands.BanIpCommands;
-import net.minecraft.server.commands.BanListCommands;
-import net.minecraft.server.commands.BanPlayerCommands;
-import net.minecraft.server.commands.BossBarCommands;
 import net.minecraft.server.commands.ClearInventoryCommands;
-import net.minecraft.server.commands.CloneCommands;
-import net.minecraft.server.commands.DamageCommand;
 import net.minecraft.server.commands.DataPackCommand;
-import net.minecraft.server.commands.DeOpCommands;
-import net.minecraft.server.commands.DebugCommand;
-import net.minecraft.server.commands.DebugConfigCommand;
-import net.minecraft.server.commands.DebugMobSpawningCommand;
-import net.minecraft.server.commands.DebugPathCommand;
-import net.minecraft.server.commands.DefaultGameModeCommands;
-import net.minecraft.server.commands.DifficultyCommand;
 import net.minecraft.server.commands.EffectCommands;
-import net.minecraft.server.commands.EmoteCommands;
-import net.minecraft.server.commands.EnchantCommand;
 import net.minecraft.server.commands.ExecuteCommand;
 import net.minecraft.server.commands.ExperienceCommand;
-import net.minecraft.server.commands.FillBiomeCommand;
-import net.minecraft.server.commands.FillCommand;
-import net.minecraft.server.commands.ForceLoadCommand;
 import net.minecraft.server.commands.FunctionCommand;
 import net.minecraft.server.commands.GameModeCommand;
 import net.minecraft.server.commands.GameRuleCommand;
 import net.minecraft.server.commands.GiveCommand;
-import net.minecraft.server.commands.HelpCommand;
-import net.minecraft.server.commands.ItemCommands;
-import net.minecraft.server.commands.JfrCommand;
-import net.minecraft.server.commands.KickCommand;
 import net.minecraft.server.commands.KillCommand;
-import net.minecraft.server.commands.ListPlayersCommand;
-import net.minecraft.server.commands.LocateCommand;
-import net.minecraft.server.commands.LootCommand;
-import net.minecraft.server.commands.MsgCommand;
-import net.minecraft.server.commands.OpCommand;
-import net.minecraft.server.commands.PardonCommand;
-import net.minecraft.server.commands.PardonIpCommand;
 import net.minecraft.server.commands.ParticleCommand;
-import net.minecraft.server.commands.PerfCommand;
-import net.minecraft.server.commands.PlaceCommand;
 import net.minecraft.server.commands.PlaySoundCommand;
-import net.minecraft.server.commands.PublishCommand;
-import net.minecraft.server.commands.RaidCommand;
-import net.minecraft.server.commands.RandomCommand;
-import net.minecraft.server.commands.RecipeCommand;
-import net.minecraft.server.commands.ReloadCommand;
-import net.minecraft.server.commands.ReturnCommand;
-import net.minecraft.server.commands.RideCommand;
-import net.minecraft.server.commands.RotateCommand;
 import net.minecraft.server.commands.SaveAllCommand;
-import net.minecraft.server.commands.SaveOffCommand;
-import net.minecraft.server.commands.SaveOnCommand;
-import net.minecraft.server.commands.SayCommand;
-import net.minecraft.server.commands.ScheduleCommand;
-import net.minecraft.server.commands.ScoreboardCommand;
-import net.minecraft.server.commands.SeedCommand;
-import net.minecraft.server.commands.ServerPackCommand;
-import net.minecraft.server.commands.SetBlockCommand;
-import net.minecraft.server.commands.SetPlayerIdleTimeoutCommand;
-import net.minecraft.server.commands.SetSpawnCommand;
 import net.minecraft.server.commands.SetWorldSpawnCommand;
-import net.minecraft.server.commands.SpawnArmorTrimsCommand;
-import net.minecraft.server.commands.SpectateCommand;
-import net.minecraft.server.commands.SpreadPlayersCommand;
-import net.minecraft.server.commands.StopCommand;
-import net.minecraft.server.commands.StopSoundCommand;
 import net.minecraft.server.commands.SummonCommand;
 import net.minecraft.server.commands.TagCommand;
-import net.minecraft.server.commands.TeamCommand;
-import net.minecraft.server.commands.TeamMsgCommand;
-import net.minecraft.server.commands.TeleportCommand;
-import net.minecraft.server.commands.TellRawCommand;
 import net.minecraft.server.commands.TickCommand;
 import net.minecraft.server.commands.TimeCommand;
-import net.minecraft.server.commands.TitleCommand;
-import net.minecraft.server.commands.TransferCommand;
 import net.minecraft.server.commands.TriggerCommand;
-import net.minecraft.server.commands.WardenSpawnTrackerCommand;
 import net.minecraft.server.commands.WeatherCommand;
-import net.minecraft.server.commands.WhitelistCommand;
 import net.minecraft.server.commands.WorldBorderCommand;
 import net.minecraft.server.commands.data.DataCommands;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.tags.TagKey;
 import net.minecraft.util.profiling.Profiler;
-import net.minecraft.util.profiling.jfr.JvmProfiler;
 import net.minecraft.world.flag.FeatureFlagSet;
 import net.minecraft.world.flag.FeatureFlags;
 import net.minecraft.world.level.GameRules;
@@ -150,110 +84,36 @@ public class Commands {
     private final CommandDispatcher<CommandSourceStack> dispatcher = new CommandDispatcher<>();
 
     public Commands(Commands.CommandSelection selection, CommandBuildContext context) {
-    // Paper start - Brigadier API - modern minecraft overloads that do not use redirects but are copies instead
+        // Paper start - Brigadier API - modern minecraft overloads that do not use redirects but are copies instead
         this(selection, context, false);
     }
     public Commands(Commands.CommandSelection selection, CommandBuildContext context, final boolean modern) {
-    // Paper end - Brigadier API - modern minecraft overloads that do not use redirects but are copies instead
-        AdvancementCommands.register(this.dispatcher);
+        // Paper end - Brigadier API - modern minecraft overloads that do not use redirects but are copies instead
         AttributeCommand.register(this.dispatcher, context);
         ExecuteCommand.register(this.dispatcher, context);
-        BossBarCommands.register(this.dispatcher, context);
         ClearInventoryCommands.register(this.dispatcher, context);
-        CloneCommands.register(this.dispatcher, context);
-        DamageCommand.register(this.dispatcher, context);
         DataCommands.register(this.dispatcher);
         DataPackCommand.register(this.dispatcher);
-        DebugCommand.register(this.dispatcher);
-        DefaultGameModeCommands.register(this.dispatcher);
-        DifficultyCommand.register(this.dispatcher);
         EffectCommands.register(this.dispatcher, context);
-        EmoteCommands.register(this.dispatcher);
-        EnchantCommand.register(this.dispatcher, context);
         ExperienceCommand.register(this.dispatcher);
-        FillCommand.register(this.dispatcher, context);
-        FillBiomeCommand.register(this.dispatcher, context);
-        ForceLoadCommand.register(this.dispatcher);
         FunctionCommand.register(this.dispatcher);
         GameModeCommand.register(this.dispatcher);
         GameRuleCommand.register(this.dispatcher, context);
         GiveCommand.register(this.dispatcher, context);
-        HelpCommand.register(this.dispatcher);
-        ItemCommands.register(this.dispatcher, context);
-        KickCommand.register(this.dispatcher);
         KillCommand.register(this.dispatcher);
-        ListPlayersCommand.register(this.dispatcher);
-        LocateCommand.register(this.dispatcher, context);
-        LootCommand.register(this.dispatcher, context);
-        MsgCommand.register(this.dispatcher);
         ParticleCommand.register(this.dispatcher, context);
-        PlaceCommand.register(this.dispatcher);
         PlaySoundCommand.register(this.dispatcher);
-        RandomCommand.register(this.dispatcher);
-        ReloadCommand.register(this.dispatcher);
-        RecipeCommand.register(this.dispatcher);
-        ReturnCommand.register(this.dispatcher);
-        RideCommand.register(this.dispatcher);
-        RotateCommand.register(this.dispatcher);
-        SayCommand.register(this.dispatcher);
-        ScheduleCommand.register(this.dispatcher);
-        ScoreboardCommand.register(this.dispatcher, context);
-        SeedCommand.register(this.dispatcher, selection != Commands.CommandSelection.INTEGRATED);
-        SetBlockCommand.register(this.dispatcher, context);
-        SetSpawnCommand.register(this.dispatcher);
         SetWorldSpawnCommand.register(this.dispatcher);
-        SpectateCommand.register(this.dispatcher);
-        SpreadPlayersCommand.register(this.dispatcher);
-        StopSoundCommand.register(this.dispatcher);
         SummonCommand.register(this.dispatcher, context);
         TagCommand.register(this.dispatcher);
-        TeamCommand.register(this.dispatcher, context);
-        TeamMsgCommand.register(this.dispatcher);
-        TeleportCommand.register(this.dispatcher);
-        TellRawCommand.register(this.dispatcher, context);
         TickCommand.register(this.dispatcher);
         TimeCommand.register(this.dispatcher);
-        TitleCommand.register(this.dispatcher, context);
         TriggerCommand.register(this.dispatcher);
         WeatherCommand.register(this.dispatcher);
         WorldBorderCommand.register(this.dispatcher);
-        if (JvmProfiler.INSTANCE.isAvailable()) {
-            JfrCommand.register(this.dispatcher);
-        }
-
-        if (SharedConstants.IS_RUNNING_IN_IDE) {
-            TestCommand.register(this.dispatcher);
-            RaidCommand.register(this.dispatcher, context);
-            DebugPathCommand.register(this.dispatcher);
-            DebugMobSpawningCommand.register(this.dispatcher);
-            WardenSpawnTrackerCommand.register(this.dispatcher);
-            SpawnArmorTrimsCommand.register(this.dispatcher);
-            ServerPackCommand.register(this.dispatcher);
-            if (selection.includeDedicated) {
-                DebugConfigCommand.register(this.dispatcher);
-            }
-        }
 
         if (selection.includeDedicated) {
-            BanIpCommands.register(this.dispatcher);
-            BanListCommands.register(this.dispatcher);
-            BanPlayerCommands.register(this.dispatcher);
-            DeOpCommands.register(this.dispatcher);
-            OpCommand.register(this.dispatcher);
-            PardonCommand.register(this.dispatcher);
-            PardonIpCommand.register(this.dispatcher);
-            PerfCommand.register(this.dispatcher);
             SaveAllCommand.register(this.dispatcher);
-            SaveOffCommand.register(this.dispatcher);
-            SaveOnCommand.register(this.dispatcher);
-            SetPlayerIdleTimeoutCommand.register(this.dispatcher);
-            StopCommand.register(this.dispatcher);
-            TransferCommand.register(this.dispatcher);
-            WhitelistCommand.register(this.dispatcher);
-        }
-
-        if (selection.includeIntegrated) {
-            PublishCommand.register(this.dispatcher);
         }
 
         // Paper start - Vanilla command permission fixes
@@ -496,7 +356,7 @@ public class Commands {
         // Paper start - Perf: Async command map building
         new com.destroystokyo.paper.event.brigadier.AsyncPlayerSendCommandsEvent<CommandSourceStack>(player.getBukkitEntity(), (RootCommandNode) rootCommandNode, false).callEvent(); // Paper - Brigadier API
         net.minecraft.server.MinecraftServer.getServer().execute(() -> {
-           runSync(player, bukkit, rootCommandNode);
+            runSync(player, bukkit, rootCommandNode);
         });
     }
 
diff --git a/net/minecraft/gametest/framework/GameTestHelper.java b/net/minecraft/gametest/framework/GameTestHelper.java
index fe4ae6bcdcbb55c47e9f9a4d63ead4c39e6d63cf..2b62b8b5978bc0a62fb487f497a855e7c753d1d6 100644
--- a/net/minecraft/gametest/framework/GameTestHelper.java
+++ b/net/minecraft/gametest/framework/GameTestHelper.java
@@ -24,7 +24,6 @@ import net.minecraft.network.Connection;
 import net.minecraft.network.protocol.PacketFlow;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
-import net.minecraft.server.commands.FillBiomeCommand;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.network.CommonListenerCookie;
diff --git a/net/minecraft/gametest/framework/GameTestServer.java b/net/minecraft/gametest/framework/GameTestServer.java
index 54ca624a8194e7d1c0f3b1c0ddba81165523382c..5f3165b81b03049d92e4a1a19fe8a342639f44df 100644
--- a/net/minecraft/gametest/framework/GameTestServer.java
+++ b/net/minecraft/gametest/framework/GameTestServer.java
@@ -278,11 +278,6 @@ public class GameTestServer extends MinecraftServer {
         return 4;
     }
 
-    @Override
-    public boolean shouldRconBroadcast() {
-        return false;
-    }
-
     @Override
     public boolean isDedicatedServer() {
         return false;
diff --git a/net/minecraft/gametest/framework/TestCommand.java b/net/minecraft/gametest/framework/TestCommand.java
deleted file mode 100644
index 5040849114d7834eaf786dcc37832fd6d95d79de..0000000000000000000000000000000000000000
--- a/net/minecraft/gametest/framework/TestCommand.java
+++ /dev/null
@@ -1,711 +0,0 @@
-package net.minecraft.gametest.framework;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.BoolArgumentType;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import com.mojang.brigadier.arguments.StringArgumentType;
-import com.mojang.brigadier.builder.ArgumentBuilder;
-import com.mojang.brigadier.context.CommandContext;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.logging.LogUtils;
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.nio.file.Paths;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Optional;
-import java.util.function.Consumer;
-import java.util.function.Function;
-import java.util.function.ToIntFunction;
-import java.util.stream.Stream;
-import net.minecraft.ChatFormatting;
-import net.minecraft.FileUtil;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Direction;
-import net.minecraft.core.Vec3i;
-import net.minecraft.data.CachedOutput;
-import net.minecraft.data.structures.NbtToSnbt;
-import net.minecraft.nbt.NbtIo;
-import net.minecraft.nbt.NbtUtils;
-import net.minecraft.network.chat.ClickEvent;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.ComponentUtils;
-import net.minecraft.network.chat.HoverEvent;
-import net.minecraft.network.chat.Style;
-import net.minecraft.network.protocol.game.DebugPackets;
-import net.minecraft.resources.ResourceLocation;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.util.Mth;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.Rotation;
-import net.minecraft.world.level.block.entity.StructureBlockEntity;
-import net.minecraft.world.level.levelgen.Heightmap;
-import net.minecraft.world.level.levelgen.structure.BoundingBox;
-import net.minecraft.world.phys.BlockHitResult;
-import org.apache.commons.io.IOUtils;
-import org.apache.commons.lang3.mutable.MutableBoolean;
-import org.apache.commons.lang3.mutable.MutableInt;
-import org.slf4j.Logger;
-
-public class TestCommand {
-    public static final int STRUCTURE_BLOCK_NEARBY_SEARCH_RADIUS = 15;
-    public static final int STRUCTURE_BLOCK_FULL_SEARCH_RADIUS = 200;
-    public static final int VERIFY_TEST_GRID_AXIS_SIZE = 10;
-    public static final int VERIFY_TEST_BATCH_SIZE = 100;
-    private static final Logger LOGGER = LogUtils.getLogger();
-    private static final int DEFAULT_CLEAR_RADIUS = 200;
-    private static final int MAX_CLEAR_RADIUS = 1024;
-    private static final int TEST_POS_Z_OFFSET_FROM_PLAYER = 3;
-    private static final int SHOW_POS_DURATION_MS = 10000;
-    private static final int DEFAULT_X_SIZE = 5;
-    private static final int DEFAULT_Y_SIZE = 5;
-    private static final int DEFAULT_Z_SIZE = 5;
-    private static final String STRUCTURE_BLOCK_ENTITY_COULD_NOT_BE_FOUND = "Structure block entity could not be found";
-    private static final TestFinder.Builder<TestCommand.Runner> testFinder = new TestFinder.Builder<>(TestCommand.Runner::new);
-
-    private static ArgumentBuilder<CommandSourceStack, ?> runWithRetryOptions(
-        ArgumentBuilder<CommandSourceStack, ?> argumentBuilder,
-        Function<CommandContext<CommandSourceStack>, TestCommand.Runner> runnerGetter,
-        Function<ArgumentBuilder<CommandSourceStack, ?>, ArgumentBuilder<CommandSourceStack, ?>> modifier
-    ) {
-        return argumentBuilder.executes(context -> runnerGetter.apply(context).run())
-            .then(
-                Commands.argument("numberOfTimes", IntegerArgumentType.integer(0))
-                    .executes(context -> runnerGetter.apply(context).run(new RetryOptions(IntegerArgumentType.getInteger(context, "numberOfTimes"), false)))
-                    .then(
-                        modifier.apply(
-                            Commands.argument("untilFailed", BoolArgumentType.bool())
-                                .executes(
-                                    context -> runnerGetter.apply(context)
-                                        .run(
-                                            new RetryOptions(
-                                                IntegerArgumentType.getInteger(context, "numberOfTimes"), BoolArgumentType.getBool(context, "untilFailed")
-                                            )
-                                        )
-                                )
-                        )
-                    )
-            );
-    }
-
-    private static ArgumentBuilder<CommandSourceStack, ?> runWithRetryOptions(
-        ArgumentBuilder<CommandSourceStack, ?> argumentBuilder, Function<CommandContext<CommandSourceStack>, TestCommand.Runner> runnerGetter
-    ) {
-        return runWithRetryOptions(argumentBuilder, runnerGetter, builder -> builder);
-    }
-
-    private static ArgumentBuilder<CommandSourceStack, ?> runWithRetryOptionsAndBuildInfo(
-        ArgumentBuilder<CommandSourceStack, ?> argumentBuilder, Function<CommandContext<CommandSourceStack>, TestCommand.Runner> runnerGetter
-    ) {
-        return runWithRetryOptions(
-            argumentBuilder,
-            runnerGetter,
-            argumentBuilder1 -> argumentBuilder1.then(
-                Commands.argument("rotationSteps", IntegerArgumentType.integer())
-                    .executes(
-                        context -> runnerGetter.apply(context)
-                            .run(
-                                new RetryOptions(IntegerArgumentType.getInteger(context, "numberOfTimes"), BoolArgumentType.getBool(context, "untilFailed")),
-                                IntegerArgumentType.getInteger(context, "rotationSteps")
-                            )
-                    )
-                    .then(
-                        Commands.argument("testsPerRow", IntegerArgumentType.integer())
-                            .executes(
-                                context -> runnerGetter.apply(context)
-                                    .run(
-                                        new RetryOptions(
-                                            IntegerArgumentType.getInteger(context, "numberOfTimes"), BoolArgumentType.getBool(context, "untilFailed")
-                                        ),
-                                        IntegerArgumentType.getInteger(context, "rotationSteps"),
-                                        IntegerArgumentType.getInteger(context, "testsPerRow")
-                                    )
-                            )
-                    )
-            )
-        );
-    }
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        ArgumentBuilder<CommandSourceStack, ?> argumentBuilder = runWithRetryOptionsAndBuildInfo(
-            Commands.argument("onlyRequiredTests", BoolArgumentType.bool()),
-            context -> testFinder.failedTests(context, BoolArgumentType.getBool(context, "onlyRequiredTests"))
-        );
-        ArgumentBuilder<CommandSourceStack, ?> argumentBuilder1 = runWithRetryOptionsAndBuildInfo(
-            Commands.argument("testClassName", TestClassNameArgument.testClassName()),
-            context -> testFinder.allTestsInClass(context, TestClassNameArgument.getTestClassName(context, "testClassName"))
-        );
-        dispatcher.register(
-            Commands.literal("test")
-                .then(
-                    Commands.literal("run")
-                        .then(
-                            runWithRetryOptionsAndBuildInfo(
-                                Commands.argument("testName", TestFunctionArgument.testFunctionArgument()),
-                                context -> testFinder.byArgument(context, "testName")
-                            )
-                        )
-                )
-                .then(
-                    Commands.literal("runmultiple")
-                        .then(
-                            Commands.argument("testName", TestFunctionArgument.testFunctionArgument())
-                                .executes(context -> testFinder.byArgument(context, "testName").run())
-                                .then(
-                                    Commands.argument("amount", IntegerArgumentType.integer())
-                                        .executes(
-                                            context -> testFinder.createMultipleCopies(IntegerArgumentType.getInteger(context, "amount"))
-                                                .byArgument(context, "testName")
-                                                .run()
-                                        )
-                                )
-                        )
-                )
-                .then(runWithRetryOptionsAndBuildInfo(Commands.literal("runall").then(argumentBuilder1), testFinder::allTests))
-                .then(runWithRetryOptions(Commands.literal("runthese"), testFinder::allNearby))
-                .then(runWithRetryOptions(Commands.literal("runclosest"), testFinder::nearest))
-                .then(runWithRetryOptions(Commands.literal("runthat"), testFinder::lookedAt))
-                .then(runWithRetryOptionsAndBuildInfo(Commands.literal("runfailed").then(argumentBuilder), testFinder::failedTests))
-                .then(
-                    Commands.literal("verify")
-                        .then(
-                            Commands.argument("testName", TestFunctionArgument.testFunctionArgument())
-                                .executes(context -> testFinder.byArgument(context, "testName").verify())
-                        )
-                )
-                .then(
-                    Commands.literal("verifyclass")
-                        .then(
-                            Commands.argument("testClassName", TestClassNameArgument.testClassName())
-                                .executes(
-                                    context -> testFinder.allTestsInClass(context, TestClassNameArgument.getTestClassName(context, "testClassName")).verify()
-                                )
-                        )
-                )
-                .then(
-                    Commands.literal("locate")
-                        .then(
-                            Commands.argument("testName", TestFunctionArgument.testFunctionArgument())
-                                .executes(
-                                    context -> testFinder.locateByName(
-                                            context, "minecraft:" + TestFunctionArgument.getTestFunction(context, "testName").structureName()
-                                        )
-                                        .locate()
-                                )
-                        )
-                )
-                .then(Commands.literal("resetclosest").executes(context -> testFinder.nearest(context).reset()))
-                .then(Commands.literal("resetthese").executes(context -> testFinder.allNearby(context).reset()))
-                .then(Commands.literal("resetthat").executes(context -> testFinder.lookedAt(context).reset()))
-                .then(
-                    Commands.literal("export")
-                        .then(
-                            Commands.argument("testName", StringArgumentType.word())
-                                .executes(context -> exportTestStructure(context.getSource(), "minecraft:" + StringArgumentType.getString(context, "testName")))
-                        )
-                )
-                .then(Commands.literal("exportclosest").executes(context -> testFinder.nearest(context).export()))
-                .then(Commands.literal("exportthese").executes(context -> testFinder.allNearby(context).export()))
-                .then(Commands.literal("exportthat").executes(context -> testFinder.lookedAt(context).export()))
-                .then(Commands.literal("clearthat").executes(context -> testFinder.lookedAt(context).clear()))
-                .then(Commands.literal("clearthese").executes(context -> testFinder.allNearby(context).clear()))
-                .then(
-                    Commands.literal("clearall")
-                        .executes(context -> testFinder.radius(context, 200).clear())
-                        .then(
-                            Commands.argument("radius", IntegerArgumentType.integer())
-                                .executes(context -> testFinder.radius(context, Mth.clamp(IntegerArgumentType.getInteger(context, "radius"), 0, 1024)).clear())
-                        )
-                )
-                .then(
-                    Commands.literal("import")
-                        .then(
-                            Commands.argument("testName", StringArgumentType.word())
-                                .executes(context -> importTestStructure(context.getSource(), StringArgumentType.getString(context, "testName")))
-                        )
-                )
-                .then(Commands.literal("stop").executes(context -> stopTests()))
-                .then(
-                    Commands.literal("pos")
-                        .executes(context -> showPos(context.getSource(), "pos"))
-                        .then(
-                            Commands.argument("var", StringArgumentType.word())
-                                .executes(context -> showPos(context.getSource(), StringArgumentType.getString(context, "var")))
-                        )
-                )
-                .then(
-                    Commands.literal("create")
-                        .then(
-                            Commands.argument("testName", StringArgumentType.word())
-                                .suggests(TestFunctionArgument::suggestTestFunction)
-                                .executes(context -> createNewStructure(context.getSource(), StringArgumentType.getString(context, "testName"), 5, 5, 5))
-                                .then(
-                                    Commands.argument("width", IntegerArgumentType.integer())
-                                        .executes(
-                                            context -> createNewStructure(
-                                                context.getSource(),
-                                                StringArgumentType.getString(context, "testName"),
-                                                IntegerArgumentType.getInteger(context, "width"),
-                                                IntegerArgumentType.getInteger(context, "width"),
-                                                IntegerArgumentType.getInteger(context, "width")
-                                            )
-                                        )
-                                        .then(
-                                            Commands.argument("height", IntegerArgumentType.integer())
-                                                .then(
-                                                    Commands.argument("depth", IntegerArgumentType.integer())
-                                                        .executes(
-                                                            context -> createNewStructure(
-                                                                context.getSource(),
-                                                                StringArgumentType.getString(context, "testName"),
-                                                                IntegerArgumentType.getInteger(context, "width"),
-                                                                IntegerArgumentType.getInteger(context, "height"),
-                                                                IntegerArgumentType.getInteger(context, "depth")
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int resetGameTestInfo(GameTestInfo gameTestInfo) {
-        gameTestInfo.getLevel().getEntities(null, gameTestInfo.getStructureBounds()).stream().forEach(entity -> entity.remove(Entity.RemovalReason.DISCARDED, org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD)); // Paper
-        gameTestInfo.getStructureBlockEntity().placeStructure(gameTestInfo.getLevel());
-        StructureUtils.removeBarriers(gameTestInfo.getStructureBounds(), gameTestInfo.getLevel());
-        say(gameTestInfo.getLevel(), "Reset succeded for: " + gameTestInfo.getTestName(), ChatFormatting.GREEN);
-        return 1;
-    }
-
-    static Stream<GameTestInfo> toGameTestInfos(CommandSourceStack source, RetryOptions retryOptions, StructureBlockPosFinder structureBlockPosFinder) {
-        return structureBlockPosFinder.findStructureBlockPos()
-            .map(blockPos -> createGameTestInfo(blockPos, source.getLevel(), retryOptions))
-            .flatMap(Optional::stream);
-    }
-
-    static Stream<GameTestInfo> toGameTestInfo(CommandSourceStack source, RetryOptions retryOptions, TestFunctionFinder testFunctionFinder, int rotationSteps) {
-        return testFunctionFinder.findTestFunctions()
-            .filter(function -> verifyStructureExists(source.getLevel(), function.structureName()))
-            .map(function -> new GameTestInfo(function, StructureUtils.getRotationForRotationSteps(rotationSteps), source.getLevel(), retryOptions));
-    }
-
-    private static Optional<GameTestInfo> createGameTestInfo(BlockPos pos, ServerLevel level, RetryOptions retryOptions) {
-        StructureBlockEntity structureBlockEntity = (StructureBlockEntity)level.getBlockEntity(pos);
-        if (structureBlockEntity == null) {
-            say(level, "Structure block entity could not be found", ChatFormatting.RED);
-            return Optional.empty();
-        } else {
-            String metaData = structureBlockEntity.getMetaData();
-            Optional<TestFunction> optional = GameTestRegistry.findTestFunction(metaData);
-            if (optional.isEmpty()) {
-                say(level, "Test function for test " + metaData + " could not be found", ChatFormatting.RED);
-                return Optional.empty();
-            } else {
-                TestFunction testFunction = optional.get();
-                GameTestInfo gameTestInfo = new GameTestInfo(testFunction, structureBlockEntity.getRotation(), level, retryOptions);
-                gameTestInfo.setStructureBlockPos(pos);
-                return !verifyStructureExists(level, gameTestInfo.getStructureName()) ? Optional.empty() : Optional.of(gameTestInfo);
-            }
-        }
-    }
-
-    private static int createNewStructure(CommandSourceStack source, String structureName, int x, int y, int z) {
-        if (x <= 48 && y <= 48 && z <= 48) {
-            ServerLevel level = source.getLevel();
-            BlockPos blockPos = createTestPositionAround(source).below();
-            StructureUtils.createNewEmptyStructureBlock(structureName.toLowerCase(), blockPos, new Vec3i(x, y, z), Rotation.NONE, level);
-            BlockPos blockPos1 = blockPos.above();
-            BlockPos blockPos2 = blockPos1.offset(x - 1, 0, z - 1);
-            BlockPos.betweenClosedStream(blockPos1, blockPos2).forEach(pos -> level.setBlockAndUpdate(pos, Blocks.BEDROCK.defaultBlockState()));
-            StructureUtils.addCommandBlockAndButtonToStartTest(blockPos, new BlockPos(1, 0, -1), Rotation.NONE, level);
-            return 0;
-        } else {
-            throw new IllegalArgumentException("The structure must be less than 48 blocks big in each axis");
-        }
-    }
-
-    private static int showPos(CommandSourceStack source, String variableName) throws CommandSyntaxException {
-        BlockHitResult blockHitResult = (BlockHitResult)source.getPlayerOrException().pick(10.0, 1.0F, false);
-        BlockPos blockPos = blockHitResult.getBlockPos();
-        ServerLevel level = source.getLevel();
-        Optional<BlockPos> optional = StructureUtils.findStructureBlockContainingPos(blockPos, 15, level);
-        if (optional.isEmpty()) {
-            optional = StructureUtils.findStructureBlockContainingPos(blockPos, 200, level);
-        }
-
-        if (optional.isEmpty()) {
-            source.sendFailure(Component.literal("Can't find a structure block that contains the targeted pos " + blockPos));
-            return 0;
-        } else {
-            StructureBlockEntity structureBlockEntity = (StructureBlockEntity)level.getBlockEntity(optional.get());
-            if (structureBlockEntity == null) {
-                say(level, "Structure block entity could not be found", ChatFormatting.RED);
-                return 0;
-            } else {
-                BlockPos blockPos1 = blockPos.subtract(optional.get());
-                String string = blockPos1.getX() + ", " + blockPos1.getY() + ", " + blockPos1.getZ();
-                String metaData = structureBlockEntity.getMetaData();
-                Component component = Component.literal(string)
-                    .setStyle(
-                        Style.EMPTY
-                            .withBold(true)
-                            .withColor(ChatFormatting.GREEN)
-                            .withHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, Component.literal("Click to copy to clipboard")))
-                            .withClickEvent(
-                                new ClickEvent(ClickEvent.Action.COPY_TO_CLIPBOARD, "final BlockPos " + variableName + " = new BlockPos(" + string + ");")
-                            )
-                    );
-                source.sendSuccess(() -> Component.literal("Position relative to " + metaData + ": ").append(component), false);
-                DebugPackets.sendGameTestAddMarker(level, new BlockPos(blockPos), string, -2147418368, 10000);
-                return 1;
-            }
-        }
-    }
-
-    static int stopTests() {
-        GameTestTicker.SINGLETON.clear();
-        return 1;
-    }
-
-    static int trackAndStartRunner(CommandSourceStack source, ServerLevel level, GameTestRunner runner) {
-        runner.addListener(new TestCommand.TestBatchSummaryDisplayer(source));
-        MultipleTestTracker multipleTestTracker = new MultipleTestTracker(runner.getTestInfos());
-        multipleTestTracker.addListener(new TestCommand.TestSummaryDisplayer(level, multipleTestTracker));
-        multipleTestTracker.addFailureListener(testInfo -> GameTestRegistry.rememberFailedTest(testInfo.getTestFunction()));
-        runner.start();
-        return 1;
-    }
-
-    static int saveAndExportTestStructure(CommandSourceStack source, StructureBlockEntity structureBlockEntity) {
-        String structureName = structureBlockEntity.getStructureName();
-        if (!structureBlockEntity.saveStructure(true)) {
-            say(source, "Failed to save structure " + structureName);
-        }
-
-        return exportTestStructure(source, structureName);
-    }
-
-    private static int exportTestStructure(CommandSourceStack source, String structurePath) {
-        Path path = Paths.get(StructureUtils.testStructuresDir);
-        ResourceLocation resourceLocation = ResourceLocation.parse(structurePath);
-        Path path1 = source.getLevel().getStructureManager().createAndValidatePathToGeneratedStructure(resourceLocation, ".nbt");
-        Path path2 = NbtToSnbt.convertStructure(CachedOutput.NO_CACHE, path1, resourceLocation.getPath(), path);
-        if (path2 == null) {
-            say(source, "Failed to export " + path1);
-            return 1;
-        } else {
-            try {
-                FileUtil.createDirectoriesSafe(path2.getParent());
-            } catch (IOException var7) {
-                say(source, "Could not create folder " + path2.getParent());
-                LOGGER.error("Could not create export folder", (Throwable)var7);
-                return 1;
-            }
-
-            say(source, "Exported " + structurePath + " to " + path2.toAbsolutePath());
-            return 0;
-        }
-    }
-
-    private static boolean verifyStructureExists(ServerLevel level, String structure) {
-        if (level.getStructureManager().get(ResourceLocation.parse(structure)).isEmpty()) {
-            say(level, "Test structure " + structure + " could not be found", ChatFormatting.RED);
-            return false;
-        } else {
-            return true;
-        }
-    }
-
-    static BlockPos createTestPositionAround(CommandSourceStack source) {
-        BlockPos blockPos = BlockPos.containing(source.getPosition());
-        int y = source.getLevel().getHeightmapPos(Heightmap.Types.WORLD_SURFACE, blockPos).getY();
-        return new BlockPos(blockPos.getX(), y + 1, blockPos.getZ() + 3);
-    }
-
-    static void say(CommandSourceStack source, String message) {
-        source.sendSuccess(() -> Component.literal(message), false);
-    }
-
-    private static int importTestStructure(CommandSourceStack source, String structurePath) {
-        Path path = Paths.get(StructureUtils.testStructuresDir, structurePath + ".snbt");
-        ResourceLocation resourceLocation = ResourceLocation.withDefaultNamespace(structurePath);
-        Path path1 = source.getLevel().getStructureManager().createAndValidatePathToGeneratedStructure(resourceLocation, ".nbt");
-
-        try {
-            BufferedReader bufferedReader = Files.newBufferedReader(path);
-            String string = IOUtils.toString(bufferedReader);
-            Files.createDirectories(path1.getParent());
-
-            try (OutputStream outputStream = Files.newOutputStream(path1)) {
-                NbtIo.writeCompressed(NbtUtils.snbtToStructure(string), outputStream);
-            }
-
-            source.getLevel().getStructureManager().remove(resourceLocation);
-            say(source, "Imported to " + path1.toAbsolutePath());
-            return 0;
-        } catch (CommandSyntaxException | IOException var12) {
-            LOGGER.error("Failed to load structure {}", structurePath, var12);
-            return 1;
-        }
-    }
-
-    static void say(ServerLevel serverLevel, String message, ChatFormatting formatting) {
-        serverLevel.getPlayers(player -> true).forEach(player -> player.sendSystemMessage(Component.literal(message).withStyle(formatting)));
-    }
-
-    public static class Runner {
-        private final TestFinder<TestCommand.Runner> finder;
-
-        public Runner(TestFinder<TestCommand.Runner> finder) {
-            this.finder = finder;
-        }
-
-        public int reset() {
-            TestCommand.stopTests();
-            return TestCommand.toGameTestInfos(this.finder.source(), RetryOptions.noRetries(), this.finder)
-                    .map(TestCommand::resetGameTestInfo)
-                    .toList()
-                    .isEmpty()
-                ? 0
-                : 1;
-        }
-
-        private <T> void logAndRun(Stream<T> structureBlockPos, ToIntFunction<T> testCounter, Runnable onFail, Consumer<Integer> onSuccess) {
-            int i = structureBlockPos.mapToInt(testCounter).sum();
-            if (i == 0) {
-                onFail.run();
-            } else {
-                onSuccess.accept(i);
-            }
-        }
-
-        public int clear() {
-            TestCommand.stopTests();
-            CommandSourceStack commandSourceStack = this.finder.source();
-            ServerLevel level = commandSourceStack.getLevel();
-            GameTestRunner.clearMarkers(level);
-            this.logAndRun(
-                this.finder.findStructureBlockPos(),
-                pos -> {
-                    StructureBlockEntity structureBlockEntity = (StructureBlockEntity)level.getBlockEntity(pos);
-                    if (structureBlockEntity == null) {
-                        return 0;
-                    } else {
-                        BoundingBox structureBoundingBox = StructureUtils.getStructureBoundingBox(structureBlockEntity);
-                        StructureUtils.clearSpaceForStructure(structureBoundingBox, level);
-                        return 1;
-                    }
-                },
-                () -> TestCommand.say(level, "Could not find any structures to clear", ChatFormatting.RED),
-                integer -> TestCommand.say(commandSourceStack, "Cleared " + integer + " structures")
-            );
-            return 1;
-        }
-
-        public int export() {
-            MutableBoolean mutableBoolean = new MutableBoolean(true);
-            CommandSourceStack commandSourceStack = this.finder.source();
-            ServerLevel level = commandSourceStack.getLevel();
-            this.logAndRun(
-                this.finder.findStructureBlockPos(),
-                pos -> {
-                    StructureBlockEntity structureBlockEntity = (StructureBlockEntity)level.getBlockEntity(pos);
-                    if (structureBlockEntity == null) {
-                        TestCommand.say(level, "Structure block entity could not be found", ChatFormatting.RED);
-                        mutableBoolean.setFalse();
-                        return 0;
-                    } else {
-                        if (TestCommand.saveAndExportTestStructure(commandSourceStack, structureBlockEntity) != 0) {
-                            mutableBoolean.setFalse();
-                        }
-
-                        return 1;
-                    }
-                },
-                () -> TestCommand.say(level, "Could not find any structures to export", ChatFormatting.RED),
-                integer -> TestCommand.say(commandSourceStack, "Exported " + integer + " structures")
-            );
-            return mutableBoolean.getValue() ? 0 : 1;
-        }
-
-        int verify() {
-            TestCommand.stopTests();
-            CommandSourceStack commandSourceStack = this.finder.source();
-            ServerLevel level = commandSourceStack.getLevel();
-            BlockPos blockPos = TestCommand.createTestPositionAround(commandSourceStack);
-            Collection<GameTestInfo> collection = Stream.concat(
-                    TestCommand.toGameTestInfos(commandSourceStack, RetryOptions.noRetries(), this.finder),
-                    TestCommand.toGameTestInfo(commandSourceStack, RetryOptions.noRetries(), this.finder, 0)
-                )
-                .toList();
-            GameTestRunner.clearMarkers(level);
-            GameTestRegistry.forgetFailedTests();
-            Collection<GameTestBatch> collection1 = new ArrayList<>();
-
-            for (GameTestInfo gameTestInfo : collection) {
-                for (Rotation rotation : Rotation.values()) {
-                    Collection<GameTestInfo> collection2 = new ArrayList<>();
-
-                    for (int i = 0; i < 100; i++) {
-                        GameTestInfo gameTestInfo1 = new GameTestInfo(gameTestInfo.getTestFunction(), rotation, level, new RetryOptions(1, true));
-                        collection2.add(gameTestInfo1);
-                    }
-
-                    GameTestBatch gameTestBatch = GameTestBatchFactory.toGameTestBatch(
-                        collection2, gameTestInfo.getTestFunction().batchName(), rotation.ordinal()
-                    );
-                    collection1.add(gameTestBatch);
-                }
-            }
-
-            StructureGridSpawner structureGridSpawner = new StructureGridSpawner(blockPos, 10, true);
-            GameTestRunner gameTestRunner = GameTestRunner.Builder.fromBatches(collection1, level)
-                .batcher(GameTestBatchFactory.fromGameTestInfo(100))
-                .newStructureSpawner(structureGridSpawner)
-                .existingStructureSpawner(structureGridSpawner)
-                .haltOnError(true)
-                .build();
-            return TestCommand.trackAndStartRunner(commandSourceStack, level, gameTestRunner);
-        }
-
-        public int run(RetryOptions retryOptions, int rotationSteps, int testsPerRow) {
-            TestCommand.stopTests();
-            CommandSourceStack commandSourceStack = this.finder.source();
-            ServerLevel level = commandSourceStack.getLevel();
-            BlockPos blockPos = TestCommand.createTestPositionAround(commandSourceStack);
-            Collection<GameTestInfo> collection = Stream.concat(
-                    TestCommand.toGameTestInfos(commandSourceStack, retryOptions, this.finder),
-                    TestCommand.toGameTestInfo(commandSourceStack, retryOptions, this.finder, rotationSteps)
-                )
-                .toList();
-            if (collection.isEmpty()) {
-                TestCommand.say(commandSourceStack, "No tests found");
-                return 0;
-            } else {
-                GameTestRunner.clearMarkers(level);
-                GameTestRegistry.forgetFailedTests();
-                TestCommand.say(commandSourceStack, "Running " + collection.size() + " tests...");
-                GameTestRunner gameTestRunner = GameTestRunner.Builder.fromInfo(collection, level)
-                    .newStructureSpawner(new StructureGridSpawner(blockPos, testsPerRow, false))
-                    .build();
-                return TestCommand.trackAndStartRunner(commandSourceStack, level, gameTestRunner);
-            }
-        }
-
-        public int run(int rotationSteps, int testsPerRow) {
-            return this.run(RetryOptions.noRetries(), rotationSteps, testsPerRow);
-        }
-
-        public int run(int rotationSteps) {
-            return this.run(RetryOptions.noRetries(), rotationSteps, 8);
-        }
-
-        public int run(RetryOptions retryOptions, int rotationSteps) {
-            return this.run(retryOptions, rotationSteps, 8);
-        }
-
-        public int run(RetryOptions retryOptions) {
-            return this.run(retryOptions, 0, 8);
-        }
-
-        public int run() {
-            return this.run(RetryOptions.noRetries());
-        }
-
-        public int locate() {
-            TestCommand.say(this.finder.source(), "Started locating test structures, this might take a while..");
-            MutableInt mutableInt = new MutableInt(0);
-            BlockPos blockPos = BlockPos.containing(this.finder.source().getPosition());
-            this.finder
-                .findStructureBlockPos()
-                .forEach(
-                    pos -> {
-                        StructureBlockEntity structureBlockEntity = (StructureBlockEntity)this.finder.source().getLevel().getBlockEntity(pos);
-                        if (structureBlockEntity != null) {
-                            Direction direction = structureBlockEntity.getRotation().rotate(Direction.NORTH);
-                            BlockPos blockPos1 = structureBlockEntity.getBlockPos().relative(direction, 2);
-                            int i1 = (int)direction.getOpposite().toYRot();
-                            String string = String.format("/tp @s %d %d %d %d 0", blockPos1.getX(), blockPos1.getY(), blockPos1.getZ(), i1);
-                            int i2 = blockPos.getX() - pos.getX();
-                            int i3 = blockPos.getZ() - pos.getZ();
-                            int floor = Mth.floor(Mth.sqrt(i2 * i2 + i3 * i3));
-                            Component component = ComponentUtils.wrapInSquareBrackets(
-                                    Component.translatable("chat.coordinates", pos.getX(), pos.getY(), pos.getZ())
-                                )
-                                .withStyle(
-                                    style -> style.withColor(ChatFormatting.GREEN)
-                                        .withClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, string))
-                                        .withHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, Component.translatable("chat.coordinates.tooltip")))
-                                );
-                            Component component1 = Component.literal("Found structure at: ").append(component).append(" (distance: " + floor + ")");
-                            this.finder.source().sendSuccess(() -> component1, false);
-                            mutableInt.increment();
-                        }
-                    }
-                );
-            int i = mutableInt.intValue();
-            if (i == 0) {
-                TestCommand.say(this.finder.source().getLevel(), "No such test structure found", ChatFormatting.RED);
-                return 0;
-            } else {
-                TestCommand.say(this.finder.source().getLevel(), "Finished locating, found " + i + " structure(s)", ChatFormatting.GREEN);
-                return 1;
-            }
-        }
-    }
-
-    record TestBatchSummaryDisplayer(CommandSourceStack source) implements GameTestBatchListener {
-        @Override
-        public void testBatchStarting(GameTestBatch batch) {
-            TestCommand.say(this.source, "Starting batch: " + batch.name());
-        }
-
-        @Override
-        public void testBatchFinished(GameTestBatch batch) {
-        }
-    }
-
-    public record TestSummaryDisplayer(ServerLevel level, MultipleTestTracker tracker) implements GameTestListener {
-        @Override
-        public void testStructureLoaded(GameTestInfo testInfo) {
-        }
-
-        @Override
-        public void testPassed(GameTestInfo test, GameTestRunner runner) {
-            showTestSummaryIfAllDone(this.level, this.tracker);
-        }
-
-        @Override
-        public void testFailed(GameTestInfo test, GameTestRunner runner) {
-            showTestSummaryIfAllDone(this.level, this.tracker);
-        }
-
-        @Override
-        public void testAddedForRerun(GameTestInfo oldTest, GameTestInfo newTest, GameTestRunner runner) {
-            this.tracker.addTestToTrack(newTest);
-        }
-
-        private static void showTestSummaryIfAllDone(ServerLevel level, MultipleTestTracker tracker) {
-            if (tracker.isDone()) {
-                TestCommand.say(level, "GameTest done! " + tracker.getTotalCount() + " tests were run", ChatFormatting.WHITE);
-                if (tracker.hasFailedRequired()) {
-                    TestCommand.say(level, tracker.getFailedRequiredCount() + " required tests failed :(", ChatFormatting.RED);
-                } else {
-                    TestCommand.say(level, "All required tests passed :)", ChatFormatting.GREEN);
-                }
-
-                if (tracker.hasFailedOptional()) {
-                    TestCommand.say(level, tracker.getFailedOptionalCount() + " optional tests failed", ChatFormatting.GRAY);
-                }
-            }
-        }
-    }
-}
diff --git a/net/minecraft/server/MinecraftServer.java b/net/minecraft/server/MinecraftServer.java
index ae220a732c78ab076261f20b5a54c71d7fceb407..ac6bd4ac34b6b0d85dea6ebfeff06c54c0f7b57c 100644
--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -42,7 +42,6 @@ import java.util.UUID;
 import java.util.Map.Entry;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
-import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.LockSupport;
 import java.util.function.BooleanSupplier;
@@ -100,8 +99,6 @@ import net.minecraft.server.packs.resources.MultiPackResourceManager;
 import net.minecraft.server.packs.resources.ResourceManager;
 import net.minecraft.server.players.GameProfileCache;
 import net.minecraft.server.players.PlayerList;
-import net.minecraft.server.players.ServerOpListEntry;
-import net.minecraft.server.players.UserWhiteList;
 import net.minecraft.tags.TagLoader;
 import net.minecraft.util.Crypt;
 import net.minecraft.util.CryptException;
@@ -129,7 +126,6 @@ import net.minecraft.util.profiling.metrics.profiling.ServerMetricsSamplersProvi
 import net.minecraft.util.profiling.metrics.storage.MetricsPersister;
 import net.minecraft.util.thread.ReentrantBlockableEventLoop;
 import net.minecraft.world.Difficulty;
-import net.minecraft.world.RandomSequences;
 import net.minecraft.world.entity.ai.village.VillageSiege;
 import net.minecraft.world.entity.npc.CatSpawner;
 import net.minecraft.world.entity.npc.WanderingTraderSpawner;
@@ -150,7 +146,6 @@ import net.minecraft.world.level.WorldDataConfiguration;
 import net.minecraft.world.level.biome.BiomeManager;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.entity.FuelValues;
-import net.minecraft.world.level.border.BorderChangeListener;
 import net.minecraft.world.level.border.WorldBorder;
 import net.minecraft.world.level.chunk.storage.ChunkIOErrorReporter;
 import net.minecraft.world.level.chunk.storage.RegionStorageInfo;
@@ -161,7 +156,6 @@ import net.minecraft.world.level.levelgen.PhantomSpawner;
 import net.minecraft.world.level.levelgen.WorldOptions;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
 import net.minecraft.world.level.storage.CommandStorage;
-import net.minecraft.world.level.storage.DerivedLevelData;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelData;
 import net.minecraft.world.level.storage.LevelResource;
@@ -918,8 +912,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     public abstract int getFunctionCompilationLevel();
 
-    public abstract boolean shouldRconBroadcast();
-
     public boolean saveAllChunks(boolean suppressLog, boolean flush, boolean forced) {
         // Paper start - add close param
         return this.saveAllChunks(suppressLog, flush, forced, false);
@@ -2364,20 +2356,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return new DataPackConfig(list, list1);
     }
 
-    public void kickUnlistedPlayers(CommandSourceStack commandSource) {
-        if (this.isEnforceWhitelist()) {
-            PlayerList playerList = commandSource.getServer().getPlayerList();
-            if (!playerList.isUsingWhitelist()) return; // Paper - whitelist not enabled
-            UserWhiteList whiteList = playerList.getWhiteList();
-
-            for (ServerPlayer serverPlayer : Lists.newArrayList(playerList.getPlayers())) {
-                if (!whiteList.isWhiteListed(serverPlayer.getGameProfile()) && !this.getPlayerList().isOp(serverPlayer.getGameProfile())) { // Paper - Fix kicking ops when whitelist is reloaded (MC-171420)
-                    serverPlayer.connection.disconnect(net.kyori.adventure.text.Component.text(org.spigotmc.SpigotConfig.whitelistMessage), org.bukkit.event.player.PlayerKickEvent.Cause.WHITELIST); // Paper - use configurable message & kick event cause
-                }
-            }
-        }
-    }
-
     public PackRepository getPackRepository() {
         return this.packRepository;
     }
@@ -2463,20 +2441,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public int getProfilePermissions(GameProfile profile) {
-        if (this.getPlayerList().isOp(profile)) {
-            ServerOpListEntry serverOpListEntry = this.getPlayerList().getOps().get(profile);
-            if (serverOpListEntry != null) {
-                return serverOpListEntry.getLevel();
-            } else if (this.isSingleplayerOwner(profile)) {
-                return 4;
-            } else if (this.isSingleplayer()) {
-                return this.getPlayerList().isAllowCommandsForAllPlayers() ? 4 : 0;
-            } else {
-                return this.getOperatorUserPermissionLevel();
-            }
-        } else {
-            return 0;
-        }
+        return 0;
     }
 
     public abstract boolean isSingleplayerOwner(GameProfile profile);
diff --git a/net/minecraft/server/chase/ChaseClient.java b/net/minecraft/server/chase/ChaseClient.java
index 9f2b32d218ffd7de38eb7612ea37af838c74818c..4b1cc77de0eef30103cf8817158410a8adfc13d4 100644
--- a/net/minecraft/server/chase/ChaseClient.java
+++ b/net/minecraft/server/chase/ChaseClient.java
@@ -18,7 +18,6 @@ import net.minecraft.commands.Commands;
 import net.minecraft.network.chat.CommonComponents;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.server.MinecraftServer;
-import net.minecraft.server.commands.ChaseCommand;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.level.Level;
diff --git a/net/minecraft/server/chase/ChaseServer.java b/net/minecraft/server/chase/ChaseServer.java
index 2fc1c63dd6ba1894ad4d7c70b8e1c8cbac252c57..481c497ab35c2907f50d1fdb24c586489a8e9e90 100644
--- a/net/minecraft/server/chase/ChaseServer.java
+++ b/net/minecraft/server/chase/ChaseServer.java
@@ -14,7 +14,6 @@ import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 import net.minecraft.Util;
-import net.minecraft.server.commands.ChaseCommand;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.players.PlayerList;
 import org.apache.commons.io.IOUtils;
diff --git a/net/minecraft/server/commands/AdvancementCommands.java b/net/minecraft/server/commands/AdvancementCommands.java
deleted file mode 100644
index 9157c1efef669795c8408d2e344a2bfeeabeb842..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/AdvancementCommands.java
+++ /dev/null
@@ -1,473 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.StringArgumentType;
-import com.mojang.brigadier.context.CommandContext;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
-import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import net.minecraft.advancements.Advancement;
-import net.minecraft.advancements.AdvancementHolder;
-import net.minecraft.advancements.AdvancementNode;
-import net.minecraft.advancements.AdvancementProgress;
-import net.minecraft.advancements.AdvancementTree;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.SharedSuggestionProvider;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.commands.arguments.ResourceKeyArgument;
-import net.minecraft.core.registries.Registries;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.level.ServerPlayer;
-
-public class AdvancementCommands {
-    private static final DynamicCommandExceptionType ERROR_NO_ACTION_PERFORMED = new DynamicCommandExceptionType(object -> (Component)object);
-    private static final Dynamic2CommandExceptionType ERROR_CRITERION_NOT_FOUND = new Dynamic2CommandExceptionType(
-        (criteriaName, criterion) -> Component.translatableEscape("commands.advancement.criterionNotFound", criteriaName, criterion)
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("advancement")
-                .requires(commandSourceStack -> commandSourceStack.hasPermission(2))
-                .then(
-                    Commands.literal("grant")
-                        .then(
-                            Commands.argument("targets", EntityArgument.players())
-                                .then(
-                                    Commands.literal("only")
-                                        .then(
-                                            Commands.argument("advancement", ResourceKeyArgument.key(Registries.ADVANCEMENT))
-                                                .executes(
-                                                    commandContext -> perform(
-                                                        commandContext.getSource(),
-                                                        EntityArgument.getPlayers(commandContext, "targets"),
-                                                        AdvancementCommands.Action.GRANT,
-                                                        getAdvancements(
-                                                            commandContext,
-                                                            ResourceKeyArgument.getAdvancement(commandContext, "advancement"),
-                                                            AdvancementCommands.Mode.ONLY
-                                                        )
-                                                    )
-                                                )
-                                                .then(
-                                                    Commands.argument("criterion", StringArgumentType.greedyString())
-                                                        .suggests(
-                                                            (commandContext, suggestionsBuilder) -> SharedSuggestionProvider.suggest(
-                                                                ResourceKeyArgument.getAdvancement(commandContext, "advancement").value().criteria().keySet(),
-                                                                suggestionsBuilder
-                                                            )
-                                                        )
-                                                        .executes(
-                                                            commandContext -> performCriterion(
-                                                                commandContext.getSource(),
-                                                                EntityArgument.getPlayers(commandContext, "targets"),
-                                                                AdvancementCommands.Action.GRANT,
-                                                                ResourceKeyArgument.getAdvancement(commandContext, "advancement"),
-                                                                StringArgumentType.getString(commandContext, "criterion")
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("from")
-                                        .then(
-                                            Commands.argument("advancement", ResourceKeyArgument.key(Registries.ADVANCEMENT))
-                                                .executes(
-                                                    context -> perform(
-                                                        context.getSource(),
-                                                        EntityArgument.getPlayers(context, "targets"),
-                                                        AdvancementCommands.Action.GRANT,
-                                                        getAdvancements(
-                                                            context, ResourceKeyArgument.getAdvancement(context, "advancement"), AdvancementCommands.Mode.FROM
-                                                        )
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("until")
-                                        .then(
-                                            Commands.argument("advancement", ResourceKeyArgument.key(Registries.ADVANCEMENT))
-                                                .executes(
-                                                    context -> perform(
-                                                        context.getSource(),
-                                                        EntityArgument.getPlayers(context, "targets"),
-                                                        AdvancementCommands.Action.GRANT,
-                                                        getAdvancements(
-                                                            context, ResourceKeyArgument.getAdvancement(context, "advancement"), AdvancementCommands.Mode.UNTIL
-                                                        )
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("through")
-                                        .then(
-                                            Commands.argument("advancement", ResourceKeyArgument.key(Registries.ADVANCEMENT))
-                                                .executes(
-                                                    context -> perform(
-                                                        context.getSource(),
-                                                        EntityArgument.getPlayers(context, "targets"),
-                                                        AdvancementCommands.Action.GRANT,
-                                                        getAdvancements(
-                                                            context,
-                                                            ResourceKeyArgument.getAdvancement(context, "advancement"),
-                                                            AdvancementCommands.Mode.THROUGH
-                                                        )
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("everything")
-                                        .executes(
-                                            context -> perform(
-                                                context.getSource(),
-                                                EntityArgument.getPlayers(context, "targets"),
-                                                AdvancementCommands.Action.GRANT,
-                                                context.getSource().getServer().getAdvancements().getAllAdvancements()
-                                            )
-                                        )
-                                )
-                        )
-                )
-                .then(
-                    Commands.literal("revoke")
-                        .then(
-                            Commands.argument("targets", EntityArgument.players())
-                                .then(
-                                    Commands.literal("only")
-                                        .then(
-                                            Commands.argument("advancement", ResourceKeyArgument.key(Registries.ADVANCEMENT))
-                                                .executes(
-                                                    context -> perform(
-                                                        context.getSource(),
-                                                        EntityArgument.getPlayers(context, "targets"),
-                                                        AdvancementCommands.Action.REVOKE,
-                                                        getAdvancements(
-                                                            context, ResourceKeyArgument.getAdvancement(context, "advancement"), AdvancementCommands.Mode.ONLY
-                                                        )
-                                                    )
-                                                )
-                                                .then(
-                                                    Commands.argument("criterion", StringArgumentType.greedyString())
-                                                        .suggests(
-                                                            (commandContext, suggestionsBuilder) -> SharedSuggestionProvider.suggest(
-                                                                ResourceKeyArgument.getAdvancement(commandContext, "advancement").value().criteria().keySet(),
-                                                                suggestionsBuilder
-                                                            )
-                                                        )
-                                                        .executes(
-                                                            commandContext -> performCriterion(
-                                                                commandContext.getSource(),
-                                                                EntityArgument.getPlayers(commandContext, "targets"),
-                                                                AdvancementCommands.Action.REVOKE,
-                                                                ResourceKeyArgument.getAdvancement(commandContext, "advancement"),
-                                                                StringArgumentType.getString(commandContext, "criterion")
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("from")
-                                        .then(
-                                            Commands.argument("advancement", ResourceKeyArgument.key(Registries.ADVANCEMENT))
-                                                .executes(
-                                                    context -> perform(
-                                                        context.getSource(),
-                                                        EntityArgument.getPlayers(context, "targets"),
-                                                        AdvancementCommands.Action.REVOKE,
-                                                        getAdvancements(
-                                                            context, ResourceKeyArgument.getAdvancement(context, "advancement"), AdvancementCommands.Mode.FROM
-                                                        )
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("until")
-                                        .then(
-                                            Commands.argument("advancement", ResourceKeyArgument.key(Registries.ADVANCEMENT))
-                                                .executes(
-                                                    context -> perform(
-                                                        context.getSource(),
-                                                        EntityArgument.getPlayers(context, "targets"),
-                                                        AdvancementCommands.Action.REVOKE,
-                                                        getAdvancements(
-                                                            context, ResourceKeyArgument.getAdvancement(context, "advancement"), AdvancementCommands.Mode.UNTIL
-                                                        )
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("through")
-                                        .then(
-                                            Commands.argument("advancement", ResourceKeyArgument.key(Registries.ADVANCEMENT))
-                                                .executes(
-                                                    context -> perform(
-                                                        context.getSource(),
-                                                        EntityArgument.getPlayers(context, "targets"),
-                                                        AdvancementCommands.Action.REVOKE,
-                                                        getAdvancements(
-                                                            context,
-                                                            ResourceKeyArgument.getAdvancement(context, "advancement"),
-                                                            AdvancementCommands.Mode.THROUGH
-                                                        )
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("everything")
-                                        .executes(
-                                            context -> perform(
-                                                context.getSource(),
-                                                EntityArgument.getPlayers(context, "targets"),
-                                                AdvancementCommands.Action.REVOKE,
-                                                context.getSource().getServer().getAdvancements().getAllAdvancements()
-                                            )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int perform(
-        CommandSourceStack source, Collection<ServerPlayer> targets, AdvancementCommands.Action action, Collection<AdvancementHolder> advancements
-    ) throws CommandSyntaxException {
-        int i = 0;
-
-        for (ServerPlayer serverPlayer : targets) {
-            i += action.perform(serverPlayer, advancements);
-        }
-
-        if (i == 0) {
-            if (advancements.size() == 1) {
-                if (targets.size() == 1) {
-                    throw ERROR_NO_ACTION_PERFORMED.create(
-                        Component.translatable(
-                            action.getKey() + ".one.to.one.failure",
-                            Advancement.name(advancements.iterator().next()),
-                            targets.iterator().next().getDisplayName()
-                        )
-                    );
-                } else {
-                    throw ERROR_NO_ACTION_PERFORMED.create(
-                        Component.translatable(action.getKey() + ".one.to.many.failure", Advancement.name(advancements.iterator().next()), targets.size())
-                    );
-                }
-            } else if (targets.size() == 1) {
-                throw ERROR_NO_ACTION_PERFORMED.create(
-                    Component.translatable(action.getKey() + ".many.to.one.failure", advancements.size(), targets.iterator().next().getDisplayName())
-                );
-            } else {
-                throw ERROR_NO_ACTION_PERFORMED.create(Component.translatable(action.getKey() + ".many.to.many.failure", advancements.size(), targets.size()));
-            }
-        } else {
-            if (advancements.size() == 1) {
-                if (targets.size() == 1) {
-                    source.sendSuccess(
-                        () -> Component.translatable(
-                            action.getKey() + ".one.to.one.success",
-                            Advancement.name(advancements.iterator().next()),
-                            targets.iterator().next().getDisplayName()
-                        ),
-                        true
-                    );
-                } else {
-                    source.sendSuccess(
-                        () -> Component.translatable(action.getKey() + ".one.to.many.success", Advancement.name(advancements.iterator().next()), targets.size()),
-                        true
-                    );
-                }
-            } else if (targets.size() == 1) {
-                source.sendSuccess(
-                    () -> Component.translatable(action.getKey() + ".many.to.one.success", advancements.size(), targets.iterator().next().getDisplayName()),
-                    true
-                );
-            } else {
-                source.sendSuccess(() -> Component.translatable(action.getKey() + ".many.to.many.success", advancements.size(), targets.size()), true);
-            }
-
-            return i;
-        }
-    }
-
-    private static int performCriterion(
-        CommandSourceStack source, Collection<ServerPlayer> targets, AdvancementCommands.Action action, AdvancementHolder advancement, String criterionName
-    ) throws CommandSyntaxException {
-        int i = 0;
-        Advancement advancement1 = advancement.value();
-        if (!advancement1.criteria().containsKey(criterionName)) {
-            throw ERROR_CRITERION_NOT_FOUND.create(Advancement.name(advancement), criterionName);
-        } else {
-            for (ServerPlayer serverPlayer : targets) {
-                if (action.performCriterion(serverPlayer, advancement, criterionName)) {
-                    i++;
-                }
-            }
-
-            if (i == 0) {
-                if (targets.size() == 1) {
-                    throw ERROR_NO_ACTION_PERFORMED.create(
-                        Component.translatable(
-                            action.getKey() + ".criterion.to.one.failure",
-                            criterionName,
-                            Advancement.name(advancement),
-                            targets.iterator().next().getDisplayName()
-                        )
-                    );
-                } else {
-                    throw ERROR_NO_ACTION_PERFORMED.create(
-                        Component.translatable(action.getKey() + ".criterion.to.many.failure", criterionName, Advancement.name(advancement), targets.size())
-                    );
-                }
-            } else {
-                if (targets.size() == 1) {
-                    source.sendSuccess(
-                        () -> Component.translatable(
-                            action.getKey() + ".criterion.to.one.success",
-                            criterionName,
-                            Advancement.name(advancement),
-                            targets.iterator().next().getDisplayName()
-                        ),
-                        true
-                    );
-                } else {
-                    source.sendSuccess(
-                        () -> Component.translatable(
-                            action.getKey() + ".criterion.to.many.success", criterionName, Advancement.name(advancement), targets.size()
-                        ),
-                        true
-                    );
-                }
-
-                return i;
-            }
-        }
-    }
-
-    private static List<AdvancementHolder> getAdvancements(
-        CommandContext<CommandSourceStack> context, AdvancementHolder advancement, AdvancementCommands.Mode mode
-    ) {
-        AdvancementTree advancementTree = context.getSource().getServer().getAdvancements().tree();
-        AdvancementNode advancementNode = advancementTree.get(advancement);
-        if (advancementNode == null) {
-            return List.of(advancement);
-        } else {
-            List<AdvancementHolder> list = new ArrayList<>();
-            if (mode.parents) {
-                for (AdvancementNode advancementNode1 = advancementNode.parent(); advancementNode1 != null; advancementNode1 = advancementNode1.parent()) {
-                    list.add(advancementNode1.holder());
-                }
-            }
-
-            list.add(advancement);
-            if (mode.children) {
-                addChildren(advancementNode, list);
-            }
-
-            return list;
-        }
-    }
-
-    private static void addChildren(AdvancementNode node, List<AdvancementHolder> output) {
-        for (AdvancementNode advancementNode : node.children()) {
-            output.add(advancementNode.holder());
-            addChildren(advancementNode, output);
-        }
-    }
-
-    static enum Action {
-        GRANT("grant") {
-            @Override
-            protected boolean perform(ServerPlayer player, AdvancementHolder advancement) {
-                AdvancementProgress orStartProgress = player.getAdvancements().getOrStartProgress(advancement);
-                if (orStartProgress.isDone()) {
-                    return false;
-                } else {
-                    for (String string : orStartProgress.getRemainingCriteria()) {
-                        player.getAdvancements().award(advancement, string);
-                    }
-
-                    return true;
-                }
-            }
-
-            @Override
-            protected boolean performCriterion(ServerPlayer player, AdvancementHolder advancement, String criterionName) {
-                return player.getAdvancements().award(advancement, criterionName);
-            }
-        },
-        REVOKE("revoke") {
-            @Override
-            protected boolean perform(ServerPlayer player, AdvancementHolder advancement) {
-                AdvancementProgress orStartProgress = player.getAdvancements().getOrStartProgress(advancement);
-                if (!orStartProgress.hasProgress()) {
-                    return false;
-                } else {
-                    for (String string : orStartProgress.getCompletedCriteria()) {
-                        player.getAdvancements().revoke(advancement, string);
-                    }
-
-                    return true;
-                }
-            }
-
-            @Override
-            protected boolean performCriterion(ServerPlayer player, AdvancementHolder advancement, String criterionName) {
-                return player.getAdvancements().revoke(advancement, criterionName);
-            }
-        };
-
-        private final String key;
-
-        Action(final String key) {
-            this.key = "commands.advancement." + key;
-        }
-
-        public int perform(ServerPlayer player, Iterable<AdvancementHolder> advancements) {
-            int i = 0;
-
-            for (AdvancementHolder advancementHolder : advancements) {
-                if (this.perform(player, advancementHolder)) {
-                    i++;
-                }
-            }
-
-            return i;
-        }
-
-        protected abstract boolean perform(ServerPlayer player, AdvancementHolder advancement);
-
-        protected abstract boolean performCriterion(ServerPlayer player, AdvancementHolder advancement, String criterionName);
-
-        protected String getKey() {
-            return this.key;
-        }
-    }
-
-    static enum Mode {
-        ONLY(false, false),
-        THROUGH(true, true),
-        FROM(false, true),
-        UNTIL(true, false),
-        EVERYTHING(true, true);
-
-        final boolean parents;
-        final boolean children;
-
-        private Mode(final boolean parents, final boolean children) {
-            this.parents = parents;
-            this.children = children;
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/BanIpCommands.java b/net/minecraft/server/commands/BanIpCommands.java
deleted file mode 100644
index 83e8d47244cf5b1c464cf1e998ad8dcf2fa73ca1..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/BanIpCommands.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.google.common.net.InetAddresses;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.StringArgumentType;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import java.util.List;
-import javax.annotation.Nullable;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.MessageArgument;
-import net.minecraft.commands.arguments.selector.EntitySelector;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.server.players.IpBanList;
-import net.minecraft.server.players.IpBanListEntry;
-
-public class BanIpCommands {
-    private static final SimpleCommandExceptionType ERROR_INVALID_IP = new SimpleCommandExceptionType(Component.translatable("commands.banip.invalid"));
-    private static final SimpleCommandExceptionType ERROR_ALREADY_BANNED = new SimpleCommandExceptionType(Component.translatable("commands.banip.failed"));
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("ban-ip")
-                .requires(source -> source.hasPermission(3))
-                .then(
-                    Commands.argument("target", StringArgumentType.word())
-                        .executes(context -> banIpOrName(context.getSource(), StringArgumentType.getString(context, "target"), null))
-                        .then(
-                            Commands.argument("reason", MessageArgument.message())
-                                .executes(
-                                    context -> banIpOrName(
-                                        context.getSource(), StringArgumentType.getString(context, "target"), MessageArgument.getMessage(context, "reason")
-                                    )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int banIpOrName(CommandSourceStack source, String username, @Nullable Component reason) throws CommandSyntaxException {
-        if (InetAddresses.isInetAddress(username)) {
-            return banIp(source, username, reason);
-        } else {
-            ServerPlayer playerByName = source.getServer().getPlayerList().getPlayerByName(username);
-            if (playerByName != null) {
-                return banIp(source, playerByName.getIpAddress(), reason);
-            } else {
-                throw ERROR_INVALID_IP.create();
-            }
-        }
-    }
-
-    private static int banIp(CommandSourceStack source, String ip, @Nullable Component reason) throws CommandSyntaxException {
-        IpBanList ipBans = source.getServer().getPlayerList().getIpBans();
-        if (ipBans.isBanned(ip)) {
-            throw ERROR_ALREADY_BANNED.create();
-        } else {
-            List<ServerPlayer> playersWithAddress = source.getServer().getPlayerList().getPlayersWithAddress(ip);
-            IpBanListEntry ipBanListEntry = new IpBanListEntry(ip, null, source.getTextName(), null, reason == null ? null : reason.getString());
-            ipBans.add(ipBanListEntry);
-            source.sendSuccess(() -> Component.translatable("commands.banip.success", ip, ipBanListEntry.getReason()), true);
-            if (!playersWithAddress.isEmpty()) {
-                source.sendSuccess(
-                    () -> Component.translatable("commands.banip.info", playersWithAddress.size(), EntitySelector.joinNames(playersWithAddress)), true
-                );
-            }
-
-            for (ServerPlayer serverPlayer : playersWithAddress) {
-                serverPlayer.connection.disconnect(Component.translatable("multiplayer.disconnect.ip_banned"), org.bukkit.event.player.PlayerKickEvent.Cause.IP_BANNED); // Paper - kick event cause
-            }
-
-            return playersWithAddress.size();
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/BanListCommands.java b/net/minecraft/server/commands/BanListCommands.java
deleted file mode 100644
index 9c570d901592eb6951c8b118fa521862b35cae32..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/BanListCommands.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import com.mojang.brigadier.CommandDispatcher;
-import java.util.Collection;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.players.BanListEntry;
-import net.minecraft.server.players.PlayerList;
-
-public class BanListCommands {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("banlist")
-                .requires(source -> source.hasPermission(3))
-                .executes(
-                    context -> {
-                        PlayerList playerList = context.getSource().getServer().getPlayerList();
-                        return showList(
-                            context.getSource(), Lists.newArrayList(Iterables.concat(playerList.getBans().getEntries(), playerList.getIpBans().getEntries()))
-                        );
-                    }
-                )
-                .then(
-                    Commands.literal("ips")
-                        .executes(context -> showList(context.getSource(), context.getSource().getServer().getPlayerList().getIpBans().getEntries()))
-                )
-                .then(
-                    Commands.literal("players")
-                        .executes(context -> showList(context.getSource(), context.getSource().getServer().getPlayerList().getBans().getEntries()))
-                )
-        );
-    }
-
-    private static int showList(CommandSourceStack source, Collection<? extends BanListEntry<?>> bannedPlayerList) {
-        if (bannedPlayerList.isEmpty()) {
-            source.sendSuccess(() -> Component.translatable("commands.banlist.none"), false);
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.banlist.list", bannedPlayerList.size()), false);
-
-            for (BanListEntry<?> banListEntry : bannedPlayerList) {
-                source.sendSuccess(
-                    () -> Component.translatable("commands.banlist.entry", banListEntry.getDisplayName(), banListEntry.getSource(), banListEntry.getReason()),
-                    false
-                );
-            }
-        }
-
-        return bannedPlayerList.size();
-    }
-}
diff --git a/net/minecraft/server/commands/BanPlayerCommands.java b/net/minecraft/server/commands/BanPlayerCommands.java
deleted file mode 100644
index b6527581c08675a2ad4400e912bb85abf1d46a2b..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/BanPlayerCommands.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.authlib.GameProfile;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import java.util.Collection;
-import javax.annotation.Nullable;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.GameProfileArgument;
-import net.minecraft.commands.arguments.MessageArgument;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.server.players.UserBanList;
-import net.minecraft.server.players.UserBanListEntry;
-
-public class BanPlayerCommands {
-    private static final SimpleCommandExceptionType ERROR_ALREADY_BANNED = new SimpleCommandExceptionType(Component.translatable("commands.ban.failed"));
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("ban")
-                .requires(source -> source.hasPermission(3))
-                .then(
-                    Commands.argument("targets", GameProfileArgument.gameProfile())
-                        .executes(context -> banPlayers(context.getSource(), GameProfileArgument.getGameProfiles(context, "targets"), null))
-                        .then(
-                            Commands.argument("reason", MessageArgument.message())
-                                .executes(
-                                    context -> banPlayers(
-                                        context.getSource(),
-                                        GameProfileArgument.getGameProfiles(context, "targets"),
-                                        MessageArgument.getMessage(context, "reason")
-                                    )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int banPlayers(CommandSourceStack source, Collection<GameProfile> gameProfiles, @Nullable Component reason) throws CommandSyntaxException {
-        UserBanList bans = source.getServer().getPlayerList().getBans();
-        int i = 0;
-
-        for (GameProfile gameProfile : gameProfiles) {
-            if (!bans.isBanned(gameProfile)) {
-                UserBanListEntry userBanListEntry = new UserBanListEntry(
-                    gameProfile, null, source.getTextName(), null, reason == null ? null : reason.getString()
-                );
-                bans.add(userBanListEntry);
-                i++;
-                source.sendSuccess(
-                    () -> Component.translatable("commands.ban.success", Component.literal(gameProfile.getName()), userBanListEntry.getReason()), true
-                );
-                ServerPlayer player = source.getServer().getPlayerList().getPlayer(gameProfile.getId());
-                if (player != null) {
-                    player.connection.disconnect(Component.translatable("multiplayer.disconnect.banned"), org.bukkit.event.player.PlayerKickEvent.Cause.BANNED); // Paper - kick event cause
-                }
-            }
-        }
-
-        if (i == 0) {
-            throw ERROR_ALREADY_BANNED.create();
-        } else {
-            return i;
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/BossBarCommands.java b/net/minecraft/server/commands/BossBarCommands.java
deleted file mode 100644
index e2d9a1395152312f4954404051cb235743d4293c..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/BossBarCommands.java
+++ /dev/null
@@ -1,399 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.BoolArgumentType;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import com.mojang.brigadier.context.CommandContext;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import com.mojang.brigadier.suggestion.SuggestionProvider;
-import java.util.Collection;
-import java.util.Collections;
-import net.minecraft.commands.CommandBuildContext;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.SharedSuggestionProvider;
-import net.minecraft.commands.arguments.ComponentArgument;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.commands.arguments.ResourceLocationArgument;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.ComponentUtils;
-import net.minecraft.resources.ResourceLocation;
-import net.minecraft.server.bossevents.CustomBossEvent;
-import net.minecraft.server.bossevents.CustomBossEvents;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.world.BossEvent;
-import net.minecraft.world.entity.player.Player;
-
-public class BossBarCommands {
-    private static final DynamicCommandExceptionType ERROR_ALREADY_EXISTS = new DynamicCommandExceptionType(
-        bossBarId -> Component.translatableEscape("commands.bossbar.create.failed", bossBarId)
-    );
-    private static final DynamicCommandExceptionType ERROR_DOESNT_EXIST = new DynamicCommandExceptionType(
-        bossBarId -> Component.translatableEscape("commands.bossbar.unknown", bossBarId)
-    );
-    private static final SimpleCommandExceptionType ERROR_NO_PLAYER_CHANGE = new SimpleCommandExceptionType(
-        Component.translatable("commands.bossbar.set.players.unchanged")
-    );
-    private static final SimpleCommandExceptionType ERROR_NO_NAME_CHANGE = new SimpleCommandExceptionType(
-        Component.translatable("commands.bossbar.set.name.unchanged")
-    );
-    private static final SimpleCommandExceptionType ERROR_NO_COLOR_CHANGE = new SimpleCommandExceptionType(
-        Component.translatable("commands.bossbar.set.color.unchanged")
-    );
-    private static final SimpleCommandExceptionType ERROR_NO_STYLE_CHANGE = new SimpleCommandExceptionType(
-        Component.translatable("commands.bossbar.set.style.unchanged")
-    );
-    private static final SimpleCommandExceptionType ERROR_NO_VALUE_CHANGE = new SimpleCommandExceptionType(
-        Component.translatable("commands.bossbar.set.value.unchanged")
-    );
-    private static final SimpleCommandExceptionType ERROR_NO_MAX_CHANGE = new SimpleCommandExceptionType(
-        Component.translatable("commands.bossbar.set.max.unchanged")
-    );
-    private static final SimpleCommandExceptionType ERROR_ALREADY_HIDDEN = new SimpleCommandExceptionType(
-        Component.translatable("commands.bossbar.set.visibility.unchanged.hidden")
-    );
-    private static final SimpleCommandExceptionType ERROR_ALREADY_VISIBLE = new SimpleCommandExceptionType(
-        Component.translatable("commands.bossbar.set.visibility.unchanged.visible")
-    );
-    public static final SuggestionProvider<CommandSourceStack> SUGGEST_BOSS_BAR = (context, builder) -> SharedSuggestionProvider.suggestResource(
-        context.getSource().getServer().getCustomBossEvents().getIds(), builder
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext context) {
-        dispatcher.register(
-            Commands.literal("bossbar")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.literal("add")
-                        .then(
-                            Commands.argument("id", ResourceLocationArgument.id())
-                                .then(
-                                    Commands.argument("name", ComponentArgument.textComponent(context))
-                                        .executes(
-                                            context1 -> createBar(
-                                                context1.getSource(),
-                                                ResourceLocationArgument.getId(context1, "id"),
-                                                ComponentArgument.getComponent(context1, "name")
-                                            )
-                                        )
-                                )
-                        )
-                )
-                .then(
-                    Commands.literal("remove")
-                        .then(
-                            Commands.argument("id", ResourceLocationArgument.id())
-                                .suggests(SUGGEST_BOSS_BAR)
-                                .executes(context1 -> removeBar(context1.getSource(), getBossBar(context1)))
-                        )
-                )
-                .then(Commands.literal("list").executes(context1 -> listBars(context1.getSource())))
-                .then(
-                    Commands.literal("set")
-                        .then(
-                            Commands.argument("id", ResourceLocationArgument.id())
-                                .suggests(SUGGEST_BOSS_BAR)
-                                .then(
-                                    Commands.literal("name")
-                                        .then(
-                                            Commands.argument("name", ComponentArgument.textComponent(context))
-                                                .executes(
-                                                    context1 -> setName(
-                                                        context1.getSource(), getBossBar(context1), ComponentArgument.getComponent(context1, "name")
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("color")
-                                        .then(
-                                            Commands.literal("pink")
-                                                .executes(context1 -> setColor(context1.getSource(), getBossBar(context1), BossEvent.BossBarColor.PINK))
-                                        )
-                                        .then(
-                                            Commands.literal("blue")
-                                                .executes(context1 -> setColor(context1.getSource(), getBossBar(context1), BossEvent.BossBarColor.BLUE))
-                                        )
-                                        .then(
-                                            Commands.literal("red")
-                                                .executes(context1 -> setColor(context1.getSource(), getBossBar(context1), BossEvent.BossBarColor.RED))
-                                        )
-                                        .then(
-                                            Commands.literal("green")
-                                                .executes(context1 -> setColor(context1.getSource(), getBossBar(context1), BossEvent.BossBarColor.GREEN))
-                                        )
-                                        .then(
-                                            Commands.literal("yellow")
-                                                .executes(context1 -> setColor(context1.getSource(), getBossBar(context1), BossEvent.BossBarColor.YELLOW))
-                                        )
-                                        .then(
-                                            Commands.literal("purple")
-                                                .executes(context1 -> setColor(context1.getSource(), getBossBar(context1), BossEvent.BossBarColor.PURPLE))
-                                        )
-                                        .then(
-                                            Commands.literal("white")
-                                                .executes(context1 -> setColor(context1.getSource(), getBossBar(context1), BossEvent.BossBarColor.WHITE))
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("style")
-                                        .then(
-                                            Commands.literal("progress")
-                                                .executes(context1 -> setStyle(context1.getSource(), getBossBar(context1), BossEvent.BossBarOverlay.PROGRESS))
-                                        )
-                                        .then(
-                                            Commands.literal("notched_6")
-                                                .executes(context1 -> setStyle(context1.getSource(), getBossBar(context1), BossEvent.BossBarOverlay.NOTCHED_6))
-                                        )
-                                        .then(
-                                            Commands.literal("notched_10")
-                                                .executes(context1 -> setStyle(context1.getSource(), getBossBar(context1), BossEvent.BossBarOverlay.NOTCHED_10))
-                                        )
-                                        .then(
-                                            Commands.literal("notched_12")
-                                                .executes(context1 -> setStyle(context1.getSource(), getBossBar(context1), BossEvent.BossBarOverlay.NOTCHED_12))
-                                        )
-                                        .then(
-                                            Commands.literal("notched_20")
-                                                .executes(context1 -> setStyle(context1.getSource(), getBossBar(context1), BossEvent.BossBarOverlay.NOTCHED_20))
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("value")
-                                        .then(
-                                            Commands.argument("value", IntegerArgumentType.integer(0))
-                                                .executes(
-                                                    context1 -> setValue(
-                                                        context1.getSource(), getBossBar(context1), IntegerArgumentType.getInteger(context1, "value")
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("max")
-                                        .then(
-                                            Commands.argument("max", IntegerArgumentType.integer(1))
-                                                .executes(
-                                                    context1 -> setMax(
-                                                        context1.getSource(), getBossBar(context1), IntegerArgumentType.getInteger(context1, "max")
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("visible")
-                                        .then(
-                                            Commands.argument("visible", BoolArgumentType.bool())
-                                                .executes(
-                                                    context1 -> setVisible(
-                                                        context1.getSource(), getBossBar(context1), BoolArgumentType.getBool(context1, "visible")
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("players")
-                                        .executes(context1 -> setPlayers(context1.getSource(), getBossBar(context1), Collections.emptyList()))
-                                        .then(
-                                            Commands.argument("targets", EntityArgument.players())
-                                                .executes(
-                                                    context1 -> setPlayers(
-                                                        context1.getSource(), getBossBar(context1), EntityArgument.getOptionalPlayers(context1, "targets")
-                                                    )
-                                                )
-                                        )
-                                )
-                        )
-                )
-                .then(
-                    Commands.literal("get")
-                        .then(
-                            Commands.argument("id", ResourceLocationArgument.id())
-                                .suggests(SUGGEST_BOSS_BAR)
-                                .then(Commands.literal("value").executes(context1 -> getValue(context1.getSource(), getBossBar(context1))))
-                                .then(Commands.literal("max").executes(context1 -> getMax(context1.getSource(), getBossBar(context1))))
-                                .then(Commands.literal("visible").executes(context1 -> getVisible(context1.getSource(), getBossBar(context1))))
-                                .then(Commands.literal("players").executes(context1 -> getPlayers(context1.getSource(), getBossBar(context1))))
-                        )
-                )
-        );
-    }
-
-    private static int getValue(CommandSourceStack source, CustomBossEvent bossbar) {
-        source.sendSuccess(() -> Component.translatable("commands.bossbar.get.value", bossbar.getDisplayName(), bossbar.getValue()), true);
-        return bossbar.getValue();
-    }
-
-    private static int getMax(CommandSourceStack source, CustomBossEvent bossbar) {
-        source.sendSuccess(() -> Component.translatable("commands.bossbar.get.max", bossbar.getDisplayName(), bossbar.getMax()), true);
-        return bossbar.getMax();
-    }
-
-    private static int getVisible(CommandSourceStack source, CustomBossEvent bossbar) {
-        if (bossbar.isVisible()) {
-            source.sendSuccess(() -> Component.translatable("commands.bossbar.get.visible.visible", bossbar.getDisplayName()), true);
-            return 1;
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.bossbar.get.visible.hidden", bossbar.getDisplayName()), true);
-            return 0;
-        }
-    }
-
-    private static int getPlayers(CommandSourceStack source, CustomBossEvent bossbar) {
-        if (bossbar.getPlayers().isEmpty()) {
-            source.sendSuccess(() -> Component.translatable("commands.bossbar.get.players.none", bossbar.getDisplayName()), true);
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.bossbar.get.players.some",
-                    bossbar.getDisplayName(),
-                    bossbar.getPlayers().size(),
-                    ComponentUtils.formatList(bossbar.getPlayers(), Player::getDisplayName)
-                ),
-                true
-            );
-        }
-
-        return bossbar.getPlayers().size();
-    }
-
-    private static int setVisible(CommandSourceStack source, CustomBossEvent bossbar, boolean visible) throws CommandSyntaxException {
-        if (bossbar.isVisible() == visible) {
-            if (visible) {
-                throw ERROR_ALREADY_VISIBLE.create();
-            } else {
-                throw ERROR_ALREADY_HIDDEN.create();
-            }
-        } else {
-            bossbar.setVisible(visible);
-            if (visible) {
-                source.sendSuccess(() -> Component.translatable("commands.bossbar.set.visible.success.visible", bossbar.getDisplayName()), true);
-            } else {
-                source.sendSuccess(() -> Component.translatable("commands.bossbar.set.visible.success.hidden", bossbar.getDisplayName()), true);
-            }
-
-            return 0;
-        }
-    }
-
-    private static int setValue(CommandSourceStack source, CustomBossEvent bossbar, int value) throws CommandSyntaxException {
-        if (bossbar.getValue() == value) {
-            throw ERROR_NO_VALUE_CHANGE.create();
-        } else {
-            bossbar.setValue(value);
-            source.sendSuccess(() -> Component.translatable("commands.bossbar.set.value.success", bossbar.getDisplayName(), value), true);
-            return value;
-        }
-    }
-
-    private static int setMax(CommandSourceStack source, CustomBossEvent bossbar, int max) throws CommandSyntaxException {
-        if (bossbar.getMax() == max) {
-            throw ERROR_NO_MAX_CHANGE.create();
-        } else {
-            bossbar.setMax(max);
-            source.sendSuccess(() -> Component.translatable("commands.bossbar.set.max.success", bossbar.getDisplayName(), max), true);
-            return max;
-        }
-    }
-
-    private static int setColor(CommandSourceStack source, CustomBossEvent bossbar, BossEvent.BossBarColor color) throws CommandSyntaxException {
-        if (bossbar.getColor().equals(color)) {
-            throw ERROR_NO_COLOR_CHANGE.create();
-        } else {
-            bossbar.setColor(color);
-            source.sendSuccess(() -> Component.translatable("commands.bossbar.set.color.success", bossbar.getDisplayName()), true);
-            return 0;
-        }
-    }
-
-    private static int setStyle(CommandSourceStack source, CustomBossEvent bossbar, BossEvent.BossBarOverlay style) throws CommandSyntaxException {
-        if (bossbar.getOverlay().equals(style)) {
-            throw ERROR_NO_STYLE_CHANGE.create();
-        } else {
-            bossbar.setOverlay(style);
-            source.sendSuccess(() -> Component.translatable("commands.bossbar.set.style.success", bossbar.getDisplayName()), true);
-            return 0;
-        }
-    }
-
-    private static int setName(CommandSourceStack source, CustomBossEvent bossbar, Component name) throws CommandSyntaxException {
-        Component component = ComponentUtils.updateForEntity(source, name, null, 0);
-        if (bossbar.getName().equals(component)) {
-            throw ERROR_NO_NAME_CHANGE.create();
-        } else {
-            bossbar.setName(component);
-            source.sendSuccess(() -> Component.translatable("commands.bossbar.set.name.success", bossbar.getDisplayName()), true);
-            return 0;
-        }
-    }
-
-    private static int setPlayers(CommandSourceStack source, CustomBossEvent bossbar, Collection<ServerPlayer> players) throws CommandSyntaxException {
-        boolean flag = bossbar.setPlayers(players);
-        if (!flag) {
-            throw ERROR_NO_PLAYER_CHANGE.create();
-        } else {
-            if (bossbar.getPlayers().isEmpty()) {
-                source.sendSuccess(() -> Component.translatable("commands.bossbar.set.players.success.none", bossbar.getDisplayName()), true);
-            } else {
-                source.sendSuccess(
-                    () -> Component.translatable(
-                        "commands.bossbar.set.players.success.some",
-                        bossbar.getDisplayName(),
-                        players.size(),
-                        ComponentUtils.formatList(players, Player::getDisplayName)
-                    ),
-                    true
-                );
-            }
-
-            return bossbar.getPlayers().size();
-        }
-    }
-
-    private static int listBars(CommandSourceStack source) {
-        Collection<CustomBossEvent> events = source.getServer().getCustomBossEvents().getEvents();
-        if (events.isEmpty()) {
-            source.sendSuccess(() -> Component.translatable("commands.bossbar.list.bars.none"), false);
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.bossbar.list.bars.some", events.size(), ComponentUtils.formatList(events, CustomBossEvent::getDisplayName)
-                ),
-                false
-            );
-        }
-
-        return events.size();
-    }
-
-    private static int createBar(CommandSourceStack source, ResourceLocation id, Component displayName) throws CommandSyntaxException {
-        CustomBossEvents customBossEvents = source.getServer().getCustomBossEvents();
-        if (customBossEvents.get(id) != null) {
-            throw ERROR_ALREADY_EXISTS.create(id.toString());
-        } else {
-            CustomBossEvent customBossEvent = customBossEvents.create(id, ComponentUtils.updateForEntity(source, displayName, null, 0));
-            source.sendSuccess(() -> Component.translatable("commands.bossbar.create.success", customBossEvent.getDisplayName()), true);
-            return customBossEvents.getEvents().size();
-        }
-    }
-
-    private static int removeBar(CommandSourceStack source, CustomBossEvent bossbar) {
-        CustomBossEvents customBossEvents = source.getServer().getCustomBossEvents();
-        bossbar.removeAllPlayers();
-        customBossEvents.remove(bossbar);
-        source.sendSuccess(() -> Component.translatable("commands.bossbar.remove.success", bossbar.getDisplayName()), true);
-        return customBossEvents.getEvents().size();
-    }
-
-    public static CustomBossEvent getBossBar(CommandContext<CommandSourceStack> source) throws CommandSyntaxException {
-        ResourceLocation id = ResourceLocationArgument.getId(source, "id");
-        CustomBossEvent customBossEvent = source.getSource().getServer().getCustomBossEvents().get(id);
-        if (customBossEvent == null) {
-            throw ERROR_DOESNT_EXIST.create(id.toString());
-        } else {
-            return customBossEvent;
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/ChaseCommand.java b/net/minecraft/server/commands/ChaseCommand.java
deleted file mode 100644
index ba16a4ec63e4bd81d8a8e970e20914648e9b809a..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/ChaseCommand.java
+++ /dev/null
@@ -1,143 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.google.common.collect.BiMap;
-import com.google.common.collect.ImmutableBiMap;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import com.mojang.brigadier.arguments.StringArgumentType;
-import com.mojang.logging.LogUtils;
-import java.io.IOException;
-import javax.annotation.Nullable;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.network.chat.Component;
-import net.minecraft.resources.ResourceKey;
-import net.minecraft.server.chase.ChaseClient;
-import net.minecraft.server.chase.ChaseServer;
-import net.minecraft.world.level.Level;
-import org.slf4j.Logger;
-
-public class ChaseCommand {
-    private static final Logger LOGGER = LogUtils.getLogger();
-    private static final String DEFAULT_CONNECT_HOST = "localhost";
-    private static final String DEFAULT_BIND_ADDRESS = "0.0.0.0";
-    private static final int DEFAULT_PORT = 10000;
-    private static final int BROADCAST_INTERVAL_MS = 100;
-    public static BiMap<String, ResourceKey<Level>> DIMENSION_NAMES = ImmutableBiMap.of("o", Level.OVERWORLD, "n", Level.NETHER, "e", Level.END);
-    @Nullable
-    private static ChaseServer chaseServer;
-    @Nullable
-    private static ChaseClient chaseClient;
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("chase")
-                .then(
-                    Commands.literal("follow")
-                        .then(
-                            Commands.argument("host", StringArgumentType.string())
-                                .executes(context -> follow(context.getSource(), StringArgumentType.getString(context, "host"), 10000))
-                                .then(
-                                    Commands.argument("port", IntegerArgumentType.integer(1, 65535))
-                                        .executes(
-                                            context -> follow(
-                                                context.getSource(),
-                                                StringArgumentType.getString(context, "host"),
-                                                IntegerArgumentType.getInteger(context, "port")
-                                            )
-                                        )
-                                )
-                        )
-                        .executes(context -> follow(context.getSource(), "localhost", 10000))
-                )
-                .then(
-                    Commands.literal("lead")
-                        .then(
-                            Commands.argument("bind_address", StringArgumentType.string())
-                                .executes(context -> lead(context.getSource(), StringArgumentType.getString(context, "bind_address"), 10000))
-                                .then(
-                                    Commands.argument("port", IntegerArgumentType.integer(1024, 65535))
-                                        .executes(
-                                            context -> lead(
-                                                context.getSource(),
-                                                StringArgumentType.getString(context, "bind_address"),
-                                                IntegerArgumentType.getInteger(context, "port")
-                                            )
-                                        )
-                                )
-                        )
-                        .executes(context -> lead(context.getSource(), "0.0.0.0", 10000))
-                )
-                .then(Commands.literal("stop").executes(context -> stop(context.getSource())))
-        );
-    }
-
-    private static int stop(CommandSourceStack source) {
-        if (chaseClient != null) {
-            chaseClient.stop();
-            source.sendSuccess(() -> Component.literal("You have now stopped chasing"), false);
-            chaseClient = null;
-        }
-
-        if (chaseServer != null) {
-            chaseServer.stop();
-            source.sendSuccess(() -> Component.literal("You are no longer being chased"), false);
-            chaseServer = null;
-        }
-
-        return 0;
-    }
-
-    private static boolean alreadyRunning(CommandSourceStack source) {
-        if (chaseServer != null) {
-            source.sendFailure(Component.literal("Chase server is already running. Stop it using /chase stop"));
-            return true;
-        } else if (chaseClient != null) {
-            source.sendFailure(Component.literal("You are already chasing someone. Stop it using /chase stop"));
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    private static int lead(CommandSourceStack source, String bindAddress, int port) {
-        if (alreadyRunning(source)) {
-            return 0;
-        } else {
-            chaseServer = new ChaseServer(bindAddress, port, source.getServer().getPlayerList(), 100);
-
-            try {
-                chaseServer.start();
-                source.sendSuccess(
-                    () -> Component.literal("Chase server is now running on port " + port + ". Clients can follow you using /chase follow <ip> <port>"), false
-                );
-            } catch (IOException var4) {
-                LOGGER.error("Failed to start chase server", (Throwable)var4);
-                source.sendFailure(Component.literal("Failed to start chase server on port " + port));
-                chaseServer = null;
-            }
-
-            return 0;
-        }
-    }
-
-    private static int follow(CommandSourceStack source, String host, int port) {
-        if (alreadyRunning(source)) {
-            return 0;
-        } else {
-            chaseClient = new ChaseClient(host, port, source.getServer());
-            chaseClient.start();
-            source.sendSuccess(
-                () -> Component.literal(
-                    "You are now chasing "
-                        + host
-                        + ":"
-                        + port
-                        + ". If that server does '/chase lead' then you will automatically go to the same position. Use '/chase stop' to stop chasing."
-                ),
-                false
-            );
-            return 0;
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/CloneCommands.java b/net/minecraft/server/commands/CloneCommands.java
deleted file mode 100644
index 20c169fb605e9ce368c3bd3f84159564d198677e..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/CloneCommands.java
+++ /dev/null
@@ -1,366 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.google.common.collect.Lists;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.builder.ArgumentBuilder;
-import com.mojang.brigadier.context.CommandContext;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import java.util.Deque;
-import java.util.List;
-import java.util.function.Predicate;
-import javax.annotation.Nullable;
-import net.minecraft.commands.CommandBuildContext;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.DimensionArgument;
-import net.minecraft.commands.arguments.blocks.BlockPredicateArgument;
-import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.component.DataComponentMap;
-import net.minecraft.nbt.CompoundTag;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.world.Clearable;
-import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.entity.BlockEntity;
-import net.minecraft.world.level.block.state.BlockState;
-import net.minecraft.world.level.block.state.pattern.BlockInWorld;
-import net.minecraft.world.level.levelgen.structure.BoundingBox;
-
-public class CloneCommands {
-    private static final SimpleCommandExceptionType ERROR_OVERLAP = new SimpleCommandExceptionType(Component.translatable("commands.clone.overlap"));
-    private static final Dynamic2CommandExceptionType ERROR_AREA_TOO_LARGE = new Dynamic2CommandExceptionType(
-        (maxBlocks, specifiedBlocks) -> Component.translatableEscape("commands.clone.toobig", maxBlocks, specifiedBlocks)
-    );
-    private static final SimpleCommandExceptionType ERROR_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.clone.failed"));
-    public static final Predicate<BlockInWorld> FILTER_AIR = blockInWorld -> !blockInWorld.getState().isAir();
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext context) {
-        dispatcher.register(
-            Commands.literal("clone")
-                .requires(source -> source.hasPermission(2))
-                .then(beginEndDestinationAndModeSuffix(context, context1 -> context1.getSource().getLevel()))
-                .then(
-                    Commands.literal("from")
-                        .then(
-                            Commands.argument("sourceDimension", DimensionArgument.dimension())
-                                .then(beginEndDestinationAndModeSuffix(context, context1 -> DimensionArgument.getDimension(context1, "sourceDimension")))
-                        )
-                )
-        );
-    }
-
-    private static ArgumentBuilder<CommandSourceStack, ?> beginEndDestinationAndModeSuffix(
-        CommandBuildContext buildContext, CloneCommands.CommandFunction<CommandContext<CommandSourceStack>, ServerLevel> levelGetter
-    ) {
-        return Commands.argument("begin", BlockPosArgument.blockPos())
-            .then(
-                Commands.argument("end", BlockPosArgument.blockPos())
-                    .then(destinationAndModeSuffix(buildContext, levelGetter, context -> context.getSource().getLevel()))
-                    .then(
-                        Commands.literal("to")
-                            .then(
-                                Commands.argument("targetDimension", DimensionArgument.dimension())
-                                    .then(
-                                        destinationAndModeSuffix(
-                                            buildContext, levelGetter, context -> DimensionArgument.getDimension(context, "targetDimension")
-                                        )
-                                    )
-                            )
-                    )
-            );
-    }
-
-    private static CloneCommands.DimensionAndPosition getLoadedDimensionAndPosition(CommandContext<CommandSourceStack> context, ServerLevel level, String name) throws CommandSyntaxException {
-        BlockPos loadedBlockPos = BlockPosArgument.getLoadedBlockPos(context, level, name);
-        return new CloneCommands.DimensionAndPosition(level, loadedBlockPos);
-    }
-
-    private static ArgumentBuilder<CommandSourceStack, ?> destinationAndModeSuffix(
-        CommandBuildContext buildContext,
-        CloneCommands.CommandFunction<CommandContext<CommandSourceStack>, ServerLevel> sourceLevelGetter,
-        CloneCommands.CommandFunction<CommandContext<CommandSourceStack>, ServerLevel> destinationLevelGetter
-    ) {
-        CloneCommands.CommandFunction<CommandContext<CommandSourceStack>, CloneCommands.DimensionAndPosition> commandFunction = context -> getLoadedDimensionAndPosition(
-            context, sourceLevelGetter.apply(context), "begin"
-        );
-        CloneCommands.CommandFunction<CommandContext<CommandSourceStack>, CloneCommands.DimensionAndPosition> commandFunction1 = context -> getLoadedDimensionAndPosition(
-            context, sourceLevelGetter.apply(context), "end"
-        );
-        CloneCommands.CommandFunction<CommandContext<CommandSourceStack>, CloneCommands.DimensionAndPosition> commandFunction2 = context -> getLoadedDimensionAndPosition(
-            context, destinationLevelGetter.apply(context), "destination"
-        );
-        return Commands.argument("destination", BlockPosArgument.blockPos())
-            .executes(
-                context -> clone(
-                    context.getSource(),
-                    commandFunction.apply(context),
-                    commandFunction1.apply(context),
-                    commandFunction2.apply(context),
-                    blockInWorld -> true,
-                    CloneCommands.Mode.NORMAL
-                )
-            )
-            .then(
-                wrapWithCloneMode(
-                    commandFunction,
-                    commandFunction1,
-                    commandFunction2,
-                    context -> blockInWorld -> true,
-                    Commands.literal("replace")
-                        .executes(
-                            context -> clone(
-                                context.getSource(),
-                                commandFunction.apply(context),
-                                commandFunction1.apply(context),
-                                commandFunction2.apply(context),
-                                blockInWorld -> true,
-                                CloneCommands.Mode.NORMAL
-                            )
-                        )
-                )
-            )
-            .then(
-                wrapWithCloneMode(
-                    commandFunction,
-                    commandFunction1,
-                    commandFunction2,
-                    context -> FILTER_AIR,
-                    Commands.literal("masked")
-                        .executes(
-                            context -> clone(
-                                context.getSource(),
-                                commandFunction.apply(context),
-                                commandFunction1.apply(context),
-                                commandFunction2.apply(context),
-                                FILTER_AIR,
-                                CloneCommands.Mode.NORMAL
-                            )
-                        )
-                )
-            )
-            .then(
-                Commands.literal("filtered")
-                    .then(
-                        wrapWithCloneMode(
-                            commandFunction,
-                            commandFunction1,
-                            commandFunction2,
-                            context -> BlockPredicateArgument.getBlockPredicate(context, "filter"),
-                            Commands.argument("filter", BlockPredicateArgument.blockPredicate(buildContext))
-                                .executes(
-                                    context -> clone(
-                                        context.getSource(),
-                                        commandFunction.apply(context),
-                                        commandFunction1.apply(context),
-                                        commandFunction2.apply(context),
-                                        BlockPredicateArgument.getBlockPredicate(context, "filter"),
-                                        CloneCommands.Mode.NORMAL
-                                    )
-                                )
-                        )
-                    )
-            );
-    }
-
-    private static ArgumentBuilder<CommandSourceStack, ?> wrapWithCloneMode(
-        CloneCommands.CommandFunction<CommandContext<CommandSourceStack>, CloneCommands.DimensionAndPosition> beginGetter,
-        CloneCommands.CommandFunction<CommandContext<CommandSourceStack>, CloneCommands.DimensionAndPosition> endGetter,
-        CloneCommands.CommandFunction<CommandContext<CommandSourceStack>, CloneCommands.DimensionAndPosition> targetGetter,
-        CloneCommands.CommandFunction<CommandContext<CommandSourceStack>, Predicate<BlockInWorld>> filterGetter,
-        ArgumentBuilder<CommandSourceStack, ?> argumentBuilder
-    ) {
-        return argumentBuilder.then(
-                Commands.literal("force")
-                    .executes(
-                        context -> clone(
-                            context.getSource(),
-                            beginGetter.apply(context),
-                            endGetter.apply(context),
-                            targetGetter.apply(context),
-                            filterGetter.apply(context),
-                            CloneCommands.Mode.FORCE
-                        )
-                    )
-            )
-            .then(
-                Commands.literal("move")
-                    .executes(
-                        context -> clone(
-                            context.getSource(),
-                            beginGetter.apply(context),
-                            endGetter.apply(context),
-                            targetGetter.apply(context),
-                            filterGetter.apply(context),
-                            CloneCommands.Mode.MOVE
-                        )
-                    )
-            )
-            .then(
-                Commands.literal("normal")
-                    .executes(
-                        context -> clone(
-                            context.getSource(),
-                            beginGetter.apply(context),
-                            endGetter.apply(context),
-                            targetGetter.apply(context),
-                            filterGetter.apply(context),
-                            CloneCommands.Mode.NORMAL
-                        )
-                    )
-            );
-    }
-
-    private static int clone(
-        CommandSourceStack source,
-        CloneCommands.DimensionAndPosition begin,
-        CloneCommands.DimensionAndPosition end,
-        CloneCommands.DimensionAndPosition target,
-        Predicate<BlockInWorld> filter,
-        CloneCommands.Mode mode
-    ) throws CommandSyntaxException {
-        BlockPos blockPos = begin.position();
-        BlockPos blockPos1 = end.position();
-        BoundingBox boundingBox = BoundingBox.fromCorners(blockPos, blockPos1);
-        BlockPos blockPos2 = target.position();
-        BlockPos blockPos3 = blockPos2.offset(boundingBox.getLength());
-        BoundingBox boundingBox1 = BoundingBox.fromCorners(blockPos2, blockPos3);
-        ServerLevel serverLevel = begin.dimension();
-        ServerLevel serverLevel1 = target.dimension();
-        if (!mode.canOverlap() && serverLevel == serverLevel1 && boundingBox1.intersects(boundingBox)) {
-            throw ERROR_OVERLAP.create();
-        } else {
-            int i = boundingBox.getXSpan() * boundingBox.getYSpan() * boundingBox.getZSpan();
-            int _int = source.getLevel().getGameRules().getInt(GameRules.RULE_COMMAND_MODIFICATION_BLOCK_LIMIT);
-            if (i > _int) {
-                throw ERROR_AREA_TOO_LARGE.create(_int, i);
-            } else if (serverLevel.hasChunksAt(blockPos, blockPos1) && serverLevel1.hasChunksAt(blockPos2, blockPos3)) {
-                List<CloneCommands.CloneBlockInfo> list = Lists.newArrayList();
-                List<CloneCommands.CloneBlockInfo> list1 = Lists.newArrayList();
-                List<CloneCommands.CloneBlockInfo> list2 = Lists.newArrayList();
-                Deque<BlockPos> list3 = Lists.newLinkedList();
-                BlockPos blockPos4 = new BlockPos(
-                    boundingBox1.minX() - boundingBox.minX(), boundingBox1.minY() - boundingBox.minY(), boundingBox1.minZ() - boundingBox.minZ()
-                );
-
-                for (int z = boundingBox.minZ(); z <= boundingBox.maxZ(); z++) {
-                    for (int y = boundingBox.minY(); y <= boundingBox.maxY(); y++) {
-                        for (int x = boundingBox.minX(); x <= boundingBox.maxX(); x++) {
-                            BlockPos blockPos5 = new BlockPos(x, y, z);
-                            BlockPos blockPos6 = blockPos5.offset(blockPos4);
-                            BlockInWorld blockInWorld = new BlockInWorld(serverLevel, blockPos5, false);
-                            BlockState state = blockInWorld.getState();
-                            if (filter.test(blockInWorld)) {
-                                BlockEntity blockEntity = serverLevel.getBlockEntity(blockPos5);
-                                if (blockEntity != null) {
-                                    CloneCommands.CloneBlockEntityInfo cloneBlockEntityInfo = new CloneCommands.CloneBlockEntityInfo(
-                                        blockEntity.saveCustomOnly(source.registryAccess()), blockEntity.components()
-                                    );
-                                    list1.add(new CloneCommands.CloneBlockInfo(blockPos6, state, cloneBlockEntityInfo));
-                                    list3.addLast(blockPos5);
-                                } else if (!state.isSolidRender() && !state.isCollisionShapeFullBlock(serverLevel, blockPos5)) {
-                                    list2.add(new CloneCommands.CloneBlockInfo(blockPos6, state, null));
-                                    list3.addFirst(blockPos5);
-                                } else {
-                                    list.add(new CloneCommands.CloneBlockInfo(blockPos6, state, null));
-                                    list3.addLast(blockPos5);
-                                }
-                            }
-                        }
-                    }
-                }
-
-                if (mode == CloneCommands.Mode.MOVE) {
-                    for (BlockPos blockPos7 : list3) {
-                        BlockEntity blockEntity1 = serverLevel.getBlockEntity(blockPos7);
-                        Clearable.tryClear(blockEntity1);
-                        serverLevel.setBlock(blockPos7, Blocks.BARRIER.defaultBlockState(), 2);
-                    }
-
-                    for (BlockPos blockPos7 : list3) {
-                        serverLevel.setBlock(blockPos7, Blocks.AIR.defaultBlockState(), 3);
-                    }
-                }
-
-                List<CloneCommands.CloneBlockInfo> list4 = Lists.newArrayList();
-                list4.addAll(list);
-                list4.addAll(list1);
-                list4.addAll(list2);
-                List<CloneCommands.CloneBlockInfo> list5 = Lists.reverse(list4);
-
-                for (CloneCommands.CloneBlockInfo cloneBlockInfo : list5) {
-                    BlockEntity blockEntity2 = serverLevel1.getBlockEntity(cloneBlockInfo.pos);
-                    Clearable.tryClear(blockEntity2);
-                    serverLevel1.setBlock(cloneBlockInfo.pos, Blocks.BARRIER.defaultBlockState(), 2);
-                }
-
-                int xx = 0;
-
-                for (CloneCommands.CloneBlockInfo cloneBlockInfo1 : list4) {
-                    if (serverLevel1.setBlock(cloneBlockInfo1.pos, cloneBlockInfo1.state, 2)) {
-                        xx++;
-                    }
-                }
-
-                for (CloneCommands.CloneBlockInfo cloneBlockInfo1x : list1) {
-                    BlockEntity blockEntity3 = serverLevel1.getBlockEntity(cloneBlockInfo1x.pos);
-                    if (cloneBlockInfo1x.blockEntityInfo != null && blockEntity3 != null) {
-                        blockEntity3.loadCustomOnly(cloneBlockInfo1x.blockEntityInfo.tag, serverLevel1.registryAccess());
-                        blockEntity3.setComponents(cloneBlockInfo1x.blockEntityInfo.components);
-                        blockEntity3.setChanged();
-                    }
-
-                    serverLevel1.setBlock(cloneBlockInfo1x.pos, cloneBlockInfo1x.state, 2);
-                }
-
-                for (CloneCommands.CloneBlockInfo cloneBlockInfo1x : list5) {
-                    serverLevel1.blockUpdated(cloneBlockInfo1x.pos, cloneBlockInfo1x.state.getBlock());
-                }
-
-                serverLevel1.getBlockTicks().copyAreaFrom(serverLevel.getBlockTicks(), boundingBox, blockPos4);
-                if (xx == 0) {
-                    throw ERROR_FAILED.create();
-                } else {
-                    int i1 = xx;
-                    source.sendSuccess(() -> Component.translatable("commands.clone.success", i1), true);
-                    return xx;
-                }
-            } else {
-                throw BlockPosArgument.ERROR_NOT_LOADED.create();
-            }
-        }
-    }
-
-    record CloneBlockEntityInfo(CompoundTag tag, DataComponentMap components) {
-    }
-
-    record CloneBlockInfo(BlockPos pos, BlockState state, @Nullable CloneCommands.CloneBlockEntityInfo blockEntityInfo) {
-    }
-
-    @FunctionalInterface
-    interface CommandFunction<T, R> {
-        R apply(T input) throws CommandSyntaxException;
-    }
-
-    record DimensionAndPosition(ServerLevel dimension, BlockPos position) {
-    }
-
-    static enum Mode {
-        FORCE(true),
-        MOVE(true),
-        NORMAL(false);
-
-        private final boolean canOverlap;
-
-        private Mode(final boolean canOverlap) {
-            this.canOverlap = canOverlap;
-        }
-
-        public boolean canOverlap() {
-            return this.canOverlap;
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/DamageCommand.java b/net/minecraft/server/commands/DamageCommand.java
deleted file mode 100644
index d99602f2c7e5463243dfaf83ada12c1d8e7d1192..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/DamageCommand.java
+++ /dev/null
@@ -1,113 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.FloatArgumentType;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import net.minecraft.commands.CommandBuildContext;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.commands.arguments.ResourceArgument;
-import net.minecraft.commands.arguments.coordinates.Vec3Argument;
-import net.minecraft.core.registries.Registries;
-import net.minecraft.network.chat.Component;
-import net.minecraft.world.damagesource.DamageSource;
-import net.minecraft.world.entity.Entity;
-
-public class DamageCommand {
-    private static final SimpleCommandExceptionType ERROR_INVULNERABLE = new SimpleCommandExceptionType(Component.translatable("commands.damage.invulnerable"));
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext context) {
-        dispatcher.register(
-            Commands.literal("damage")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.argument("target", EntityArgument.entity())
-                        .then(
-                            Commands.argument("amount", FloatArgumentType.floatArg(0.0F))
-                                .executes(
-                                    context1 -> damage(
-                                        context1.getSource(),
-                                        EntityArgument.getEntity(context1, "target"),
-                                        FloatArgumentType.getFloat(context1, "amount"),
-                                        context1.getSource().getLevel().damageSources().generic()
-                                    )
-                                )
-                                .then(
-                                    Commands.argument("damageType", ResourceArgument.resource(context, Registries.DAMAGE_TYPE))
-                                        .executes(
-                                            context1 -> damage(
-                                                context1.getSource(),
-                                                EntityArgument.getEntity(context1, "target"),
-                                                FloatArgumentType.getFloat(context1, "amount"),
-                                                new DamageSource(ResourceArgument.getResource(context1, "damageType", Registries.DAMAGE_TYPE))
-                                            )
-                                        )
-                                        .then(
-                                            Commands.literal("at")
-                                                .then(
-                                                    Commands.argument("location", Vec3Argument.vec3())
-                                                        .executes(
-                                                            context1 -> damage(
-                                                                context1.getSource(),
-                                                                EntityArgument.getEntity(context1, "target"),
-                                                                FloatArgumentType.getFloat(context1, "amount"),
-                                                                new DamageSource(
-                                                                    ResourceArgument.getResource(context1, "damageType", Registries.DAMAGE_TYPE),
-                                                                    Vec3Argument.getVec3(context1, "location")
-                                                                )
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.literal("by")
-                                                .then(
-                                                    Commands.argument("entity", EntityArgument.entity())
-                                                        .executes(
-                                                            context1 -> damage(
-                                                                context1.getSource(),
-                                                                EntityArgument.getEntity(context1, "target"),
-                                                                FloatArgumentType.getFloat(context1, "amount"),
-                                                                new DamageSource(
-                                                                    ResourceArgument.getResource(context1, "damageType", Registries.DAMAGE_TYPE),
-                                                                    EntityArgument.getEntity(context1, "entity")
-                                                                )
-                                                            )
-                                                        )
-                                                        .then(
-                                                            Commands.literal("from")
-                                                                .then(
-                                                                    Commands.argument("cause", EntityArgument.entity())
-                                                                        .executes(
-                                                                            context1 -> damage(
-                                                                                context1.getSource(),
-                                                                                EntityArgument.getEntity(context1, "target"),
-                                                                                FloatArgumentType.getFloat(context1, "amount"),
-                                                                                new DamageSource(
-                                                                                    ResourceArgument.getResource(context1, "damageType", Registries.DAMAGE_TYPE),
-                                                                                    EntityArgument.getEntity(context1, "entity"),
-                                                                                    EntityArgument.getEntity(context1, "cause")
-                                                                                )
-                                                                            )
-                                                                        )
-                                                                )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int damage(CommandSourceStack source, Entity target, float amount, DamageSource damageType) throws CommandSyntaxException {
-        if (target.hurtServer(source.getLevel(), damageType, amount)) {
-            source.sendSuccess(() -> Component.translatable("commands.damage.success", amount, target.getDisplayName()), true);
-            return 1;
-        } else {
-            throw ERROR_INVULNERABLE.create();
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/DataPackCommand.java b/net/minecraft/server/commands/DataPackCommand.java
index 833434868d2c4adc5b28244bbd3d6f5943e9106d..98cd58ca0e7657c5c7f8521b3ab7344591bc889b 100644
--- a/net/minecraft/server/commands/DataPackCommand.java
+++ b/net/minecraft/server/commands/DataPackCommand.java
@@ -10,7 +10,6 @@ import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
 import com.mojang.brigadier.suggestion.SuggestionProvider;
 import java.util.Collection;
 import java.util.List;
-import java.util.stream.Collectors;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.Commands;
 import net.minecraft.commands.SharedSuggestionProvider;
@@ -112,7 +111,7 @@ public class DataPackCommand {
                                             context -> enablePack(
                                                 context.getSource(),
                                                 getPack(context, "name", true),
-                                                (enabledPacks, packToEnable) -> enabledPacks.add(0, packToEnable)
+                                                List::addFirst
                                             )
                                         )
                                 )
@@ -140,7 +139,6 @@ public class DataPackCommand {
         List<Pack> list = Lists.newArrayList(packRepository.getSelectedPacks());
         priorityCallback.apply(list, pack);
         source.sendSuccess(() -> Component.translatable("commands.datapack.modify.enable", pack.getChatLink(true)), true);
-        ReloadCommand.reloadPacks(list.stream().map(Pack::getId).collect(Collectors.toList()), source);
         return list.size();
     }
 
@@ -149,7 +147,6 @@ public class DataPackCommand {
         List<Pack> list = Lists.newArrayList(packRepository.getSelectedPacks());
         list.remove(pack);
         source.sendSuccess(() -> Component.translatable("commands.datapack.modify.disable", pack.getChatLink(true)), true);
-        ReloadCommand.reloadPacks(list.stream().map(Pack::getId).collect(Collectors.toList()), source);
         return list.size();
     }
 
diff --git a/net/minecraft/server/commands/DeOpCommands.java b/net/minecraft/server/commands/DeOpCommands.java
deleted file mode 100644
index 1b44d92c7c459906679e8c9a966c0716c9640643..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/DeOpCommands.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.authlib.GameProfile;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import java.util.Collection;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.SharedSuggestionProvider;
-import net.minecraft.commands.arguments.GameProfileArgument;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.players.PlayerList;
-
-public class DeOpCommands {
-    private static final SimpleCommandExceptionType ERROR_NOT_OP = new SimpleCommandExceptionType(Component.translatable("commands.deop.failed"));
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("deop")
-                .requires(source -> source.hasPermission(3))
-                .then(
-                    Commands.argument("targets", GameProfileArgument.gameProfile())
-                        .suggests((context, builder) -> SharedSuggestionProvider.suggest(context.getSource().getServer().getPlayerList().getOpNames(), builder))
-                        .executes(context -> deopPlayers(context.getSource(), GameProfileArgument.getGameProfiles(context, "targets")))
-                )
-        );
-    }
-
-    private static int deopPlayers(CommandSourceStack source, Collection<GameProfile> players) throws CommandSyntaxException {
-        PlayerList playerList = source.getServer().getPlayerList();
-        int i = 0;
-
-        for (GameProfile gameProfile : players) {
-            if (playerList.isOp(gameProfile)) {
-                playerList.deop(gameProfile);
-                i++;
-                source.sendSuccess(() -> Component.translatable("commands.deop.success", gameProfile.getName()), true); // Paper - fixes MC-253721
-            }
-        }
-
-        if (i == 0) {
-            throw ERROR_NOT_OP.create();
-        } else {
-            source.getServer().kickUnlistedPlayers(source);
-            return i;
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/DebugCommand.java b/net/minecraft/server/commands/DebugCommand.java
deleted file mode 100644
index b246c9885fd8c9cc0de2fd4faa53e0619dd3865c..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/DebugCommand.java
+++ /dev/null
@@ -1,277 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.context.CommandContext;
-import com.mojang.brigadier.context.ContextChain;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import com.mojang.logging.LogUtils;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.UncheckedIOException;
-import java.io.Writer;
-import java.nio.charset.StandardCharsets;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.util.Collection;
-import java.util.Locale;
-import net.minecraft.Util;
-import net.minecraft.commands.CommandResultCallback;
-import net.minecraft.commands.CommandSource;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.FunctionInstantiationException;
-import net.minecraft.commands.arguments.item.FunctionArgument;
-import net.minecraft.commands.execution.ChainModifiers;
-import net.minecraft.commands.execution.CustomCommandExecutor;
-import net.minecraft.commands.execution.ExecutionContext;
-import net.minecraft.commands.execution.ExecutionControl;
-import net.minecraft.commands.execution.Frame;
-import net.minecraft.commands.execution.TraceCallbacks;
-import net.minecraft.commands.execution.tasks.CallFunction;
-import net.minecraft.commands.functions.CommandFunction;
-import net.minecraft.commands.functions.InstantiatedFunction;
-import net.minecraft.network.chat.Component;
-import net.minecraft.resources.ResourceLocation;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.util.TimeUtil;
-import net.minecraft.util.profiling.ProfileResults;
-import org.apache.commons.io.IOUtils;
-import org.slf4j.Logger;
-
-public class DebugCommand {
-    static final Logger LOGGER = LogUtils.getLogger();
-    private static final SimpleCommandExceptionType ERROR_NOT_RUNNING = new SimpleCommandExceptionType(Component.translatable("commands.debug.notRunning"));
-    private static final SimpleCommandExceptionType ERROR_ALREADY_RUNNING = new SimpleCommandExceptionType(
-        Component.translatable("commands.debug.alreadyRunning")
-    );
-    static final SimpleCommandExceptionType NO_RECURSIVE_TRACES = new SimpleCommandExceptionType(Component.translatable("commands.debug.function.noRecursion"));
-    static final SimpleCommandExceptionType NO_RETURN_RUN = new SimpleCommandExceptionType(Component.translatable("commands.debug.function.noReturnRun"));
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("debug")
-                .requires(source -> source.hasPermission(3))
-                .then(Commands.literal("start").executes(context -> start(context.getSource())))
-                .then(Commands.literal("stop").executes(context -> stop(context.getSource())))
-                .then(
-                    Commands.literal("function")
-                        .requires(source -> source.hasPermission(3))
-                        .then(
-                            Commands.argument("name", FunctionArgument.functions())
-                                .suggests(FunctionCommand.SUGGEST_FUNCTION)
-                                .executes(new DebugCommand.TraceCustomExecutor())
-                        )
-                )
-        );
-    }
-
-    private static int start(CommandSourceStack source) throws CommandSyntaxException {
-        MinecraftServer server = source.getServer();
-        if (server.isTimeProfilerRunning()) {
-            throw ERROR_ALREADY_RUNNING.create();
-        } else {
-            server.startTimeProfiler();
-            source.sendSuccess(() -> Component.translatable("commands.debug.started"), true);
-            return 0;
-        }
-    }
-
-    private static int stop(CommandSourceStack source) throws CommandSyntaxException {
-        MinecraftServer server = source.getServer();
-        if (!server.isTimeProfilerRunning()) {
-            throw ERROR_NOT_RUNNING.create();
-        } else {
-            ProfileResults profileResults = server.stopTimeProfiler();
-            double d = (double)profileResults.getNanoDuration() / TimeUtil.NANOSECONDS_PER_SECOND;
-            double d1 = profileResults.getTickDuration() / d;
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.debug.stopped", String.format(Locale.ROOT, "%.2f", d), profileResults.getTickDuration(), String.format(Locale.ROOT, "%.2f", d1)
-                ),
-                true
-            );
-            return (int)d1;
-        }
-    }
-
-    static class TraceCustomExecutor
-        extends CustomCommandExecutor.WithErrorHandling<CommandSourceStack>
-        implements CustomCommandExecutor.CommandAdapter<CommandSourceStack> {
-        @Override
-        public void runGuarded(
-            CommandSourceStack source,
-            ContextChain<CommandSourceStack> contextChain,
-            ChainModifiers chainModifiers,
-            ExecutionControl<CommandSourceStack> executionControl
-        ) throws CommandSyntaxException {
-            if (chainModifiers.isReturn()) {
-                throw DebugCommand.NO_RETURN_RUN.create();
-            } else if (executionControl.tracer() != null) {
-                throw DebugCommand.NO_RECURSIVE_TRACES.create();
-            } else {
-                CommandContext<CommandSourceStack> topContext = contextChain.getTopContext();
-                Collection<CommandFunction<CommandSourceStack>> functions = FunctionArgument.getFunctions(topContext, "name");
-                MinecraftServer server = source.getServer();
-                String string = "debug-trace-" + Util.getFilenameFormattedDateTime() + ".txt";
-                CommandDispatcher<CommandSourceStack> dispatcher = source.getServer().getFunctions().getDispatcher();
-                int i = 0;
-
-                try {
-                    Path file = server.getFile("debug");
-                    Files.createDirectories(file);
-                    final PrintWriter printWriter = new PrintWriter(Files.newBufferedWriter(file.resolve(string), StandardCharsets.UTF_8));
-                    DebugCommand.Tracer tracer = new DebugCommand.Tracer(printWriter);
-                    executionControl.tracer(tracer);
-
-                    for (final CommandFunction<CommandSourceStack> commandFunction : functions) {
-                        try {
-                            CommandSourceStack commandSourceStack = source.withSource(tracer).withMaximumPermission(2);
-                            InstantiatedFunction<CommandSourceStack> instantiatedFunction = commandFunction.instantiate(null, dispatcher);
-                            executionControl.queueNext((new CallFunction<CommandSourceStack>(instantiatedFunction, CommandResultCallback.EMPTY, false) {
-                                @Override
-                                public void execute(CommandSourceStack source1, ExecutionContext<CommandSourceStack> executionContext, Frame frame) {
-                                    printWriter.println(commandFunction.id());
-                                    super.execute(source1, executionContext, frame);
-                                }
-                            }).bind(commandSourceStack));
-                            i += instantiatedFunction.entries().size();
-                        } catch (FunctionInstantiationException var18) {
-                            source.sendFailure(var18.messageComponent());
-                        }
-                    }
-                } catch (IOException | UncheckedIOException var19) {
-                    DebugCommand.LOGGER.warn("Tracing failed", (Throwable)var19);
-                    source.sendFailure(Component.translatable("commands.debug.function.traceFailed"));
-                }
-
-                int i1 = i;
-                executionControl.queueNext(
-                    (executionContext, frame) -> {
-                        if (functions.size() == 1) {
-                            source.sendSuccess(
-                                () -> Component.translatable(
-                                    "commands.debug.function.success.single", i1, Component.translationArg(functions.iterator().next().id()), string
-                                ),
-                                true
-                            );
-                        } else {
-                            source.sendSuccess(() -> Component.translatable("commands.debug.function.success.multiple", i1, functions.size(), string), true);
-                        }
-                    }
-                );
-            }
-        }
-    }
-
-    static class Tracer implements CommandSource, TraceCallbacks {
-        public static final int INDENT_OFFSET = 1;
-        private final PrintWriter output;
-        private int lastIndent;
-        private boolean waitingForResult;
-
-        Tracer(PrintWriter output) {
-            this.output = output;
-        }
-
-        private void indentAndSave(int indent) {
-            this.printIndent(indent);
-            this.lastIndent = indent;
-        }
-
-        private void printIndent(int indent) {
-            for (int i = 0; i < indent + 1; i++) {
-                this.output.write("    ");
-            }
-        }
-
-        private void newLine() {
-            if (this.waitingForResult) {
-                this.output.println();
-                this.waitingForResult = false;
-            }
-        }
-
-        @Override
-        public void onCommand(int depth, String command) {
-            this.newLine();
-            this.indentAndSave(depth);
-            this.output.print("[C] ");
-            this.output.print(command);
-            this.waitingForResult = true;
-        }
-
-        @Override
-        public void onReturn(int depth, String command, int returnValue) {
-            if (this.waitingForResult) {
-                this.output.print(" -> ");
-                this.output.println(returnValue);
-                this.waitingForResult = false;
-            } else {
-                this.indentAndSave(depth);
-                this.output.print("[R = ");
-                this.output.print(returnValue);
-                this.output.print("] ");
-                this.output.println(command);
-            }
-        }
-
-        @Override
-        public void onCall(int depth, ResourceLocation function, int commands) {
-            this.newLine();
-            this.indentAndSave(depth);
-            this.output.print("[F] ");
-            this.output.print(function);
-            this.output.print(" size=");
-            this.output.println(commands);
-        }
-
-        @Override
-        public void onError(String errorMessage) {
-            this.newLine();
-            this.indentAndSave(this.lastIndent + 1);
-            this.output.print("[E] ");
-            this.output.print(errorMessage);
-        }
-
-        @Override
-        public void sendSystemMessage(Component component) {
-            this.newLine();
-            this.printIndent(this.lastIndent + 1);
-            this.output.print("[M] ");
-            this.output.println(component.getString());
-        }
-
-        @Override
-        public boolean acceptsSuccess() {
-            return true;
-        }
-
-        @Override
-        public boolean acceptsFailure() {
-            return true;
-        }
-
-        @Override
-        public boolean shouldInformAdmins() {
-            return false;
-        }
-
-        @Override
-        public boolean alwaysAccepts() {
-            return true;
-        }
-
-        // Paper start
-        @Override
-        public org.bukkit.command.CommandSender getBukkitSender(final CommandSourceStack wrapper) {
-            throw new UnsupportedOperationException();
-        }
-        // Paper end
-
-        @Override
-        public void close() {
-            IOUtils.closeQuietly((Writer)this.output);
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/DebugConfigCommand.java b/net/minecraft/server/commands/DebugConfigCommand.java
deleted file mode 100644
index 073d34a4861f8d1f97734c36aca6558874cb08ac..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/DebugConfigCommand.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.authlib.GameProfile;
-import com.mojang.brigadier.CommandDispatcher;
-import java.util.HashSet;
-import java.util.Set;
-import java.util.UUID;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.SharedSuggestionProvider;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.commands.arguments.UuidArgument;
-import net.minecraft.network.Connection;
-import net.minecraft.network.PacketListener;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.server.network.ServerConfigurationPacketListenerImpl;
-
-public class DebugConfigCommand {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("debugconfig")
-                .requires(commandSourceStack -> commandSourceStack.hasPermission(3))
-                .then(
-                    Commands.literal("config")
-                        .then(
-                            Commands.argument("target", EntityArgument.player())
-                                .executes(commandContext -> config(commandContext.getSource(), EntityArgument.getPlayer(commandContext, "target")))
-                        )
-                )
-                .then(
-                    Commands.literal("unconfig")
-                        .then(
-                            Commands.argument("target", UuidArgument.uuid())
-                                .suggests(
-                                    (commandContext, suggestionsBuilder) -> SharedSuggestionProvider.suggest(
-                                        getUuidsInConfig(commandContext.getSource().getServer()), suggestionsBuilder
-                                    )
-                                )
-                                .executes(commandContext -> unconfig(commandContext.getSource(), UuidArgument.getUuid(commandContext, "target")))
-                        )
-                )
-        );
-    }
-
-    private static Iterable<String> getUuidsInConfig(MinecraftServer server) {
-        Set<String> set = new HashSet<>();
-
-        for (Connection connection : server.getConnection().getConnections()) {
-            if (connection.getPacketListener() instanceof ServerConfigurationPacketListenerImpl serverConfigurationPacketListenerImpl) {
-                set.add(serverConfigurationPacketListenerImpl.getOwner().getId().toString());
-            }
-        }
-
-        return set;
-    }
-
-    private static int config(CommandSourceStack source, ServerPlayer target) {
-        GameProfile gameProfile = target.getGameProfile();
-        target.connection.switchToConfig();
-        source.sendSuccess(() -> Component.literal("Switched player " + gameProfile.getName() + "(" + gameProfile.getId() + ") to config mode"), false);
-        return 1;
-    }
-
-    private static int unconfig(CommandSourceStack source, UUID target) {
-        for (Connection connection : source.getServer().getConnection().getConnections()) {
-            PacketListener var5 = connection.getPacketListener();
-            if (var5 instanceof ServerConfigurationPacketListenerImpl) {
-                ServerConfigurationPacketListenerImpl serverConfigurationPacketListenerImpl = (ServerConfigurationPacketListenerImpl)var5;
-                if (serverConfigurationPacketListenerImpl.getOwner().getId().equals(target)) {
-                    serverConfigurationPacketListenerImpl.returnToWorld();
-                }
-            }
-        }
-
-        source.sendFailure(Component.literal("Can't find player to unconfig"));
-        return 0;
-    }
-}
diff --git a/net/minecraft/server/commands/DebugMobSpawningCommand.java b/net/minecraft/server/commands/DebugMobSpawningCommand.java
deleted file mode 100644
index 1183f153f5c0da9c051f1f3b7d1c30618fba4d9d..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/DebugMobSpawningCommand.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.builder.LiteralArgumentBuilder;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
-import net.minecraft.core.BlockPos;
-import net.minecraft.world.entity.MobCategory;
-import net.minecraft.world.level.NaturalSpawner;
-
-public class DebugMobSpawningCommand {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        LiteralArgumentBuilder<CommandSourceStack> literalArgumentBuilder = Commands.literal("debugmobspawning").requires(source -> source.hasPermission(2));
-
-        for (MobCategory mobCategory : MobCategory.values()) {
-            literalArgumentBuilder.then(
-                Commands.literal(mobCategory.getName())
-                    .then(
-                        Commands.argument("at", BlockPosArgument.blockPos())
-                            .executes(context -> spawnMobs(context.getSource(), mobCategory, BlockPosArgument.getLoadedBlockPos(context, "at")))
-                    )
-            );
-        }
-
-        dispatcher.register(literalArgumentBuilder);
-    }
-
-    private static int spawnMobs(CommandSourceStack source, MobCategory mobCategory, BlockPos pos) {
-        NaturalSpawner.spawnCategoryForPosition(mobCategory, source.getLevel(), pos);
-        return 1;
-    }
-}
diff --git a/net/minecraft/server/commands/DebugPathCommand.java b/net/minecraft/server/commands/DebugPathCommand.java
deleted file mode 100644
index 2ca3dde988f8fffb1e54b0cebbae3cb969b638e6..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/DebugPathCommand.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
-import net.minecraft.core.BlockPos;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.protocol.game.DebugPackets;
-import net.minecraft.world.entity.Mob;
-import net.minecraft.world.entity.ai.navigation.GroundPathNavigation;
-import net.minecraft.world.entity.ai.navigation.PathNavigation;
-import net.minecraft.world.level.pathfinder.Path;
-
-public class DebugPathCommand {
-    private static final SimpleCommandExceptionType ERROR_NOT_MOB = new SimpleCommandExceptionType(Component.literal("Source is not a mob"));
-    private static final SimpleCommandExceptionType ERROR_NO_PATH = new SimpleCommandExceptionType(Component.literal("Path not found"));
-    private static final SimpleCommandExceptionType ERROR_NOT_COMPLETE = new SimpleCommandExceptionType(Component.literal("Target not reached"));
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("debugpath")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.argument("to", BlockPosArgument.blockPos())
-                        .executes(context -> fillBlocks(context.getSource(), BlockPosArgument.getLoadedBlockPos(context, "to")))
-                )
-        );
-    }
-
-    private static int fillBlocks(CommandSourceStack stack, BlockPos pos) throws CommandSyntaxException {
-        if (!(stack.getEntity() instanceof Mob mob)) {
-            throw ERROR_NOT_MOB.create();
-        } else {
-            PathNavigation pathNavigation = new GroundPathNavigation(mob, stack.getLevel());
-            Path path = pathNavigation.createPath(pos, 0);
-            DebugPackets.sendPathFindingPacket(stack.getLevel(), mob, path, pathNavigation.getMaxDistanceToWaypoint());
-            if (path == null) {
-                throw ERROR_NO_PATH.create();
-            } else if (!path.canReach()) {
-                throw ERROR_NOT_COMPLETE.create();
-            } else {
-                stack.sendSuccess(() -> Component.literal("Made path"), true);
-                return 1;
-            }
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/DefaultGameModeCommands.java b/net/minecraft/server/commands/DefaultGameModeCommands.java
deleted file mode 100644
index fd42373ccfedf28ffc0fcf9b3153e5a308c561c5..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/DefaultGameModeCommands.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.GameModeArgument;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.world.level.GameType;
-
-public class DefaultGameModeCommands {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("defaultgamemode")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.argument("gamemode", GameModeArgument.gameMode())
-                        .executes(context -> setMode(context.getSource(), GameModeArgument.getGameMode(context, "gamemode")))
-                )
-        );
-    }
-
-    private static int setMode(CommandSourceStack commandSource, GameType gamemode) {
-        int i = 0;
-        MinecraftServer server = commandSource.getServer();
-        server.setDefaultGameType(gamemode);
-        GameType forcedGameType = server.getForcedGameType();
-        if (forcedGameType != null) {
-            for (ServerPlayer serverPlayer : server.getPlayerList().getPlayers()) {
-                // Paper start - Expand PlayerGameModeChangeEvent
-                org.bukkit.event.player.PlayerGameModeChangeEvent event = serverPlayer.setGameMode(gamemode, org.bukkit.event.player.PlayerGameModeChangeEvent.Cause.DEFAULT_GAMEMODE, net.kyori.adventure.text.Component.empty());
-                if (event != null && event.isCancelled()) {
-                    commandSource.sendSuccess(() -> io.papermc.paper.adventure.PaperAdventure.asVanilla(event.cancelMessage()), false);
-                }
-                // Paper end - Expand PlayerGameModeChangeEvent
-                    i++;
-            }
-        }
-
-        commandSource.sendSuccess(() -> Component.translatable("commands.defaultgamemode.success", gamemode.getLongDisplayName()), true);
-        return i;
-    }
-}
diff --git a/net/minecraft/server/commands/DifficultyCommand.java b/net/minecraft/server/commands/DifficultyCommand.java
deleted file mode 100644
index 4d537bd7d650518f8bf1bc7dae185d8018fac28e..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/DifficultyCommand.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.builder.LiteralArgumentBuilder;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.world.Difficulty;
-
-public class DifficultyCommand {
-    private static final DynamicCommandExceptionType ERROR_ALREADY_DIFFICULT = new DynamicCommandExceptionType(
-        difficulty -> Component.translatableEscape("commands.difficulty.failure", difficulty)
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        LiteralArgumentBuilder<CommandSourceStack> literalArgumentBuilder = Commands.literal("difficulty");
-
-        for (Difficulty difficulty : Difficulty.values()) {
-            literalArgumentBuilder.then(Commands.literal(difficulty.getKey()).executes(context -> setDifficulty(context.getSource(), difficulty)));
-        }
-
-        dispatcher.register(literalArgumentBuilder.requires(source -> source.hasPermission(2)).executes(context -> {
-            Difficulty difficulty1 = context.getSource().getLevel().getDifficulty();
-            context.getSource().sendSuccess(() -> Component.translatable("commands.difficulty.query", difficulty1.getDisplayName()), false);
-            return difficulty1.getId();
-        }));
-    }
-
-    public static int setDifficulty(CommandSourceStack source, Difficulty difficulty) throws CommandSyntaxException {
-        MinecraftServer server = source.getServer();
-        if (source.getLevel().getDifficulty() == difficulty) { // CraftBukkit
-            throw ERROR_ALREADY_DIFFICULT.create(difficulty.getKey());
-        } else {
-            server.setDifficulty(source.getLevel(), difficulty, true); // Paper - per level difficulty; don't skip other difficulty-changing logic (fix upstream's fix)
-            source.sendSuccess(() -> Component.translatable("commands.difficulty.success", difficulty.getDisplayName()), true);
-            return 0;
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/EmoteCommands.java b/net/minecraft/server/commands/EmoteCommands.java
deleted file mode 100644
index b9865c0257952eed80f5aa102a9425fee66a8593..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/EmoteCommands.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.MessageArgument;
-import net.minecraft.network.chat.ChatType;
-import net.minecraft.server.players.PlayerList;
-
-public class EmoteCommands {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(Commands.literal("me").then(Commands.argument("action", MessageArgument.message()).executes(context -> {
-            MessageArgument.resolveChatMessage(context, "action", message -> {
-                CommandSourceStack commandSourceStack = context.getSource();
-                PlayerList playerList = commandSourceStack.getServer().getPlayerList();
-                playerList.broadcastChatMessage(message, commandSourceStack, ChatType.bind(ChatType.EMOTE_COMMAND, commandSourceStack));
-            });
-            return 1;
-        })));
-    }
-}
diff --git a/net/minecraft/server/commands/EnchantCommand.java b/net/minecraft/server/commands/EnchantCommand.java
deleted file mode 100644
index fe86823f1a02d66df143756f00ee56fb9f634475..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/EnchantCommand.java
+++ /dev/null
@@ -1,118 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
-import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import java.util.Collection;
-import net.minecraft.commands.CommandBuildContext;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.commands.arguments.ResourceArgument;
-import net.minecraft.core.Holder;
-import net.minecraft.core.registries.Registries;
-import net.minecraft.network.chat.Component;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.item.enchantment.Enchantment;
-import net.minecraft.world.item.enchantment.EnchantmentHelper;
-
-public class EnchantCommand {
-    private static final DynamicCommandExceptionType ERROR_NOT_LIVING_ENTITY = new DynamicCommandExceptionType(
-        entity -> Component.translatableEscape("commands.enchant.failed.entity", entity)
-    );
-    private static final DynamicCommandExceptionType ERROR_NO_ITEM = new DynamicCommandExceptionType(
-        entity -> Component.translatableEscape("commands.enchant.failed.itemless", entity)
-    );
-    private static final DynamicCommandExceptionType ERROR_INCOMPATIBLE = new DynamicCommandExceptionType(
-        item -> Component.translatableEscape("commands.enchant.failed.incompatible", item)
-    );
-    private static final Dynamic2CommandExceptionType ERROR_LEVEL_TOO_HIGH = new Dynamic2CommandExceptionType(
-        (requestedLevel, maxLevel) -> Component.translatableEscape("commands.enchant.failed.level", requestedLevel, maxLevel)
-    );
-    private static final SimpleCommandExceptionType ERROR_NOTHING_HAPPENED = new SimpleCommandExceptionType(Component.translatable("commands.enchant.failed"));
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext context) {
-        dispatcher.register(
-            Commands.literal("enchant")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.argument("targets", EntityArgument.entities())
-                        .then(
-                            Commands.argument("enchantment", ResourceArgument.resource(context, Registries.ENCHANTMENT))
-                                .executes(
-                                    context1 -> enchant(
-                                        context1.getSource(),
-                                        EntityArgument.getEntities(context1, "targets"),
-                                        ResourceArgument.getEnchantment(context1, "enchantment"),
-                                        1
-                                    )
-                                )
-                                .then(
-                                    Commands.argument("level", IntegerArgumentType.integer(0))
-                                        .executes(
-                                            context1 -> enchant(
-                                                context1.getSource(),
-                                                EntityArgument.getEntities(context1, "targets"),
-                                                ResourceArgument.getEnchantment(context1, "enchantment"),
-                                                IntegerArgumentType.getInteger(context1, "level")
-                                            )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int enchant(CommandSourceStack source, Collection<? extends Entity> targets, Holder<Enchantment> enchantment, int level) throws CommandSyntaxException {
-        Enchantment enchantment1 = enchantment.value();
-        if (level > enchantment1.getMaxLevel()) {
-            throw ERROR_LEVEL_TOO_HIGH.create(level, enchantment1.getMaxLevel());
-        } else {
-            int i = 0;
-
-            for (Entity entity : targets) {
-                if (entity instanceof LivingEntity) {
-                    LivingEntity livingEntity = (LivingEntity)entity;
-                    ItemStack mainHandItem = livingEntity.getMainHandItem();
-                    if (!mainHandItem.isEmpty()) {
-                        if (enchantment1.canEnchant(mainHandItem)
-                            && EnchantmentHelper.isEnchantmentCompatible(EnchantmentHelper.getEnchantmentsForCrafting(mainHandItem).keySet(), enchantment)) {
-                            mainHandItem.enchant(enchantment, level);
-                            i++;
-                        } else if (targets.size() == 1) {
-                            throw ERROR_INCOMPATIBLE.create(mainHandItem.getHoverName().getString());
-                        }
-                    } else if (targets.size() == 1) {
-                        throw ERROR_NO_ITEM.create(livingEntity.getName().getString());
-                    }
-                } else if (targets.size() == 1) {
-                    throw ERROR_NOT_LIVING_ENTITY.create(entity.getName().getString());
-                }
-            }
-
-            if (i == 0) {
-                throw ERROR_NOTHING_HAPPENED.create();
-            } else {
-                if (targets.size() == 1) {
-                    source.sendSuccess(
-                        () -> Component.translatable(
-                            "commands.enchant.success.single", Enchantment.getFullname(enchantment, level), targets.iterator().next().getDisplayName()
-                        ),
-                        true
-                    );
-                } else {
-                    source.sendSuccess(
-                        () -> Component.translatable("commands.enchant.success.multiple", Enchantment.getFullname(enchantment, level), targets.size()), true
-                    );
-                }
-
-                return i;
-            }
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/ExecuteCommand.java b/net/minecraft/server/commands/ExecuteCommand.java
index 2b69670a3760bc7967017058e75fb9cba508f00d..b00986772f75935ec0c971438fc0b671e6a10f63 100644
--- a/net/minecraft/server/commands/ExecuteCommand.java
+++ b/net/minecraft/server/commands/ExecuteCommand.java
@@ -20,7 +20,6 @@ import com.mojang.brigadier.tree.LiteralCommandNode;
 import it.unimi.dsi.fastutil.ints.IntList;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.Optional;
 import java.util.OptionalInt;
@@ -46,7 +45,6 @@ import net.minecraft.commands.arguments.NbtPathArgument;
 import net.minecraft.commands.arguments.ObjectiveArgument;
 import net.minecraft.commands.arguments.RangeArgument;
 import net.minecraft.commands.arguments.ResourceArgument;
-import net.minecraft.commands.arguments.ResourceLocationArgument;
 import net.minecraft.commands.arguments.ResourceOrIdArgument;
 import net.minecraft.commands.arguments.ResourceOrTagArgument;
 import net.minecraft.commands.arguments.ScoreHolderArgument;
@@ -83,13 +81,11 @@ import net.minecraft.nbt.ShortTag;
 import net.minecraft.nbt.Tag;
 import net.minecraft.network.chat.Component;
 import net.minecraft.server.ReloadableServerRegistries;
-import net.minecraft.server.bossevents.CustomBossEvent;
 import net.minecraft.server.commands.data.DataAccessor;
 import net.minecraft.server.commands.data.DataCommands;
 import net.minecraft.server.level.FullChunkStatus;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.Mth;
-import net.minecraft.world.Container;
 import net.minecraft.world.entity.Attackable;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
@@ -120,7 +116,6 @@ import net.minecraft.world.scores.ScoreHolder;
 import net.minecraft.world.scores.Scoreboard;
 
 public class ExecuteCommand {
-    private static final int MAX_TEST_AREA = 32768;
     private static final Dynamic2CommandExceptionType ERROR_AREA_TOO_LARGE = new Dynamic2CommandExceptionType(
         (maxBlocks, specifiedBlocks) -> Component.translatableEscape("commands.execute.blocks.toobig", maxBlocks, specifiedBlocks)
     );
@@ -327,21 +322,6 @@ public class ExecuteCommand {
                         )
                 )
         );
-        literal.then(
-            Commands.literal("bossbar")
-                .then(
-                    Commands.argument("id", ResourceLocationArgument.id())
-                        .suggests(BossBarCommands.SUGGEST_BOSS_BAR)
-                        .then(
-                            Commands.literal("value")
-                                .redirect(parent, context -> storeValue(context.getSource(), BossBarCommands.getBossBar(context), true, storingResult))
-                        )
-                        .then(
-                            Commands.literal("max")
-                                .redirect(parent, context -> storeValue(context.getSource(), BossBarCommands.getBossBar(context), false, storingResult))
-                        )
-                )
-        );
 
         for (DataCommands.DataProvider dataProvider : DataCommands.TARGET_PROVIDERS) {
             dataProvider.wrap(
@@ -462,17 +442,6 @@ public class ExecuteCommand {
         }, CommandResultCallback::chain);
     }
 
-    private static CommandSourceStack storeValue(CommandSourceStack source, CustomBossEvent bar, boolean storingValue, boolean storingResult) {
-        return source.withCallback((success, result) -> {
-            int i = storingResult ? result : (success ? 1 : 0);
-            if (storingValue) {
-                bar.setValue(i);
-            } else {
-                bar.setMax(i);
-            }
-        }, CommandResultCallback::chain);
-    }
-
     private static CommandSourceStack storeData(
         CommandSourceStack source, DataAccessor accessor, NbtPathArgument.NbtPath path, IntFunction<Tag> tagConverter, boolean storingResult
     ) {
@@ -482,7 +451,7 @@ public class ExecuteCommand {
                 int i = storingResult ? result : (success ? 1 : 0);
                 path.set(data, tagConverter.apply(i));
                 accessor.setData(data);
-            } catch (CommandSyntaxException var8) {
+            } catch (CommandSyntaxException ignored) {
             }
         }, CommandResultCallback::chain);
     }
@@ -722,43 +691,6 @@ public class ExecuteCommand {
                                     )
                             )
                     )
-                    .then(
-                        Commands.literal("block")
-                            .then(
-                                Commands.argument("pos", BlockPosArgument.blockPos())
-                                    .then(
-                                        Commands.argument("slots", SlotsArgument.slots())
-                                            .then(
-                                                Commands.argument("item_predicate", ItemPredicateArgument.itemPredicate(context))
-                                                    .fork(
-                                                        parent,
-                                                        commandContext -> expect(
-                                                            commandContext,
-                                                            isIf,
-                                                            countItems(
-                                                                    commandContext.getSource(),
-                                                                    BlockPosArgument.getLoadedBlockPos(commandContext, "pos"),
-                                                                    SlotsArgument.getSlots(commandContext, "slots"),
-                                                                    ItemPredicateArgument.getItemPredicate(commandContext, "item_predicate")
-                                                                )
-                                                                > 0
-                                                        )
-                                                    )
-                                                    .executes(
-                                                        createNumericConditionalHandler(
-                                                            isIf,
-                                                            context1 -> countItems(
-                                                                context1.getSource(),
-                                                                BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                                                SlotsArgument.getSlots(context1, "slots"),
-                                                                ItemPredicateArgument.getItemPredicate(context1, "item_predicate")
-                                                            )
-                                                        )
-                                                    )
-                                            )
-                                    )
-                            )
-                    )
             );
 
         for (DataCommands.DataProvider dataProvider : DataCommands.SOURCE_PROVIDERS) {
@@ -807,25 +739,6 @@ public class ExecuteCommand {
         return i;
     }
 
-    private static int countItems(CommandSourceStack source, BlockPos pos, SlotRange slotRange, Predicate<ItemStack> filter) throws CommandSyntaxException {
-        int i = 0;
-        Container container = ItemCommands.getContainer(source, pos, ItemCommands.ERROR_SOURCE_NOT_A_CONTAINER);
-        int containerSize = container.getContainerSize();
-        IntList list = slotRange.slots();
-
-        for (int i1 = 0; i1 < list.size(); i1++) {
-            int _int = list.getInt(i1);
-            if (_int >= 0 && _int < containerSize) {
-                ItemStack item = container.getItem(_int);
-                if (filter.test(item)) {
-                    i += item.getCount();
-                }
-            }
-        }
-
-        return i;
-    }
-
     private static Command<CommandSourceStack> createNumericConditionalHandler(boolean isIf, ExecuteCommand.CommandNumericPredicate predicate) {
         return isIf ? commandContext -> {
             int i = predicate.test(commandContext);
@@ -881,7 +794,7 @@ public class ExecuteCommand {
     }
 
     private static Collection<CommandSourceStack> expect(CommandContext<CommandSourceStack> context, boolean actual, boolean expected) {
-        return (Collection<CommandSourceStack>)(expected == actual ? Collections.singleton(context.getSource()) : Collections.emptyList());
+        return expected == actual ? java.util.Collections.singleton(context.getSource()) : java.util.Collections.emptyList();
     }
 
     private static ArgumentBuilder<CommandSourceStack, ?> addConditional(
@@ -1107,7 +1020,7 @@ public class ExecuteCommand {
             }
 
             for (T executionCommandSource : sources) {
-                T executionCommandSource1 = (T)sourceModifier.apply(executionCommandSource.clearCallbacks());
+                T executionCommandSource1 = sourceModifier.apply(executionCommandSource.clearCallbacks());
                 CommandResultCallback commandResultCallback = (success, result) -> {
                     if (successCheck.test(result)) {
                         list.add(executionCommandSource);
diff --git a/net/minecraft/server/commands/ExperienceCommand.java b/net/minecraft/server/commands/ExperienceCommand.java
index cb59af8018d3009876a47fae249885c00b6c7b57..e71b9a313c870e073f15813aeb5b6f0c60546102 100644
--- a/net/minecraft/server/commands/ExperienceCommand.java
+++ b/net/minecraft/server/commands/ExperienceCommand.java
@@ -178,7 +178,7 @@ public class ExperienceCommand {
         }
     }
 
-    static enum Type {
+    enum Type {
         POINTS("points", Player::giveExperiencePoints, (player, experience) -> {
             if (experience >= player.getXpNeededForNextLevel()) {
                 return false;
@@ -197,7 +197,7 @@ public class ExperienceCommand {
         public final String name;
         final ToIntFunction<ServerPlayer> query;
 
-        private Type(
+        Type(
             final String name,
             final BiConsumer<ServerPlayer, Integer> add,
             final BiPredicate<ServerPlayer, Integer> set,
diff --git a/net/minecraft/server/commands/FillBiomeCommand.java b/net/minecraft/server/commands/FillBiomeCommand.java
deleted file mode 100644
index bb2c8612b27bb04758c467ec6245de1236fc4de1..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/FillBiomeCommand.java
+++ /dev/null
@@ -1,173 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import com.mojang.datafixers.util.Either;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Optional;
-import java.util.function.Consumer;
-import java.util.function.Predicate;
-import java.util.function.Supplier;
-import net.minecraft.commands.CommandBuildContext;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.ResourceArgument;
-import net.minecraft.commands.arguments.ResourceOrTagArgument;
-import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Holder;
-import net.minecraft.core.QuartPos;
-import net.minecraft.core.SectionPos;
-import net.minecraft.core.registries.Registries;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.biome.Biome;
-import net.minecraft.world.level.biome.BiomeResolver;
-import net.minecraft.world.level.chunk.ChunkAccess;
-import net.minecraft.world.level.chunk.status.ChunkStatus;
-import net.minecraft.world.level.levelgen.structure.BoundingBox;
-import org.apache.commons.lang3.mutable.MutableInt;
-
-public class FillBiomeCommand {
-    public static final SimpleCommandExceptionType ERROR_NOT_LOADED = new SimpleCommandExceptionType(Component.translatable("argument.pos.unloaded"));
-    private static final Dynamic2CommandExceptionType ERROR_VOLUME_TOO_LARGE = new Dynamic2CommandExceptionType(
-        (maxBlocks, specifiedBlocks) -> Component.translatableEscape("commands.fillbiome.toobig", maxBlocks, specifiedBlocks)
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext context) {
-        dispatcher.register(
-            Commands.literal("fillbiome")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.argument("from", BlockPosArgument.blockPos())
-                        .then(
-                            Commands.argument("to", BlockPosArgument.blockPos())
-                                .then(
-                                    Commands.argument("biome", ResourceArgument.resource(context, Registries.BIOME))
-                                        .executes(
-                                            context1 -> fill(
-                                                context1.getSource(),
-                                                BlockPosArgument.getLoadedBlockPos(context1, "from"),
-                                                BlockPosArgument.getLoadedBlockPos(context1, "to"),
-                                                ResourceArgument.getResource(context1, "biome", Registries.BIOME),
-                                                biome -> true
-                                            )
-                                        )
-                                        .then(
-                                            Commands.literal("replace")
-                                                .then(
-                                                    Commands.argument("filter", ResourceOrTagArgument.resourceOrTag(context, Registries.BIOME))
-                                                        .executes(
-                                                            context1 -> fill(
-                                                                context1.getSource(),
-                                                                BlockPosArgument.getLoadedBlockPos(context1, "from"),
-                                                                BlockPosArgument.getLoadedBlockPos(context1, "to"),
-                                                                ResourceArgument.getResource(context1, "biome", Registries.BIOME),
-                                                                ResourceOrTagArgument.getResourceOrTag(context1, "filter", Registries.BIOME)::test
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int quantize(int value) {
-        return QuartPos.toBlock(QuartPos.fromBlock(value));
-    }
-
-    private static BlockPos quantize(BlockPos pos) {
-        return new BlockPos(quantize(pos.getX()), quantize(pos.getY()), quantize(pos.getZ()));
-    }
-
-    private static BiomeResolver makeResolver(
-        MutableInt biomeEntries, ChunkAccess chunk, BoundingBox targetRegion, Holder<Biome> replacementBiome, Predicate<Holder<Biome>> filter
-    ) {
-        return (x, y, z, sampler) -> {
-            int blockPosX = QuartPos.toBlock(x);
-            int blockPosY = QuartPos.toBlock(y);
-            int blockPosZ = QuartPos.toBlock(z);
-            Holder<Biome> noiseBiome = chunk.getNoiseBiome(x, y, z);
-            if (targetRegion.isInside(blockPosX, blockPosY, blockPosZ) && filter.test(noiseBiome)) {
-                biomeEntries.increment();
-                return replacementBiome;
-            } else {
-                return noiseBiome;
-            }
-        };
-    }
-
-    public static Either<Integer, CommandSyntaxException> fill(ServerLevel level, BlockPos from, BlockPos to, Holder<Biome> biome) {
-        return fill(level, from, to, biome, biome1 -> true, message -> {});
-    }
-
-    public static Either<Integer, CommandSyntaxException> fill(
-        ServerLevel level, BlockPos from, BlockPos to, Holder<Biome> biome, Predicate<Holder<Biome>> filter, Consumer<Supplier<Component>> messageOutput
-    ) {
-        BlockPos blockPos = quantize(from);
-        BlockPos blockPos1 = quantize(to);
-        BoundingBox boundingBox = BoundingBox.fromCorners(blockPos, blockPos1);
-        int i = boundingBox.getXSpan() * boundingBox.getYSpan() * boundingBox.getZSpan();
-        int _int = level.getGameRules().getInt(GameRules.RULE_COMMAND_MODIFICATION_BLOCK_LIMIT);
-        if (i > _int) {
-            return Either.right(ERROR_VOLUME_TOO_LARGE.create(_int, i));
-        } else {
-            List<ChunkAccess> list = new ArrayList<>();
-
-            for (int sectionPosMinZ = SectionPos.blockToSectionCoord(boundingBox.minZ());
-                sectionPosMinZ <= SectionPos.blockToSectionCoord(boundingBox.maxZ());
-                sectionPosMinZ++
-            ) {
-                for (int sectionPosMinX = SectionPos.blockToSectionCoord(boundingBox.minX());
-                    sectionPosMinX <= SectionPos.blockToSectionCoord(boundingBox.maxX());
-                    sectionPosMinX++
-                ) {
-                    ChunkAccess chunk = level.getChunk(sectionPosMinX, sectionPosMinZ, ChunkStatus.FULL, false);
-                    if (chunk == null) {
-                        return Either.right(ERROR_NOT_LOADED.create());
-                    }
-
-                    list.add(chunk);
-                }
-            }
-
-            MutableInt mutableInt = new MutableInt(0);
-
-            for (ChunkAccess chunk : list) {
-                chunk.fillBiomesFromNoise(makeResolver(mutableInt, chunk, boundingBox, biome, filter), level.getChunkSource().randomState().sampler());
-                chunk.markUnsaved();
-            }
-
-            level.getChunkSource().chunkMap.resendBiomesForChunks(list);
-            messageOutput.accept(
-                () -> Component.translatable(
-                    "commands.fillbiome.success.count",
-                    mutableInt.getValue(),
-                    boundingBox.minX(),
-                    boundingBox.minY(),
-                    boundingBox.minZ(),
-                    boundingBox.maxX(),
-                    boundingBox.maxY(),
-                    boundingBox.maxZ()
-                )
-            );
-            return Either.left(mutableInt.getValue());
-        }
-    }
-
-    private static int fill(CommandSourceStack source, BlockPos from, BlockPos to, Holder.Reference<Biome> biome, Predicate<Holder<Biome>> filter) throws CommandSyntaxException {
-        Either<Integer, CommandSyntaxException> either = fill(source.getLevel(), from, to, biome, filter, supplier -> source.sendSuccess(supplier, true));
-        Optional<CommandSyntaxException> optional = either.right();
-        if (optional.isPresent()) {
-            throw (CommandSyntaxException)optional.get();
-        } else {
-            return either.left().get();
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/FillCommand.java b/net/minecraft/server/commands/FillCommand.java
deleted file mode 100644
index a224f8cc122fc6d79b4abd08815f58f0e6aa340b..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/FillCommand.java
+++ /dev/null
@@ -1,228 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.google.common.collect.Lists;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import java.util.Collections;
-import java.util.List;
-import java.util.function.Predicate;
-import javax.annotation.Nullable;
-import net.minecraft.commands.CommandBuildContext;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.blocks.BlockInput;
-import net.minecraft.commands.arguments.blocks.BlockPredicateArgument;
-import net.minecraft.commands.arguments.blocks.BlockStateArgument;
-import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
-import net.minecraft.core.BlockPos;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.world.Clearable;
-import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.block.Block;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.entity.BlockEntity;
-import net.minecraft.world.level.block.state.pattern.BlockInWorld;
-import net.minecraft.world.level.levelgen.structure.BoundingBox;
-
-public class FillCommand {
-    private static final Dynamic2CommandExceptionType ERROR_AREA_TOO_LARGE = new Dynamic2CommandExceptionType(
-        (maxBlocks, specifiedBlocks) -> Component.translatableEscape("commands.fill.toobig", maxBlocks, specifiedBlocks)
-    );
-    static final BlockInput HOLLOW_CORE = new BlockInput(Blocks.AIR.defaultBlockState(), Collections.emptySet(), null);
-    private static final SimpleCommandExceptionType ERROR_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.fill.failed"));
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext context) {
-        dispatcher.register(
-            Commands.literal("fill")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.argument("from", BlockPosArgument.blockPos())
-                        .then(
-                            Commands.argument("to", BlockPosArgument.blockPos())
-                                .then(
-                                    Commands.argument("block", BlockStateArgument.block(context))
-                                        .executes(
-                                            context1 -> fillBlocks(
-                                                context1.getSource(),
-                                                BoundingBox.fromCorners(
-                                                    BlockPosArgument.getLoadedBlockPos(context1, "from"), BlockPosArgument.getLoadedBlockPos(context1, "to")
-                                                ),
-                                                BlockStateArgument.getBlock(context1, "block"),
-                                                FillCommand.Mode.REPLACE,
-                                                null
-                                            )
-                                        )
-                                        .then(
-                                            Commands.literal("replace")
-                                                .executes(
-                                                    context1 -> fillBlocks(
-                                                        context1.getSource(),
-                                                        BoundingBox.fromCorners(
-                                                            BlockPosArgument.getLoadedBlockPos(context1, "from"),
-                                                            BlockPosArgument.getLoadedBlockPos(context1, "to")
-                                                        ),
-                                                        BlockStateArgument.getBlock(context1, "block"),
-                                                        FillCommand.Mode.REPLACE,
-                                                        null
-                                                    )
-                                                )
-                                                .then(
-                                                    Commands.argument("filter", BlockPredicateArgument.blockPredicate(context))
-                                                        .executes(
-                                                            context1 -> fillBlocks(
-                                                                context1.getSource(),
-                                                                BoundingBox.fromCorners(
-                                                                    BlockPosArgument.getLoadedBlockPos(context1, "from"),
-                                                                    BlockPosArgument.getLoadedBlockPos(context1, "to")
-                                                                ),
-                                                                BlockStateArgument.getBlock(context1, "block"),
-                                                                FillCommand.Mode.REPLACE,
-                                                                BlockPredicateArgument.getBlockPredicate(context1, "filter")
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.literal("keep")
-                                                .executes(
-                                                    context1 -> fillBlocks(
-                                                        context1.getSource(),
-                                                        BoundingBox.fromCorners(
-                                                            BlockPosArgument.getLoadedBlockPos(context1, "from"),
-                                                            BlockPosArgument.getLoadedBlockPos(context1, "to")
-                                                        ),
-                                                        BlockStateArgument.getBlock(context1, "block"),
-                                                        FillCommand.Mode.REPLACE,
-                                                        blockInWorld -> blockInWorld.getLevel().isEmptyBlock(blockInWorld.getPos())
-                                                    )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.literal("outline")
-                                                .executes(
-                                                    context1 -> fillBlocks(
-                                                        context1.getSource(),
-                                                        BoundingBox.fromCorners(
-                                                            BlockPosArgument.getLoadedBlockPos(context1, "from"),
-                                                            BlockPosArgument.getLoadedBlockPos(context1, "to")
-                                                        ),
-                                                        BlockStateArgument.getBlock(context1, "block"),
-                                                        FillCommand.Mode.OUTLINE,
-                                                        null
-                                                    )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.literal("hollow")
-                                                .executes(
-                                                    context1 -> fillBlocks(
-                                                        context1.getSource(),
-                                                        BoundingBox.fromCorners(
-                                                            BlockPosArgument.getLoadedBlockPos(context1, "from"),
-                                                            BlockPosArgument.getLoadedBlockPos(context1, "to")
-                                                        ),
-                                                        BlockStateArgument.getBlock(context1, "block"),
-                                                        FillCommand.Mode.HOLLOW,
-                                                        null
-                                                    )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.literal("destroy")
-                                                .executes(
-                                                    context1 -> fillBlocks(
-                                                        context1.getSource(),
-                                                        BoundingBox.fromCorners(
-                                                            BlockPosArgument.getLoadedBlockPos(context1, "from"),
-                                                            BlockPosArgument.getLoadedBlockPos(context1, "to")
-                                                        ),
-                                                        BlockStateArgument.getBlock(context1, "block"),
-                                                        FillCommand.Mode.DESTROY,
-                                                        null
-                                                    )
-                                                )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int fillBlocks(
-        CommandSourceStack source, BoundingBox area, BlockInput newBlock, FillCommand.Mode mode, @Nullable Predicate<BlockInWorld> replacingPredicate
-    ) throws CommandSyntaxException {
-        int i = area.getXSpan() * area.getYSpan() * area.getZSpan();
-        int _int = source.getLevel().getGameRules().getInt(GameRules.RULE_COMMAND_MODIFICATION_BLOCK_LIMIT);
-        if (i > _int) {
-            throw ERROR_AREA_TOO_LARGE.create(_int, i);
-        } else {
-            List<BlockPos> list = Lists.newArrayList();
-            ServerLevel level = source.getLevel();
-            int i1 = 0;
-
-            for (BlockPos blockPos : BlockPos.betweenClosed(area.minX(), area.minY(), area.minZ(), area.maxX(), area.maxY(), area.maxZ())) {
-                if (replacingPredicate == null || replacingPredicate.test(new BlockInWorld(level, blockPos, true))) {
-                    BlockInput blockInput = mode.filter.filter(area, blockPos, newBlock, level);
-                    if (blockInput != null) {
-                        BlockEntity blockEntity = level.getBlockEntity(blockPos);
-                        Clearable.tryClear(blockEntity);
-                        if (blockInput.place(level, blockPos, 2)) {
-                            list.add(blockPos.immutable());
-                            i1++;
-                        }
-                    }
-                }
-            }
-
-            for (BlockPos blockPosx : list) {
-                Block block = level.getBlockState(blockPosx).getBlock();
-                level.blockUpdated(blockPosx, block);
-            }
-
-            if (i1 == 0) {
-                throw ERROR_FAILED.create();
-            } else {
-                int i2 = i1;
-                source.sendSuccess(() -> Component.translatable("commands.fill.success", i2), true);
-                return i1;
-            }
-        }
-    }
-
-    static enum Mode {
-        REPLACE((area, blockPos, newBlock, level) -> newBlock),
-        OUTLINE(
-            (area, blockPos, newBlock, level) -> blockPos.getX() != area.minX()
-                    && blockPos.getX() != area.maxX()
-                    && blockPos.getY() != area.minY()
-                    && blockPos.getY() != area.maxY()
-                    && blockPos.getZ() != area.minZ()
-                    && blockPos.getZ() != area.maxZ()
-                ? null
-                : newBlock
-        ),
-        HOLLOW(
-            (area, blockPos, newBlock, level) -> blockPos.getX() != area.minX()
-                    && blockPos.getX() != area.maxX()
-                    && blockPos.getY() != area.minY()
-                    && blockPos.getY() != area.maxY()
-                    && blockPos.getZ() != area.minZ()
-                    && blockPos.getZ() != area.maxZ()
-                ? FillCommand.HOLLOW_CORE
-                : newBlock
-        ),
-        DESTROY((area, blockPos, newBlock, level) -> {
-            level.destroyBlock(blockPos, true);
-            return newBlock;
-        });
-
-        public final SetBlockCommand.Filter filter;
-
-        private Mode(final SetBlockCommand.Filter filter) {
-            this.filter = filter;
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/ForceLoadCommand.java b/net/minecraft/server/commands/ForceLoadCommand.java
deleted file mode 100644
index 619ffb7846047d3e033378c750dc4ceaf9ac6239..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/ForceLoadCommand.java
+++ /dev/null
@@ -1,217 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.google.common.base.Joiner;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import it.unimi.dsi.fastutil.longs.LongSet;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
-import net.minecraft.commands.arguments.coordinates.ColumnPosArgument;
-import net.minecraft.core.SectionPos;
-import net.minecraft.network.chat.Component;
-import net.minecraft.resources.ResourceKey;
-import net.minecraft.server.level.ColumnPos;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.world.level.ChunkPos;
-import net.minecraft.world.level.Level;
-
-public class ForceLoadCommand {
-    private static final int MAX_CHUNK_LIMIT = 256;
-    private static final Dynamic2CommandExceptionType ERROR_TOO_MANY_CHUNKS = new Dynamic2CommandExceptionType(
-        (maxChunks, specifiedChunks) -> Component.translatableEscape("commands.forceload.toobig", maxChunks, specifiedChunks)
-    );
-    private static final Dynamic2CommandExceptionType ERROR_NOT_TICKING = new Dynamic2CommandExceptionType(
-        (chunkPos, level) -> Component.translatableEscape("commands.forceload.query.failure", chunkPos, level)
-    );
-    private static final SimpleCommandExceptionType ERROR_ALL_ADDED = new SimpleCommandExceptionType(Component.translatable("commands.forceload.added.failure"));
-    private static final SimpleCommandExceptionType ERROR_NONE_REMOVED = new SimpleCommandExceptionType(
-        Component.translatable("commands.forceload.removed.failure")
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("forceload")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.literal("add")
-                        .then(
-                            Commands.argument("from", ColumnPosArgument.columnPos())
-                                .executes(
-                                    context -> changeForceLoad(
-                                        context.getSource(),
-                                        ColumnPosArgument.getColumnPos(context, "from"),
-                                        ColumnPosArgument.getColumnPos(context, "from"),
-                                        true
-                                    )
-                                )
-                                .then(
-                                    Commands.argument("to", ColumnPosArgument.columnPos())
-                                        .executes(
-                                            context -> changeForceLoad(
-                                                context.getSource(),
-                                                ColumnPosArgument.getColumnPos(context, "from"),
-                                                ColumnPosArgument.getColumnPos(context, "to"),
-                                                true
-                                            )
-                                        )
-                                )
-                        )
-                )
-                .then(
-                    Commands.literal("remove")
-                        .then(
-                            Commands.argument("from", ColumnPosArgument.columnPos())
-                                .executes(
-                                    context -> changeForceLoad(
-                                        context.getSource(),
-                                        ColumnPosArgument.getColumnPos(context, "from"),
-                                        ColumnPosArgument.getColumnPos(context, "from"),
-                                        false
-                                    )
-                                )
-                                .then(
-                                    Commands.argument("to", ColumnPosArgument.columnPos())
-                                        .executes(
-                                            context -> changeForceLoad(
-                                                context.getSource(),
-                                                ColumnPosArgument.getColumnPos(context, "from"),
-                                                ColumnPosArgument.getColumnPos(context, "to"),
-                                                false
-                                            )
-                                        )
-                                )
-                        )
-                        .then(Commands.literal("all").executes(context -> removeAll(context.getSource())))
-                )
-                .then(
-                    Commands.literal("query")
-                        .executes(context -> listForceLoad(context.getSource()))
-                        .then(
-                            Commands.argument("pos", ColumnPosArgument.columnPos())
-                                .executes(context -> queryForceLoad(context.getSource(), ColumnPosArgument.getColumnPos(context, "pos")))
-                        )
-                )
-        );
-    }
-
-    private static int queryForceLoad(CommandSourceStack source, ColumnPos pos) throws CommandSyntaxException {
-        ChunkPos chunkPos = pos.toChunkPos();
-        ServerLevel level = source.getLevel();
-        ResourceKey<Level> resourceKey = level.dimension();
-        boolean flag = level.getForcedChunks().contains(chunkPos.toLong());
-        if (flag) {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.forceload.query.success", Component.translationArg(chunkPos), Component.translationArg(resourceKey.location())
-                ),
-                false
-            );
-            return 1;
-        } else {
-            throw ERROR_NOT_TICKING.create(chunkPos, resourceKey.location());
-        }
-    }
-
-    private static int listForceLoad(CommandSourceStack source) {
-        ServerLevel level = source.getLevel();
-        ResourceKey<Level> resourceKey = level.dimension();
-        LongSet forcedChunks = level.getForcedChunks();
-        int size = forcedChunks.size();
-        if (size > 0) {
-            String string = Joiner.on(", ").join(forcedChunks.stream().sorted().map(ChunkPos::new).map(ChunkPos::toString).iterator());
-            if (size == 1) {
-                source.sendSuccess(
-                    () -> Component.translatable("commands.forceload.list.single", Component.translationArg(resourceKey.location()), string), false
-                );
-            } else {
-                source.sendSuccess(
-                    () -> Component.translatable("commands.forceload.list.multiple", size, Component.translationArg(resourceKey.location()), string), false
-                );
-            }
-        } else {
-            source.sendFailure(Component.translatable("commands.forceload.added.none", Component.translationArg(resourceKey.location())));
-        }
-
-        return size;
-    }
-
-    private static int removeAll(CommandSourceStack source) {
-        ServerLevel level = source.getLevel();
-        ResourceKey<Level> resourceKey = level.dimension();
-        LongSet forcedChunks = level.getForcedChunks();
-        forcedChunks.forEach(packedChunkPos -> level.setChunkForced(ChunkPos.getX(packedChunkPos), ChunkPos.getZ(packedChunkPos), false));
-        source.sendSuccess(() -> Component.translatable("commands.forceload.removed.all", Component.translationArg(resourceKey.location())), true);
-        return 0;
-    }
-
-    private static int changeForceLoad(CommandSourceStack source, ColumnPos from, ColumnPos to, boolean add) throws CommandSyntaxException {
-        int min = Math.min(from.x(), to.x());
-        int min1 = Math.min(from.z(), to.z());
-        int max = Math.max(from.x(), to.x());
-        int max1 = Math.max(from.z(), to.z());
-        if (min >= -30000000 && min1 >= -30000000 && max < 30000000 && max1 < 30000000) {
-            int sectionPosCoord = SectionPos.blockToSectionCoord(min);
-            int sectionPosCoord1 = SectionPos.blockToSectionCoord(min1);
-            int sectionPosCoord2 = SectionPos.blockToSectionCoord(max);
-            int sectionPosCoord3 = SectionPos.blockToSectionCoord(max1);
-            long l = (sectionPosCoord2 - sectionPosCoord + 1L) * (sectionPosCoord3 - sectionPosCoord1 + 1L);
-            if (l > 256L) {
-                throw ERROR_TOO_MANY_CHUNKS.create(256, l);
-            } else {
-                ServerLevel level = source.getLevel();
-                ResourceKey<Level> resourceKey = level.dimension();
-                ChunkPos chunkPos = null;
-                int i = 0;
-
-                for (int i1 = sectionPosCoord; i1 <= sectionPosCoord2; i1++) {
-                    for (int i2 = sectionPosCoord1; i2 <= sectionPosCoord3; i2++) {
-                        boolean flag = level.setChunkForced(i1, i2, add);
-                        if (flag) {
-                            i++;
-                            if (chunkPos == null) {
-                                chunkPos = new ChunkPos(i1, i2);
-                            }
-                        }
-                    }
-                }
-
-                ChunkPos chunkPos1 = chunkPos;
-                int i2x = i;
-                if (i2x == 0) {
-                    throw (add ? ERROR_ALL_ADDED : ERROR_NONE_REMOVED).create();
-                } else {
-                    if (i2x == 1) {
-                        source.sendSuccess(
-                            () -> Component.translatable(
-                                "commands.forceload." + (add ? "added" : "removed") + ".single",
-                                Component.translationArg(chunkPos1),
-                                Component.translationArg(resourceKey.location())
-                            ),
-                            true
-                        );
-                    } else {
-                        ChunkPos chunkPos2 = new ChunkPos(sectionPosCoord, sectionPosCoord1);
-                        ChunkPos chunkPos3 = new ChunkPos(sectionPosCoord2, sectionPosCoord3);
-                        source.sendSuccess(
-                            () -> Component.translatable(
-                                "commands.forceload." + (add ? "added" : "removed") + ".multiple",
-                                i2x,
-                                Component.translationArg(resourceKey.location()),
-                                Component.translationArg(chunkPos2),
-                                Component.translationArg(chunkPos3)
-                            ),
-                            true
-                        );
-                    }
-
-                    return i2x;
-                }
-            }
-        } else {
-            throw BlockPosArgument.ERROR_OUT_OF_WORLD.create();
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/FunctionCommand.java b/net/minecraft/server/commands/FunctionCommand.java
index b28153e7321e23ba8e0c2b99d1e80bad1240a077..ad0acee024ea5e94fcf4e7652c3244ca1205afb2 100644
--- a/net/minecraft/server/commands/FunctionCommand.java
+++ b/net/minecraft/server/commands/FunctionCommand.java
@@ -53,12 +53,7 @@ public class FunctionCommand {
         SharedSuggestionProvider.suggestResource(functions.getTagNames(), suggestions, "#");
         return SharedSuggestionProvider.suggestResource(functions.getFunctionNames(), suggestions);
     };
-    static final FunctionCommand.Callbacks<CommandSourceStack> FULL_CONTEXT_CALLBACKS = new FunctionCommand.Callbacks<CommandSourceStack>() {
-        @Override
-        public void signalResult(CommandSourceStack source, ResourceLocation function, int commands) {
-            source.sendSuccess(() -> Component.translatable("commands.function.result", Component.translationArg(function), commands), true);
-        }
-    };
+    static final FunctionCommand.Callbacks<CommandSourceStack> FULL_CONTEXT_CALLBACKS = (source, function, commands) -> source.sendSuccess(() -> net.minecraft.network.chat.Component.translatable("commands.function.result", net.minecraft.network.chat.Component.translationArg(function), commands), true);
 
     public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
         LiteralArgumentBuilder<CommandSourceStack> literalArgumentBuilder = Commands.literal("with");
diff --git a/net/minecraft/server/commands/GameModeCommand.java b/net/minecraft/server/commands/GameModeCommand.java
index c44cdbbdc06b25bd20a208386545a10af9b96df8..ef3b48ea00dc1337f297292df336b31cf5abb834 100644
--- a/net/minecraft/server/commands/GameModeCommand.java
+++ b/net/minecraft/server/commands/GameModeCommand.java
@@ -14,8 +14,6 @@ import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.GameType;
 
 public class GameModeCommand {
-    public static final int PERMISSION_LEVEL = 2;
-
     public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
         dispatcher.register(
             Commands.literal("gamemode")
diff --git a/net/minecraft/server/commands/GiveCommand.java b/net/minecraft/server/commands/GiveCommand.java
index 8b7af734ca4ed3cafa810460b2cea6c1e6342a69..31f2476bd921a43abcec834cc5a21a4e0768e0c7 100644
--- a/net/minecraft/server/commands/GiveCommand.java
+++ b/net/minecraft/server/commands/GiveCommand.java
@@ -18,8 +18,6 @@ import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.item.ItemStack;
 
 public class GiveCommand {
-    public static final int MAX_ALLOWED_ITEMSTACKS = 100;
-
     public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext context) {
         dispatcher.register(
             Commands.literal("give")
diff --git a/net/minecraft/server/commands/HelpCommand.java b/net/minecraft/server/commands/HelpCommand.java
deleted file mode 100644
index e581285abe9ead212f0d1314add5d1167e8cbe0f..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/HelpCommand.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.google.common.collect.Iterables;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.ParseResults;
-import com.mojang.brigadier.arguments.StringArgumentType;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import com.mojang.brigadier.tree.CommandNode;
-import java.util.Map;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.network.chat.Component;
-
-public class HelpCommand {
-    private static final SimpleCommandExceptionType ERROR_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.help.failed"));
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("help")
-                .executes(context -> {
-                    Map<CommandNode<CommandSourceStack>, String> smartUsage = dispatcher.getSmartUsage(dispatcher.getRoot(), context.getSource());
-
-                    for (String string : smartUsage.values()) {
-                        context.getSource().sendSuccess(() -> Component.literal("/" + string), false);
-                    }
-
-                    return smartUsage.size();
-                })
-                .then(
-                    Commands.argument("command", StringArgumentType.greedyString())
-                        .executes(
-                            context -> {
-                                ParseResults<CommandSourceStack> parseResults = dispatcher.parse(
-                                    StringArgumentType.getString(context, "command"), context.getSource()
-                                );
-                                if (parseResults.getContext().getNodes().isEmpty()) {
-                                    throw ERROR_FAILED.create();
-                                } else {
-                                    Map<CommandNode<CommandSourceStack>, String> smartUsage = dispatcher.getSmartUsage(
-                                        Iterables.getLast(parseResults.getContext().getNodes()).getNode(), context.getSource()
-                                    );
-
-                                    for (String string : smartUsage.values()) {
-                                        context.getSource()
-                                            .sendSuccess(() -> Component.literal("/" + parseResults.getReader().getString() + " " + string), false);
-                                    }
-
-                                    return smartUsage.size();
-                                }
-                            }
-                        )
-                )
-        );
-    }
-}
diff --git a/net/minecraft/server/commands/ItemCommands.java b/net/minecraft/server/commands/ItemCommands.java
deleted file mode 100644
index 26894fa710c7f12a27bcfb97d699aedaabccc771..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/ItemCommands.java
+++ /dev/null
@@ -1,489 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
-import com.mojang.brigadier.exceptions.Dynamic3CommandExceptionType;
-import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
-import com.mojang.brigadier.suggestion.SuggestionProvider;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Map.Entry;
-import net.minecraft.commands.CommandBuildContext;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.SharedSuggestionProvider;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.commands.arguments.ResourceOrIdArgument;
-import net.minecraft.commands.arguments.SlotArgument;
-import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
-import net.minecraft.commands.arguments.item.ItemArgument;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Holder;
-import net.minecraft.core.registries.Registries;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.ReloadableServerRegistries;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.world.Container;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.SlotAccess;
-import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.level.block.entity.BlockEntity;
-import net.minecraft.world.level.storage.loot.LootContext;
-import net.minecraft.world.level.storage.loot.LootParams;
-import net.minecraft.world.level.storage.loot.functions.LootItemFunction;
-import net.minecraft.world.level.storage.loot.parameters.LootContextParamSets;
-import net.minecraft.world.level.storage.loot.parameters.LootContextParams;
-
-public class ItemCommands {
-    static final Dynamic3CommandExceptionType ERROR_TARGET_NOT_A_CONTAINER = new Dynamic3CommandExceptionType(
-        (x, y, z) -> Component.translatableEscape("commands.item.target.not_a_container", x, y, z)
-    );
-    static final Dynamic3CommandExceptionType ERROR_SOURCE_NOT_A_CONTAINER = new Dynamic3CommandExceptionType(
-        (x, y, z) -> Component.translatableEscape("commands.item.source.not_a_container", x, y, z)
-    );
-    static final DynamicCommandExceptionType ERROR_TARGET_INAPPLICABLE_SLOT = new DynamicCommandExceptionType(
-        invalidSlot -> Component.translatableEscape("commands.item.target.no_such_slot", invalidSlot)
-    );
-    private static final DynamicCommandExceptionType ERROR_SOURCE_INAPPLICABLE_SLOT = new DynamicCommandExceptionType(
-        invalidSlot -> Component.translatableEscape("commands.item.source.no_such_slot", invalidSlot)
-    );
-    private static final DynamicCommandExceptionType ERROR_TARGET_NO_CHANGES = new DynamicCommandExceptionType(
-        slot -> Component.translatableEscape("commands.item.target.no_changes", slot)
-    );
-    private static final Dynamic2CommandExceptionType ERROR_TARGET_NO_CHANGES_KNOWN_ITEM = new Dynamic2CommandExceptionType(
-        (stackName, slot) -> Component.translatableEscape("commands.item.target.no_changed.known_item", stackName, slot)
-    );
-    private static final SuggestionProvider<CommandSourceStack> SUGGEST_MODIFIER = (context, builder) -> {
-        ReloadableServerRegistries.Holder holder = context.getSource().getServer().reloadableRegistries();
-        return SharedSuggestionProvider.suggestResource(holder.getKeys(Registries.ITEM_MODIFIER), builder);
-    };
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext context) {
-        dispatcher.register(
-            Commands.literal("item")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.literal("replace")
-                        .then(
-                            Commands.literal("block")
-                                .then(
-                                    Commands.argument("pos", BlockPosArgument.blockPos())
-                                        .then(
-                                            Commands.argument("slot", SlotArgument.slot())
-                                                .then(
-                                                    Commands.literal("with")
-                                                        .then(
-                                                            Commands.argument("item", ItemArgument.item(context))
-                                                                .executes(
-                                                                    context1 -> setBlockItem(
-                                                                        context1.getSource(),
-                                                                        BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                                                        SlotArgument.getSlot(context1, "slot"),
-                                                                        ItemArgument.getItem(context1, "item").createItemStack(1, false)
-                                                                    )
-                                                                )
-                                                                .then(
-                                                                    Commands.argument("count", IntegerArgumentType.integer(1, 99))
-                                                                        .executes(
-                                                                            context1 -> setBlockItem(
-                                                                                context1.getSource(),
-                                                                                BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                                                                SlotArgument.getSlot(context1, "slot"),
-                                                                                ItemArgument.getItem(context1, "item")
-                                                                                    .createItemStack(IntegerArgumentType.getInteger(context1, "count"), true)
-                                                                            )
-                                                                        )
-                                                                )
-                                                        )
-                                                )
-                                                .then(
-                                                    Commands.literal("from")
-                                                        .then(
-                                                            Commands.literal("block")
-                                                                .then(
-                                                                    Commands.argument("source", BlockPosArgument.blockPos())
-                                                                        .then(
-                                                                            Commands.argument("sourceSlot", SlotArgument.slot())
-                                                                                .executes(
-                                                                                    context1 -> blockToBlock(
-                                                                                        context1.getSource(),
-                                                                                        BlockPosArgument.getLoadedBlockPos(context1, "source"),
-                                                                                        SlotArgument.getSlot(context1, "sourceSlot"),
-                                                                                        BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                                                                        SlotArgument.getSlot(context1, "slot")
-                                                                                    )
-                                                                                )
-                                                                                .then(
-                                                                                    Commands.argument("modifier", ResourceOrIdArgument.lootModifier(context))
-                                                                                        .suggests(SUGGEST_MODIFIER)
-                                                                                        .executes(
-                                                                                            context1 -> blockToBlock(
-                                                                                                (CommandSourceStack)context1.getSource(),
-                                                                                                BlockPosArgument.getLoadedBlockPos(context1, "source"),
-                                                                                                SlotArgument.getSlot(context1, "sourceSlot"),
-                                                                                                BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                                                                                SlotArgument.getSlot(context1, "slot"),
-                                                                                                ResourceOrIdArgument.getLootModifier(context1, "modifier")
-                                                                                            )
-                                                                                        )
-                                                                                )
-                                                                        )
-                                                                )
-                                                        )
-                                                        .then(
-                                                            Commands.literal("entity")
-                                                                .then(
-                                                                    Commands.argument("source", EntityArgument.entity())
-                                                                        .then(
-                                                                            Commands.argument("sourceSlot", SlotArgument.slot())
-                                                                                .executes(
-                                                                                    context1 -> entityToBlock(
-                                                                                        context1.getSource(),
-                                                                                        EntityArgument.getEntity(context1, "source"),
-                                                                                        SlotArgument.getSlot(context1, "sourceSlot"),
-                                                                                        BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                                                                        SlotArgument.getSlot(context1, "slot")
-                                                                                    )
-                                                                                )
-                                                                                .then(
-                                                                                    Commands.argument("modifier", ResourceOrIdArgument.lootModifier(context))
-                                                                                        .suggests(SUGGEST_MODIFIER)
-                                                                                        .executes(
-                                                                                            context1 -> entityToBlock(
-                                                                                                (CommandSourceStack)context1.getSource(),
-                                                                                                EntityArgument.getEntity(context1, "source"),
-                                                                                                SlotArgument.getSlot(context1, "sourceSlot"),
-                                                                                                BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                                                                                SlotArgument.getSlot(context1, "slot"),
-                                                                                                ResourceOrIdArgument.getLootModifier(context1, "modifier")
-                                                                                            )
-                                                                                        )
-                                                                                )
-                                                                        )
-                                                                )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                        .then(
-                            Commands.literal("entity")
-                                .then(
-                                    Commands.argument("targets", EntityArgument.entities())
-                                        .then(
-                                            Commands.argument("slot", SlotArgument.slot())
-                                                .then(
-                                                    Commands.literal("with")
-                                                        .then(
-                                                            Commands.argument("item", ItemArgument.item(context))
-                                                                .executes(
-                                                                    context1 -> setEntityItem(
-                                                                        context1.getSource(),
-                                                                        EntityArgument.getEntities(context1, "targets"),
-                                                                        SlotArgument.getSlot(context1, "slot"),
-                                                                        ItemArgument.getItem(context1, "item").createItemStack(1, false)
-                                                                    )
-                                                                )
-                                                                .then(
-                                                                    Commands.argument("count", IntegerArgumentType.integer(1, 99))
-                                                                        .executes(
-                                                                            context1 -> setEntityItem(
-                                                                                context1.getSource(),
-                                                                                EntityArgument.getEntities(context1, "targets"),
-                                                                                SlotArgument.getSlot(context1, "slot"),
-                                                                                ItemArgument.getItem(context1, "item")
-                                                                                    .createItemStack(IntegerArgumentType.getInteger(context1, "count"), true)
-                                                                            )
-                                                                        )
-                                                                )
-                                                        )
-                                                )
-                                                .then(
-                                                    Commands.literal("from")
-                                                        .then(
-                                                            Commands.literal("block")
-                                                                .then(
-                                                                    Commands.argument("source", BlockPosArgument.blockPos())
-                                                                        .then(
-                                                                            Commands.argument("sourceSlot", SlotArgument.slot())
-                                                                                .executes(
-                                                                                    context1 -> blockToEntities(
-                                                                                        context1.getSource(),
-                                                                                        BlockPosArgument.getLoadedBlockPos(context1, "source"),
-                                                                                        SlotArgument.getSlot(context1, "sourceSlot"),
-                                                                                        EntityArgument.getEntities(context1, "targets"),
-                                                                                        SlotArgument.getSlot(context1, "slot")
-                                                                                    )
-                                                                                )
-                                                                                .then(
-                                                                                    Commands.argument("modifier", ResourceOrIdArgument.lootModifier(context))
-                                                                                        .suggests(SUGGEST_MODIFIER)
-                                                                                        .executes(
-                                                                                            context1 -> blockToEntities(
-                                                                                                (CommandSourceStack)context1.getSource(),
-                                                                                                BlockPosArgument.getLoadedBlockPos(context1, "source"),
-                                                                                                SlotArgument.getSlot(context1, "sourceSlot"),
-                                                                                                EntityArgument.getEntities(context1, "targets"),
-                                                                                                SlotArgument.getSlot(context1, "slot"),
-                                                                                                ResourceOrIdArgument.getLootModifier(context1, "modifier")
-                                                                                            )
-                                                                                        )
-                                                                                )
-                                                                        )
-                                                                )
-                                                        )
-                                                        .then(
-                                                            Commands.literal("entity")
-                                                                .then(
-                                                                    Commands.argument("source", EntityArgument.entity())
-                                                                        .then(
-                                                                            Commands.argument("sourceSlot", SlotArgument.slot())
-                                                                                .executes(
-                                                                                    context1 -> entityToEntities(
-                                                                                        context1.getSource(),
-                                                                                        EntityArgument.getEntity(context1, "source"),
-                                                                                        SlotArgument.getSlot(context1, "sourceSlot"),
-                                                                                        EntityArgument.getEntities(context1, "targets"),
-                                                                                        SlotArgument.getSlot(context1, "slot")
-                                                                                    )
-                                                                                )
-                                                                                .then(
-                                                                                    Commands.argument("modifier", ResourceOrIdArgument.lootModifier(context))
-                                                                                        .suggests(SUGGEST_MODIFIER)
-                                                                                        .executes(
-                                                                                            context1 -> entityToEntities(
-                                                                                                (CommandSourceStack)context1.getSource(),
-                                                                                                EntityArgument.getEntity(context1, "source"),
-                                                                                                SlotArgument.getSlot(context1, "sourceSlot"),
-                                                                                                EntityArgument.getEntities(context1, "targets"),
-                                                                                                SlotArgument.getSlot(context1, "slot"),
-                                                                                                ResourceOrIdArgument.getLootModifier(context1, "modifier")
-                                                                                            )
-                                                                                        )
-                                                                                )
-                                                                        )
-                                                                )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                )
-                .then(
-                    Commands.literal("modify")
-                        .then(
-                            Commands.literal("block")
-                                .then(
-                                    Commands.argument("pos", BlockPosArgument.blockPos())
-                                        .then(
-                                            Commands.argument("slot", SlotArgument.slot())
-                                                .then(
-                                                    Commands.argument("modifier", ResourceOrIdArgument.lootModifier(context))
-                                                        .suggests(SUGGEST_MODIFIER)
-                                                        .executes(
-                                                            context1 -> modifyBlockItem(
-                                                                (CommandSourceStack)context1.getSource(),
-                                                                BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                                                SlotArgument.getSlot(context1, "slot"),
-                                                                ResourceOrIdArgument.getLootModifier(context1, "modifier")
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                        .then(
-                            Commands.literal("entity")
-                                .then(
-                                    Commands.argument("targets", EntityArgument.entities())
-                                        .then(
-                                            Commands.argument("slot", SlotArgument.slot())
-                                                .then(
-                                                    Commands.argument("modifier", ResourceOrIdArgument.lootModifier(context))
-                                                        .suggests(SUGGEST_MODIFIER)
-                                                        .executes(
-                                                            context1 -> modifyEntityItem(
-                                                                (CommandSourceStack)context1.getSource(),
-                                                                EntityArgument.getEntities(context1, "targets"),
-                                                                SlotArgument.getSlot(context1, "slot"),
-                                                                ResourceOrIdArgument.getLootModifier(context1, "modifier")
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int modifyBlockItem(CommandSourceStack source, BlockPos pos, int slot, Holder<LootItemFunction> modifier) throws CommandSyntaxException {
-        Container container = getContainer(source, pos, ERROR_TARGET_NOT_A_CONTAINER);
-        if (slot >= 0 && slot < container.getContainerSize()) {
-            ItemStack itemStack = applyModifier(source, modifier, container.getItem(slot));
-            container.setItem(slot, itemStack);
-            source.sendSuccess(
-                () -> Component.translatable("commands.item.block.set.success", pos.getX(), pos.getY(), pos.getZ(), itemStack.getDisplayName()), true
-            );
-            return 1;
-        } else {
-            throw ERROR_TARGET_INAPPLICABLE_SLOT.create(slot);
-        }
-    }
-
-    private static int modifyEntityItem(CommandSourceStack source, Collection<? extends Entity> targets, int sourceSlot, Holder<LootItemFunction> modifer) throws CommandSyntaxException {
-        Map<Entity, ItemStack> map = Maps.newHashMapWithExpectedSize(targets.size());
-
-        for (Entity entity : targets) {
-            SlotAccess slot = entity.getSlot(sourceSlot);
-            if (slot != SlotAccess.NULL) {
-                ItemStack itemStack = applyModifier(source, modifer, slot.get().copy());
-                if (slot.set(itemStack)) {
-                    map.put(entity, itemStack);
-                    if (entity instanceof ServerPlayer) {
-                        ((ServerPlayer)entity).containerMenu.broadcastChanges();
-                    }
-                }
-            }
-        }
-
-        if (map.isEmpty()) {
-            throw ERROR_TARGET_NO_CHANGES.create(sourceSlot);
-        } else {
-            if (map.size() == 1) {
-                Entry<Entity, ItemStack> entry = map.entrySet().iterator().next();
-                source.sendSuccess(
-                    () -> Component.translatable("commands.item.entity.set.success.single", entry.getKey().getDisplayName(), entry.getValue().getDisplayName()),
-                    true
-                );
-            } else {
-                source.sendSuccess(() -> Component.translatable("commands.item.entity.set.success.multiple", map.size()), true);
-            }
-
-            return map.size();
-        }
-    }
-
-    private static int setBlockItem(CommandSourceStack source, BlockPos pos, int slot, ItemStack item) throws CommandSyntaxException {
-        Container container = getContainer(source, pos, ERROR_TARGET_NOT_A_CONTAINER);
-        if (slot >= 0 && slot < container.getContainerSize()) {
-            container.setItem(slot, item);
-            source.sendSuccess(() -> Component.translatable("commands.item.block.set.success", pos.getX(), pos.getY(), pos.getZ(), item.getDisplayName()), true);
-            return 1;
-        } else {
-            throw ERROR_TARGET_INAPPLICABLE_SLOT.create(slot);
-        }
-    }
-
-    static Container getContainer(CommandSourceStack source, BlockPos pos, Dynamic3CommandExceptionType exception) throws CommandSyntaxException {
-        BlockEntity blockEntity = source.getLevel().getBlockEntity(pos);
-        if (!(blockEntity instanceof Container)) {
-            throw exception.create(pos.getX(), pos.getY(), pos.getZ());
-        } else {
-            return (Container)blockEntity;
-        }
-    }
-
-    private static int setEntityItem(CommandSourceStack source, Collection<? extends Entity> targets, int slot, ItemStack item) throws CommandSyntaxException {
-        List<Entity> list = Lists.newArrayListWithCapacity(targets.size());
-
-        for (Entity entity : targets) {
-            SlotAccess slot1 = entity.getSlot(slot);
-            if (slot1 != SlotAccess.NULL && slot1.set(item.copy())) {
-                list.add(entity);
-                if (entity instanceof ServerPlayer) {
-                    ((ServerPlayer)entity).containerMenu.broadcastChanges();
-                }
-            }
-        }
-
-        if (list.isEmpty()) {
-            throw ERROR_TARGET_NO_CHANGES_KNOWN_ITEM.create(item.getDisplayName(), slot);
-        } else {
-            if (list.size() == 1) {
-                source.sendSuccess(
-                    () -> Component.translatable("commands.item.entity.set.success.single", list.iterator().next().getDisplayName(), item.getDisplayName()),
-                    true
-                );
-            } else {
-                source.sendSuccess(() -> Component.translatable("commands.item.entity.set.success.multiple", list.size(), item.getDisplayName()), true);
-            }
-
-            return list.size();
-        }
-    }
-
-    private static int blockToEntities(CommandSourceStack source, BlockPos pos, int sourceSlot, Collection<? extends Entity> targets, int slot) throws CommandSyntaxException {
-        return setEntityItem(source, targets, slot, getBlockItem(source, pos, sourceSlot));
-    }
-
-    private static int blockToEntities(
-        CommandSourceStack source, BlockPos pos, int sourceSlot, Collection<? extends Entity> targets, int slot, Holder<LootItemFunction> modifier
-    ) throws CommandSyntaxException {
-        return setEntityItem(source, targets, slot, applyModifier(source, modifier, getBlockItem(source, pos, sourceSlot)));
-    }
-
-    private static int blockToBlock(CommandSourceStack source, BlockPos sourcePos, int sourceSlot, BlockPos pos, int slot) throws CommandSyntaxException {
-        return setBlockItem(source, pos, slot, getBlockItem(source, sourcePos, sourceSlot));
-    }
-
-    private static int blockToBlock(CommandSourceStack source, BlockPos sourcePos, int sourceSlot, BlockPos pos, int slot, Holder<LootItemFunction> modifier) throws CommandSyntaxException {
-        return setBlockItem(source, pos, slot, applyModifier(source, modifier, getBlockItem(source, sourcePos, sourceSlot)));
-    }
-
-    private static int entityToBlock(CommandSourceStack source, Entity sourceEntity, int sourceSlot, BlockPos pos, int slot) throws CommandSyntaxException {
-        return setBlockItem(source, pos, slot, getEntityItem(sourceEntity, sourceSlot));
-    }
-
-    private static int entityToBlock(CommandSourceStack source, Entity sourceEntity, int sourceSlot, BlockPos pos, int slot, Holder<LootItemFunction> modifier) throws CommandSyntaxException {
-        return setBlockItem(source, pos, slot, applyModifier(source, modifier, getEntityItem(sourceEntity, sourceSlot)));
-    }
-
-    private static int entityToEntities(CommandSourceStack source, Entity sourceEntity, int sourceSlot, Collection<? extends Entity> targets, int slot) throws CommandSyntaxException {
-        return setEntityItem(source, targets, slot, getEntityItem(sourceEntity, sourceSlot));
-    }
-
-    private static int entityToEntities(
-        CommandSourceStack source, Entity sourceEntity, int sourceSlot, Collection<? extends Entity> targets, int slot, Holder<LootItemFunction> modifier
-    ) throws CommandSyntaxException {
-        return setEntityItem(source, targets, slot, applyModifier(source, modifier, getEntityItem(sourceEntity, sourceSlot)));
-    }
-
-    private static ItemStack applyModifier(CommandSourceStack source, Holder<LootItemFunction> modifier, ItemStack stack) {
-        ServerLevel level = source.getLevel();
-        LootParams lootParams = new LootParams.Builder(level)
-            .withParameter(LootContextParams.ORIGIN, source.getPosition())
-            .withOptionalParameter(LootContextParams.THIS_ENTITY, source.getEntity())
-            .create(LootContextParamSets.COMMAND);
-        LootContext lootContext = new LootContext.Builder(lootParams).create(Optional.empty());
-        lootContext.pushVisitedElement(LootContext.createVisitedEntry(modifier.value()));
-        ItemStack itemStack = modifier.value().apply(stack, lootContext);
-        itemStack.limitSize(itemStack.getMaxStackSize());
-        return itemStack;
-    }
-
-    private static ItemStack getEntityItem(Entity entity, int slot) throws CommandSyntaxException {
-        SlotAccess slot1 = entity.getSlot(slot);
-        if (slot1 == SlotAccess.NULL) {
-            throw ERROR_SOURCE_INAPPLICABLE_SLOT.create(slot);
-        } else {
-            return slot1.get().copy();
-        }
-    }
-
-    private static ItemStack getBlockItem(CommandSourceStack source, BlockPos pos, int slot) throws CommandSyntaxException {
-        Container container = getContainer(source, pos, ERROR_SOURCE_NOT_A_CONTAINER);
-        if (slot >= 0 && slot < container.getContainerSize()) {
-            return container.getItem(slot).copy();
-        } else {
-            throw ERROR_SOURCE_INAPPLICABLE_SLOT.create(slot);
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/JfrCommand.java b/net/minecraft/server/commands/JfrCommand.java
deleted file mode 100644
index 5b32584379d946dc424c9d716fd0d9be5ddfdd64..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/JfrCommand.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import java.nio.file.Path;
-import java.nio.file.Paths;
-import net.minecraft.ChatFormatting;
-import net.minecraft.SharedConstants;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.network.chat.ClickEvent;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.HoverEvent;
-import net.minecraft.util.profiling.jfr.Environment;
-import net.minecraft.util.profiling.jfr.JvmProfiler;
-
-public class JfrCommand {
-    private static final SimpleCommandExceptionType START_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.jfr.start.failed"));
-    private static final DynamicCommandExceptionType DUMP_FAILED = new DynamicCommandExceptionType(
-        message -> Component.translatableEscape("commands.jfr.dump.failed", message)
-    );
-
-    private JfrCommand() {
-    }
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("jfr")
-                .requires(source -> source.hasPermission(4))
-                .then(Commands.literal("start").executes(context -> startJfr(context.getSource())))
-                .then(Commands.literal("stop").executes(context -> stopJfr(context.getSource())))
-        );
-    }
-
-    private static int startJfr(CommandSourceStack source) throws CommandSyntaxException {
-        Environment environment = Environment.from(source.getServer());
-        if (!JvmProfiler.INSTANCE.start(environment)) {
-            throw START_FAILED.create();
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.jfr.started"), false);
-            return 1;
-        }
-    }
-
-    private static int stopJfr(CommandSourceStack source) throws CommandSyntaxException {
-        try {
-            Path path = Paths.get(".").relativize(JvmProfiler.INSTANCE.stop().normalize());
-            Path path1 = source.getServer().isPublished() && !SharedConstants.IS_RUNNING_IN_IDE ? path : path.toAbsolutePath();
-            Component component = Component.literal(path.toString())
-                .withStyle(ChatFormatting.UNDERLINE)
-                .withStyle(
-                    style -> style.withClickEvent(new ClickEvent(ClickEvent.Action.COPY_TO_CLIPBOARD, path1.toString()))
-                        .withHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, Component.translatable("chat.copy.click")))
-                );
-            source.sendSuccess(() -> Component.translatable("commands.jfr.stopped", component), false);
-            return 1;
-        } catch (Throwable var4) {
-            throw DUMP_FAILED.create(var4.getMessage());
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/KickCommand.java b/net/minecraft/server/commands/KickCommand.java
deleted file mode 100644
index 96a85803ceae7054a60067de4ec2116a35720e66..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/KickCommand.java
+++ /dev/null
@@ -1,64 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import java.util.Collection;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.commands.arguments.MessageArgument;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.level.ServerPlayer;
-
-public class KickCommand {
-    private static final SimpleCommandExceptionType ERROR_KICKING_OWNER = new SimpleCommandExceptionType(Component.translatable("commands.kick.owner.failed"));
-    private static final SimpleCommandExceptionType ERROR_SINGLEPLAYER = new SimpleCommandExceptionType(
-        Component.translatable("commands.kick.singleplayer.failed")
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("kick")
-                .requires(source -> source.hasPermission(3))
-                .then(
-                    Commands.argument("targets", EntityArgument.players())
-                        .executes(
-                            context -> kickPlayers(
-                                context.getSource(), EntityArgument.getPlayers(context, "targets"), Component.translatable("multiplayer.disconnect.kicked")
-                            )
-                        )
-                        .then(
-                            Commands.argument("reason", MessageArgument.message())
-                                .executes(
-                                    context -> kickPlayers(
-                                        context.getSource(), EntityArgument.getPlayers(context, "targets"), MessageArgument.getMessage(context, "reason")
-                                    )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int kickPlayers(CommandSourceStack source, Collection<ServerPlayer> players, Component reason) throws CommandSyntaxException {
-        if (!source.getServer().isPublished()) {
-            throw ERROR_SINGLEPLAYER.create();
-        } else {
-            int i = 0;
-
-            for (ServerPlayer serverPlayer : players) {
-                if (!source.getServer().isSingleplayerOwner(serverPlayer.getGameProfile())) {
-                    serverPlayer.connection.disconnect(reason, org.bukkit.event.player.PlayerKickEvent.Cause.KICK_COMMAND); // Paper - kick event cause
-                    source.sendSuccess(() -> Component.translatable("commands.kick.success", serverPlayer.getDisplayName(), reason), true);
-                    i++;
-                }
-            }
-
-            if (i == 0) {
-                throw ERROR_KICKING_OWNER.create();
-            } else {
-                return i;
-            }
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/ListPlayersCommand.java b/net/minecraft/server/commands/ListPlayersCommand.java
deleted file mode 100644
index c6ae34f91b3629990294fc5e69237a1e600ef038..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/ListPlayersCommand.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import java.util.List;
-import java.util.function.Function;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.ComponentUtils;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.server.players.PlayerList;
-import net.minecraft.world.entity.player.Player;
-
-public class ListPlayersCommand {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("list")
-                .executes(context -> listPlayers(context.getSource()))
-                .then(Commands.literal("uuids").executes(context -> listPlayersWithUuids(context.getSource())))
-        );
-    }
-
-    private static int listPlayers(CommandSourceStack source) {
-        return format(source, Player::getDisplayName);
-    }
-
-    private static int listPlayersWithUuids(CommandSourceStack source) {
-        return format(
-            source, player -> Component.translatable("commands.list.nameAndId", player.getName(), Component.translationArg(player.getGameProfile().getId()))
-        );
-    }
-
-    private static int format(CommandSourceStack source, Function<ServerPlayer, Component> nameExtractor) {
-        PlayerList playerList = source.getServer().getPlayerList();
-        // CraftBukkit start
-        List<ServerPlayer> playersTemp = playerList.getPlayers();
-        if (source.getBukkitSender() instanceof org.bukkit.entity.Player) {
-            org.bukkit.entity.Player sender = (org.bukkit.entity.Player) source.getBukkitSender();
-            playersTemp = playersTemp.stream().filter((ep) -> sender.canSee(ep.getBukkitEntity())).collect(java.util.stream.Collectors.toList());
-        }
-        final List<ServerPlayer> players = playersTemp;
-        // CraftBukkit end
-        Component component = ComponentUtils.formatList(players, nameExtractor);
-        source.sendSuccess(() -> Component.translatable("commands.list.players", players.size(), playerList.getMaxPlayers(), component), false);
-        return players.size();
-    }
-}
diff --git a/net/minecraft/server/commands/LocateCommand.java b/net/minecraft/server/commands/LocateCommand.java
deleted file mode 100644
index 13bcd8653d766cd0b754a22e9aab261fbc62b0a5..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/LocateCommand.java
+++ /dev/null
@@ -1,207 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.google.common.base.Stopwatch;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
-import com.mojang.datafixers.util.Pair;
-import com.mojang.logging.LogUtils;
-import java.time.Duration;
-import java.util.Optional;
-import net.minecraft.ChatFormatting;
-import net.minecraft.Util;
-import net.minecraft.commands.CommandBuildContext;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.ResourceOrTagArgument;
-import net.minecraft.commands.arguments.ResourceOrTagKeyArgument;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Holder;
-import net.minecraft.core.HolderSet;
-import net.minecraft.core.Registry;
-import net.minecraft.core.registries.Registries;
-import net.minecraft.network.chat.ClickEvent;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.ComponentUtils;
-import net.minecraft.network.chat.HoverEvent;
-import net.minecraft.resources.ResourceKey;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.util.Mth;
-import net.minecraft.world.entity.ai.village.poi.PoiManager;
-import net.minecraft.world.entity.ai.village.poi.PoiType;
-import net.minecraft.world.level.biome.Biome;
-import net.minecraft.world.level.levelgen.structure.Structure;
-import org.slf4j.Logger;
-
-public class LocateCommand {
-    private static final Logger LOGGER = LogUtils.getLogger();
-    private static final DynamicCommandExceptionType ERROR_STRUCTURE_NOT_FOUND = new DynamicCommandExceptionType(
-        structureType -> Component.translatableEscape("commands.locate.structure.not_found", structureType)
-    );
-    private static final DynamicCommandExceptionType ERROR_STRUCTURE_INVALID = new DynamicCommandExceptionType(
-        structureType -> Component.translatableEscape("commands.locate.structure.invalid", structureType)
-    );
-    private static final DynamicCommandExceptionType ERROR_BIOME_NOT_FOUND = new DynamicCommandExceptionType(
-        biomeType -> Component.translatableEscape("commands.locate.biome.not_found", biomeType)
-    );
-    private static final DynamicCommandExceptionType ERROR_POI_NOT_FOUND = new DynamicCommandExceptionType(
-        biomeType -> Component.translatableEscape("commands.locate.poi.not_found", biomeType)
-    );
-    private static final int MAX_STRUCTURE_SEARCH_RADIUS = 100;
-    private static final int MAX_BIOME_SEARCH_RADIUS = 6400;
-    private static final int BIOME_SAMPLE_RESOLUTION_HORIZONTAL = 32;
-    private static final int BIOME_SAMPLE_RESOLUTION_VERTICAL = 64;
-    private static final int POI_SEARCH_RADIUS = 256;
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext context) {
-        dispatcher.register(
-            Commands.literal("locate")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.literal("structure")
-                        .then(
-                            Commands.argument("structure", ResourceOrTagKeyArgument.resourceOrTagKey(Registries.STRUCTURE))
-                                .executes(
-                                    context1 -> locateStructure(
-                                        context1.getSource(),
-                                        ResourceOrTagKeyArgument.getResourceOrTagKey(context1, "structure", Registries.STRUCTURE, ERROR_STRUCTURE_INVALID)
-                                    )
-                                )
-                        )
-                )
-                .then(
-                    Commands.literal("biome")
-                        .then(
-                            Commands.argument("biome", ResourceOrTagArgument.resourceOrTag(context, Registries.BIOME))
-                                .executes(
-                                    context1 -> locateBiome(context1.getSource(), ResourceOrTagArgument.getResourceOrTag(context1, "biome", Registries.BIOME))
-                                )
-                        )
-                )
-                .then(
-                    Commands.literal("poi")
-                        .then(
-                            Commands.argument("poi", ResourceOrTagArgument.resourceOrTag(context, Registries.POINT_OF_INTEREST_TYPE))
-                                .executes(
-                                    context1 -> locatePoi(
-                                        context1.getSource(), ResourceOrTagArgument.getResourceOrTag(context1, "poi", Registries.POINT_OF_INTEREST_TYPE)
-                                    )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static Optional<? extends HolderSet.ListBacked<Structure>> getHolders(
-        ResourceOrTagKeyArgument.Result<Structure> structure, Registry<Structure> structureRegistry
-    ) {
-        return structure.unwrap()
-            .map(
-                structureKey -> structureRegistry.get((ResourceKey<Structure>)structureKey).map(structureHolder -> HolderSet.direct(structureHolder)),
-                structureRegistry::get
-            );
-    }
-
-    private static int locateStructure(CommandSourceStack source, ResourceOrTagKeyArgument.Result<Structure> structure) throws CommandSyntaxException {
-        Registry<Structure> registry = source.getLevel().registryAccess().lookupOrThrow(Registries.STRUCTURE);
-        HolderSet<Structure> holderSet = (HolderSet<Structure>)getHolders(structure, registry)
-            .orElseThrow(() -> ERROR_STRUCTURE_INVALID.create(structure.asPrintable()));
-        BlockPos blockPos = BlockPos.containing(source.getPosition());
-        ServerLevel level = source.getLevel();
-        Stopwatch stopwatch = Stopwatch.createStarted(Util.TICKER);
-        Pair<BlockPos, Holder<Structure>> pair = level.getChunkSource().getGenerator().findNearestMapStructure(level, holderSet, blockPos, 100, false);
-        stopwatch.stop();
-        if (pair == null) {
-            throw ERROR_STRUCTURE_NOT_FOUND.create(structure.asPrintable());
-        } else {
-            return showLocateResult(source, structure, blockPos, pair, "commands.locate.structure.success", false, stopwatch.elapsed());
-        }
-    }
-
-    private static int locateBiome(CommandSourceStack source, ResourceOrTagArgument.Result<Biome> biome) throws CommandSyntaxException {
-        BlockPos blockPos = BlockPos.containing(source.getPosition());
-        Stopwatch stopwatch = Stopwatch.createStarted(Util.TICKER);
-        Pair<BlockPos, Holder<Biome>> pair = source.getLevel().findClosestBiome3d(biome, blockPos, 6400, 32, 64);
-        stopwatch.stop();
-        if (pair == null) {
-            throw ERROR_BIOME_NOT_FOUND.create(biome.asPrintable());
-        } else {
-            return showLocateResult(source, biome, blockPos, pair, "commands.locate.biome.success", true, stopwatch.elapsed());
-        }
-    }
-
-    private static int locatePoi(CommandSourceStack source, ResourceOrTagArgument.Result<PoiType> poiType) throws CommandSyntaxException {
-        BlockPos blockPos = BlockPos.containing(source.getPosition());
-        ServerLevel level = source.getLevel();
-        Stopwatch stopwatch = Stopwatch.createStarted(Util.TICKER);
-        Optional<Pair<Holder<PoiType>, BlockPos>> optional = level.getPoiManager().findClosestWithType(poiType, blockPos, 256, PoiManager.Occupancy.ANY);
-        stopwatch.stop();
-        if (optional.isEmpty()) {
-            throw ERROR_POI_NOT_FOUND.create(poiType.asPrintable());
-        } else {
-            return showLocateResult(source, poiType, blockPos, optional.get().swap(), "commands.locate.poi.success", false, stopwatch.elapsed());
-        }
-    }
-
-    public static int showLocateResult(
-        CommandSourceStack source,
-        ResourceOrTagArgument.Result<?> result,
-        BlockPos sourcePosition,
-        Pair<BlockPos, ? extends Holder<?>> resultWithPosition,
-        String translationKey,
-        boolean absoluteY,
-        Duration duration
-    ) {
-        String string = result.unwrap()
-            .map(reference -> result.asPrintable(), named -> result.asPrintable() + " (" + resultWithPosition.getSecond().getRegisteredName() + ")");
-        return showLocateResult(source, sourcePosition, resultWithPosition, translationKey, absoluteY, string, duration);
-    }
-
-    public static int showLocateResult(
-        CommandSourceStack source,
-        ResourceOrTagKeyArgument.Result<?> result,
-        BlockPos sourcePosition,
-        Pair<BlockPos, ? extends Holder<?>> resultWithPosition,
-        String translationKey,
-        boolean absoluteY,
-        Duration duration
-    ) {
-        String string = result.unwrap()
-            .map(
-                resourceKey -> resourceKey.location().toString(),
-                tagKey -> "#" + tagKey.location() + " (" + resultWithPosition.getSecond().getRegisteredName() + ")"
-            );
-        return showLocateResult(source, sourcePosition, resultWithPosition, translationKey, absoluteY, string, duration);
-    }
-
-    private static int showLocateResult(
-        CommandSourceStack source,
-        BlockPos sourcePosition,
-        Pair<BlockPos, ? extends Holder<?>> resultWithoutPosition,
-        String translationKey,
-        boolean absoluteY,
-        String elementName,
-        Duration duration
-    ) {
-        BlockPos blockPos = resultWithoutPosition.getFirst();
-        int i = absoluteY
-            ? Mth.floor(Mth.sqrt((float)sourcePosition.distSqr(blockPos)))
-            : Mth.floor(dist(sourcePosition.getX(), sourcePosition.getZ(), blockPos.getX(), blockPos.getZ()));
-        String string = absoluteY ? String.valueOf(blockPos.getY()) : "~";
-        Component component = ComponentUtils.wrapInSquareBrackets(Component.translatable("chat.coordinates", blockPos.getX(), string, blockPos.getZ()))
-            .withStyle(
-                style -> style.withColor(ChatFormatting.GREEN)
-                    .withClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, "/tp @s " + blockPos.getX() + " " + string + " " + blockPos.getZ()))
-                    .withHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, Component.translatable("chat.coordinates.tooltip")))
-            );
-        source.sendSuccess(() -> Component.translatable(translationKey, elementName, component, i), false);
-        LOGGER.info("Locating element " + elementName + " took " + duration.toMillis() + " ms");
-        return i;
-    }
-
-    private static float dist(int x1, int z1, int x2, int z2) {
-        int i = x2 - x1;
-        int i1 = z2 - z1;
-        return (float) Math.hypot(i, i1); // Paper - Fix MC-177381
-    }
-}
diff --git a/net/minecraft/server/commands/LookAt.java b/net/minecraft/server/commands/LookAt.java
index 69cab7de82b6122d3de3258b42a9aeb9d80bb144..dd596236a4c506992e94ad26ad0db4b9b3c25203 100644
--- a/net/minecraft/server/commands/LookAt.java
+++ b/net/minecraft/server/commands/LookAt.java
@@ -10,7 +10,7 @@ import net.minecraft.world.phys.Vec3;
 public interface LookAt {
     void perform(CommandSourceStack source, Entity entity);
 
-    public record LookAtEntity(Entity entity, EntityAnchorArgument.Anchor anchor) implements LookAt {
+    record LookAtEntity(Entity entity, EntityAnchorArgument.Anchor anchor) implements LookAt {
         @Override
         public void perform(CommandSourceStack source, Entity entity) {
             if (entity instanceof ServerPlayer serverPlayer) {
@@ -21,7 +21,7 @@ public interface LookAt {
         }
     }
 
-    public record LookAtPosition(Vec3 position) implements LookAt {
+    record LookAtPosition(Vec3 position) implements LookAt {
         @Override
         public void perform(CommandSourceStack source, Entity entity) {
             entity.lookAt(source.getAnchor(), this.position);
diff --git a/net/minecraft/server/commands/LootCommand.java b/net/minecraft/server/commands/LootCommand.java
deleted file mode 100644
index 7071d8dc6464bb5ea20f6fed7ada8234cfe7e7fd..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/LootCommand.java
+++ /dev/null
@@ -1,526 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.google.common.collect.Lists;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import com.mojang.brigadier.builder.ArgumentBuilder;
-import com.mojang.brigadier.context.CommandContext;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
-import com.mojang.brigadier.suggestion.SuggestionProvider;
-import java.util.Collection;
-import java.util.List;
-import java.util.Optional;
-import net.minecraft.commands.CommandBuildContext;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.SharedSuggestionProvider;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.commands.arguments.ResourceOrIdArgument;
-import net.minecraft.commands.arguments.SlotArgument;
-import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
-import net.minecraft.commands.arguments.coordinates.Vec3Argument;
-import net.minecraft.commands.arguments.item.ItemArgument;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Holder;
-import net.minecraft.core.registries.Registries;
-import net.minecraft.network.chat.Component;
-import net.minecraft.resources.ResourceKey;
-import net.minecraft.server.ReloadableServerRegistries;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.world.Container;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.EquipmentSlot;
-import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.SlotAccess;
-import net.minecraft.world.entity.item.ItemEntity;
-import net.minecraft.world.entity.player.Player;
-import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.level.block.entity.BlockEntity;
-import net.minecraft.world.level.block.state.BlockState;
-import net.minecraft.world.level.storage.loot.LootParams;
-import net.minecraft.world.level.storage.loot.LootTable;
-import net.minecraft.world.level.storage.loot.parameters.LootContextParamSets;
-import net.minecraft.world.level.storage.loot.parameters.LootContextParams;
-import net.minecraft.world.phys.Vec3;
-
-public class LootCommand {
-    public static final SuggestionProvider<CommandSourceStack> SUGGEST_LOOT_TABLE = (context, builder) -> {
-        ReloadableServerRegistries.Holder holder = context.getSource().getServer().reloadableRegistries();
-        return SharedSuggestionProvider.suggestResource(holder.getKeys(Registries.LOOT_TABLE), builder);
-    };
-    private static final DynamicCommandExceptionType ERROR_NO_HELD_ITEMS = new DynamicCommandExceptionType(
-        target -> Component.translatableEscape("commands.drop.no_held_items", target)
-    );
-    private static final DynamicCommandExceptionType ERROR_NO_ENTITY_LOOT_TABLE = new DynamicCommandExceptionType(
-        target -> Component.translatableEscape("commands.drop.no_loot_table.entity", target)
-    );
-    private static final DynamicCommandExceptionType ERROR_NO_BLOCK_LOOT_TABLE = new DynamicCommandExceptionType(
-        object -> Component.translatableEscape("commands.drop.no_loot_table.block", object)
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext context) {
-        dispatcher.register(
-            addTargets(
-                Commands.literal("loot").requires(commandSourceStack -> commandSourceStack.hasPermission(2)),
-                (builder, dropConsumer) -> builder.then(
-                        Commands.literal("fish")
-                            .then(
-                                Commands.argument("loot_table", ResourceOrIdArgument.lootTable(context))
-                                    .suggests(SUGGEST_LOOT_TABLE)
-                                    .then(
-                                        Commands.argument("pos", BlockPosArgument.blockPos())
-                                            .executes(
-                                                context1 -> dropFishingLoot(
-                                                    context1,
-                                                    ResourceOrIdArgument.getLootTable(context1, "loot_table"),
-                                                    BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                                    ItemStack.EMPTY,
-                                                    dropConsumer
-                                                )
-                                            )
-                                            .then(
-                                                Commands.argument("tool", ItemArgument.item(context))
-                                                    .executes(
-                                                        context1 -> dropFishingLoot(
-                                                            context1,
-                                                            ResourceOrIdArgument.getLootTable(context1, "loot_table"),
-                                                            BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                                            ItemArgument.getItem(context1, "tool").createItemStack(1, false),
-                                                            dropConsumer
-                                                        )
-                                                    )
-                                            )
-                                            .then(
-                                                Commands.literal("mainhand")
-                                                    .executes(
-                                                        context1 -> dropFishingLoot(
-                                                            context1,
-                                                            ResourceOrIdArgument.getLootTable(context1, "loot_table"),
-                                                            BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                                            getSourceHandItem(context1.getSource(), EquipmentSlot.MAINHAND),
-                                                            dropConsumer
-                                                        )
-                                                    )
-                                            )
-                                            .then(
-                                                Commands.literal("offhand")
-                                                    .executes(
-                                                        context1 -> dropFishingLoot(
-                                                            context1,
-                                                            ResourceOrIdArgument.getLootTable(context1, "loot_table"),
-                                                            BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                                            getSourceHandItem(context1.getSource(), EquipmentSlot.OFFHAND),
-                                                            dropConsumer
-                                                        )
-                                                    )
-                                            )
-                                    )
-                            )
-                    )
-                    .then(
-                        Commands.literal("loot")
-                            .then(
-                                Commands.argument("loot_table", ResourceOrIdArgument.lootTable(context))
-                                    .suggests(SUGGEST_LOOT_TABLE)
-                                    .executes(context1 -> dropChestLoot(context1, ResourceOrIdArgument.getLootTable(context1, "loot_table"), dropConsumer))
-                            )
-                    )
-                    .then(
-                        Commands.literal("kill")
-                            .then(
-                                Commands.argument("target", EntityArgument.entity())
-                                    .executes(context1 -> dropKillLoot(context1, EntityArgument.getEntity(context1, "target"), dropConsumer))
-                            )
-                    )
-                    .then(
-                        Commands.literal("mine")
-                            .then(
-                                Commands.argument("pos", BlockPosArgument.blockPos())
-                                    .executes(
-                                        context1 -> dropBlockLoot(context1, BlockPosArgument.getLoadedBlockPos(context1, "pos"), ItemStack.EMPTY, dropConsumer)
-                                    )
-                                    .then(
-                                        Commands.argument("tool", ItemArgument.item(context))
-                                            .executes(
-                                                context1 -> dropBlockLoot(
-                                                    context1,
-                                                    BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                                    ItemArgument.getItem(context1, "tool").createItemStack(1, false),
-                                                    dropConsumer
-                                                )
-                                            )
-                                    )
-                                    .then(
-                                        Commands.literal("mainhand")
-                                            .executes(
-                                                context1 -> dropBlockLoot(
-                                                    context1,
-                                                    BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                                    getSourceHandItem(context1.getSource(), EquipmentSlot.MAINHAND),
-                                                    dropConsumer
-                                                )
-                                            )
-                                    )
-                                    .then(
-                                        Commands.literal("offhand")
-                                            .executes(
-                                                commandContext -> dropBlockLoot(
-                                                    commandContext,
-                                                    BlockPosArgument.getLoadedBlockPos(commandContext, "pos"),
-                                                    getSourceHandItem(commandContext.getSource(), EquipmentSlot.OFFHAND),
-                                                    dropConsumer
-                                                )
-                                            )
-                                    )
-                            )
-                    )
-            )
-        );
-    }
-
-    private static <T extends ArgumentBuilder<CommandSourceStack, T>> T addTargets(T builder, LootCommand.TailProvider tailProvider) {
-        return builder.then(
-                Commands.literal("replace")
-                    .then(
-                        Commands.literal("entity")
-                            .then(
-                                Commands.argument("entities", EntityArgument.entities())
-                                    .then(
-                                        tailProvider.construct(
-                                                Commands.argument("slot", SlotArgument.slot()),
-                                                (context, items, callback) -> entityReplace(
-                                                    EntityArgument.getEntities(context, "entities"),
-                                                    SlotArgument.getSlot(context, "slot"),
-                                                    items.size(),
-                                                    items,
-                                                    callback
-                                                )
-                                            )
-                                            .then(
-                                                tailProvider.construct(
-                                                    Commands.argument("count", IntegerArgumentType.integer(0)),
-                                                    (context, items, callback) -> entityReplace(
-                                                        EntityArgument.getEntities(context, "entities"),
-                                                        SlotArgument.getSlot(context, "slot"),
-                                                        IntegerArgumentType.getInteger(context, "count"),
-                                                        items,
-                                                        callback
-                                                    )
-                                                )
-                                            )
-                                    )
-                            )
-                    )
-                    .then(
-                        Commands.literal("block")
-                            .then(
-                                Commands.argument("targetPos", BlockPosArgument.blockPos())
-                                    .then(
-                                        tailProvider.construct(
-                                                Commands.argument("slot", SlotArgument.slot()),
-                                                (context, items, callback) -> blockReplace(
-                                                    context.getSource(),
-                                                    BlockPosArgument.getLoadedBlockPos(context, "targetPos"),
-                                                    SlotArgument.getSlot(context, "slot"),
-                                                    items.size(),
-                                                    items,
-                                                    callback
-                                                )
-                                            )
-                                            .then(
-                                                tailProvider.construct(
-                                                    Commands.argument("count", IntegerArgumentType.integer(0)),
-                                                    (context, items, callback) -> blockReplace(
-                                                        context.getSource(),
-                                                        BlockPosArgument.getLoadedBlockPos(context, "targetPos"),
-                                                        IntegerArgumentType.getInteger(context, "slot"),
-                                                        IntegerArgumentType.getInteger(context, "count"),
-                                                        items,
-                                                        callback
-                                                    )
-                                                )
-                                            )
-                                    )
-                            )
-                    )
-            )
-            .then(
-                Commands.literal("insert")
-                    .then(
-                        tailProvider.construct(
-                            Commands.argument("targetPos", BlockPosArgument.blockPos()),
-                            (context, items, callback) -> blockDistribute(
-                                context.getSource(), BlockPosArgument.getLoadedBlockPos(context, "targetPos"), items, callback
-                            )
-                        )
-                    )
-            )
-            .then(
-                Commands.literal("give")
-                    .then(
-                        tailProvider.construct(
-                            Commands.argument("players", EntityArgument.players()),
-                            (context, items, callback) -> playerGive(EntityArgument.getPlayers(context, "players"), items, callback)
-                        )
-                    )
-            )
-            .then(
-                Commands.literal("spawn")
-                    .then(
-                        tailProvider.construct(
-                            Commands.argument("targetPos", Vec3Argument.vec3()),
-                            (context, items, callback) -> dropInWorld(context.getSource(), Vec3Argument.getVec3(context, "targetPos"), items, callback)
-                        )
-                    )
-            );
-    }
-
-    private static Container getContainer(CommandSourceStack source, BlockPos pos) throws CommandSyntaxException {
-        BlockEntity blockEntity = source.getLevel().getBlockEntity(pos);
-        if (!(blockEntity instanceof Container)) {
-            throw ItemCommands.ERROR_TARGET_NOT_A_CONTAINER.create(pos.getX(), pos.getY(), pos.getZ());
-        } else {
-            return (Container)blockEntity;
-        }
-    }
-
-    private static int blockDistribute(CommandSourceStack source, BlockPos pos, List<ItemStack> items, LootCommand.Callback callback) throws CommandSyntaxException {
-        Container container = getContainer(source, pos);
-        List<ItemStack> list = Lists.newArrayListWithCapacity(items.size());
-
-        for (ItemStack itemStack : items) {
-            if (distributeToContainer(container, itemStack.copy())) {
-                container.setChanged();
-                list.add(itemStack);
-            }
-        }
-
-        callback.accept(list);
-        return list.size();
-    }
-
-    private static boolean distributeToContainer(Container container, ItemStack item) {
-        boolean flag = false;
-
-        for (int i = 0; i < container.getContainerSize() && !item.isEmpty(); i++) {
-            ItemStack item1 = container.getItem(i);
-            if (container.canPlaceItem(i, item)) {
-                if (item1.isEmpty()) {
-                    container.setItem(i, item);
-                    flag = true;
-                    break;
-                }
-
-                if (canMergeItems(item1, item)) {
-                    int i1 = item.getMaxStackSize() - item1.getCount();
-                    int min = Math.min(item.getCount(), i1);
-                    item.shrink(min);
-                    item1.grow(min);
-                    flag = true;
-                }
-            }
-        }
-
-        return flag;
-    }
-
-    private static int blockReplace(CommandSourceStack source, BlockPos pos, int slot, int numSlots, List<ItemStack> items, LootCommand.Callback callback) throws CommandSyntaxException {
-        Container container = getContainer(source, pos);
-        int containerSize = container.getContainerSize();
-        if (slot >= 0 && slot < containerSize) {
-            List<ItemStack> list = Lists.newArrayListWithCapacity(items.size());
-
-            for (int i = 0; i < numSlots; i++) {
-                int i1 = slot + i;
-                ItemStack itemStack = i < items.size() ? items.get(i) : ItemStack.EMPTY;
-                if (container.canPlaceItem(i1, itemStack)) {
-                    container.setItem(i1, itemStack);
-                    list.add(itemStack);
-                }
-            }
-
-            callback.accept(list);
-            return list.size();
-        } else {
-            throw ItemCommands.ERROR_TARGET_INAPPLICABLE_SLOT.create(slot);
-        }
-    }
-
-    private static boolean canMergeItems(ItemStack first, ItemStack second) {
-        return first.getCount() <= first.getMaxStackSize() && ItemStack.isSameItemSameComponents(first, second);
-    }
-
-    private static int playerGive(Collection<ServerPlayer> targets, List<ItemStack> items, LootCommand.Callback callback) throws CommandSyntaxException {
-        List<ItemStack> list = Lists.newArrayListWithCapacity(items.size());
-
-        for (ItemStack itemStack : items) {
-            for (ServerPlayer serverPlayer : targets) {
-                if (serverPlayer.getInventory().add(itemStack.copy())) {
-                    list.add(itemStack);
-                }
-            }
-        }
-
-        callback.accept(list);
-        return list.size();
-    }
-
-    private static void setSlots(Entity target, List<ItemStack> items, int startSlot, int numSlots, List<ItemStack> setItems) {
-        for (int i = 0; i < numSlots; i++) {
-            ItemStack itemStack = i < items.size() ? items.get(i) : ItemStack.EMPTY;
-            SlotAccess slot = target.getSlot(startSlot + i);
-            if (slot != SlotAccess.NULL && slot.set(itemStack.copy())) {
-                setItems.add(itemStack);
-            }
-        }
-    }
-
-    private static int entityReplace(Collection<? extends Entity> targets, int startSlot, int numSlots, List<ItemStack> items, LootCommand.Callback callback) throws CommandSyntaxException {
-        List<ItemStack> list = Lists.newArrayListWithCapacity(items.size());
-
-        for (Entity entity : targets) {
-            if (entity instanceof ServerPlayer serverPlayer) {
-                setSlots(entity, items, startSlot, numSlots, list);
-                serverPlayer.containerMenu.broadcastChanges();
-            } else {
-                setSlots(entity, items, startSlot, numSlots, list);
-            }
-        }
-
-        callback.accept(list);
-        return list.size();
-    }
-
-    private static int dropInWorld(CommandSourceStack source, Vec3 pos, List<ItemStack> items, LootCommand.Callback callback) throws CommandSyntaxException {
-        ServerLevel level = source.getLevel();
-        items.forEach(itemStack -> {
-            ItemEntity itemEntity = new ItemEntity(level, pos.x, pos.y, pos.z, itemStack.copy());
-            itemEntity.setDefaultPickUpDelay();
-            level.addFreshEntity(itemEntity);
-        });
-        callback.accept(items);
-        return items.size();
-    }
-
-    private static void callback(CommandSourceStack source, List<ItemStack> items) {
-        if (items.size() == 1) {
-            ItemStack itemStack = items.get(0);
-            source.sendSuccess(() -> Component.translatable("commands.drop.success.single", itemStack.getCount(), itemStack.getDisplayName()), false);
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.drop.success.multiple", items.size()), false);
-        }
-    }
-
-    private static void callback(CommandSourceStack source, List<ItemStack> items, ResourceKey<LootTable> lootTable) {
-        if (items.size() == 1) {
-            ItemStack itemStack = items.get(0);
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.drop.success.single_with_table", itemStack.getCount(), itemStack.getDisplayName(), Component.translationArg(lootTable.location())
-                ),
-                false
-            );
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable("commands.drop.success.multiple_with_table", items.size(), Component.translationArg(lootTable.location())), false
-            );
-        }
-    }
-
-    private static ItemStack getSourceHandItem(CommandSourceStack source, EquipmentSlot slot) throws CommandSyntaxException {
-        Entity entityOrException = source.getEntityOrException();
-        if (entityOrException instanceof LivingEntity) {
-            return ((LivingEntity)entityOrException).getItemBySlot(slot);
-        } else {
-            throw ERROR_NO_HELD_ITEMS.create(entityOrException.getDisplayName());
-        }
-    }
-
-    private static int dropBlockLoot(CommandContext<CommandSourceStack> context, BlockPos pos, ItemStack tool, LootCommand.DropConsumer dropConsumer) throws CommandSyntaxException {
-        CommandSourceStack commandSourceStack = context.getSource();
-        ServerLevel level = commandSourceStack.getLevel();
-        BlockState blockState = level.getBlockState(pos);
-        BlockEntity blockEntity = level.getBlockEntity(pos);
-        Optional<ResourceKey<LootTable>> lootTable = blockState.getBlock().getLootTable();
-        if (lootTable.isEmpty()) {
-            throw ERROR_NO_BLOCK_LOOT_TABLE.create(blockState.getBlock().getName());
-        } else {
-            LootParams.Builder builder = new LootParams.Builder(level)
-                .withParameter(LootContextParams.ORIGIN, Vec3.atCenterOf(pos))
-                .withParameter(LootContextParams.BLOCK_STATE, blockState)
-                .withOptionalParameter(LootContextParams.BLOCK_ENTITY, blockEntity)
-                .withOptionalParameter(LootContextParams.THIS_ENTITY, commandSourceStack.getEntity())
-                .withParameter(LootContextParams.TOOL, tool);
-            List<ItemStack> drops = blockState.getDrops(builder);
-            return dropConsumer.accept(context, drops, items -> callback(commandSourceStack, items, lootTable.get()));
-        }
-    }
-
-    private static int dropKillLoot(CommandContext<CommandSourceStack> context, Entity entity, LootCommand.DropConsumer dropConsumer) throws CommandSyntaxException {
-        Optional<ResourceKey<LootTable>> lootTable = entity.getLootTable();
-        if (lootTable.isEmpty()) {
-            throw ERROR_NO_ENTITY_LOOT_TABLE.create(entity.getDisplayName());
-        } else {
-            CommandSourceStack commandSourceStack = context.getSource();
-            LootParams.Builder builder = new LootParams.Builder(commandSourceStack.getLevel());
-            Entity entity1 = commandSourceStack.getEntity();
-            if (entity1 instanceof Player player) {
-                builder.withParameter(LootContextParams.LAST_DAMAGE_PLAYER, player);
-            }
-
-            builder.withParameter(LootContextParams.DAMAGE_SOURCE, entity.damageSources().magic());
-            builder.withOptionalParameter(LootContextParams.DIRECT_ATTACKING_ENTITY, entity1);
-            builder.withOptionalParameter(LootContextParams.ATTACKING_ENTITY, entity1);
-            builder.withParameter(LootContextParams.THIS_ENTITY, entity);
-            builder.withParameter(LootContextParams.ORIGIN, commandSourceStack.getPosition());
-            LootParams lootParams = builder.create(LootContextParamSets.ENTITY);
-            LootTable lootTable1 = commandSourceStack.getServer().reloadableRegistries().getLootTable(lootTable.get());
-            List<ItemStack> randomItems = lootTable1.getRandomItems(lootParams);
-            return dropConsumer.accept(context, randomItems, items -> callback(commandSourceStack, items, lootTable.get()));
-        }
-    }
-
-    private static int dropChestLoot(CommandContext<CommandSourceStack> context, Holder<LootTable> lootTable, LootCommand.DropConsumer dropCOnsimer) throws CommandSyntaxException {
-        CommandSourceStack commandSourceStack = context.getSource();
-        LootParams lootParams = new LootParams.Builder(commandSourceStack.getLevel())
-            .withOptionalParameter(LootContextParams.THIS_ENTITY, commandSourceStack.getEntity())
-            .withParameter(LootContextParams.ORIGIN, commandSourceStack.getPosition())
-            .create(LootContextParamSets.CHEST);
-        return drop(context, lootTable, lootParams, dropCOnsimer);
-    }
-
-    private static int dropFishingLoot(
-        CommandContext<CommandSourceStack> context, Holder<LootTable> lootTable, BlockPos pos, ItemStack tool, LootCommand.DropConsumer dropConsumet
-    ) throws CommandSyntaxException {
-        CommandSourceStack commandSourceStack = context.getSource();
-        LootParams lootParams = new LootParams.Builder(commandSourceStack.getLevel())
-            .withParameter(LootContextParams.ORIGIN, Vec3.atCenterOf(pos))
-            .withParameter(LootContextParams.TOOL, tool)
-            .withOptionalParameter(LootContextParams.THIS_ENTITY, commandSourceStack.getEntity())
-            .create(LootContextParamSets.FISHING);
-        return drop(context, lootTable, lootParams, dropConsumet);
-    }
-
-    private static int drop(CommandContext<CommandSourceStack> context, Holder<LootTable> lootTable, LootParams params, LootCommand.DropConsumer dropConsumer) throws CommandSyntaxException {
-        CommandSourceStack commandSourceStack = context.getSource();
-        List<ItemStack> randomItems = lootTable.value().getRandomItems(params);
-        return dropConsumer.accept(context, randomItems, items -> callback(commandSourceStack, items));
-    }
-
-    @FunctionalInterface
-    interface Callback {
-        void accept(List<ItemStack> items) throws CommandSyntaxException;
-    }
-
-    @FunctionalInterface
-    interface DropConsumer {
-        int accept(CommandContext<CommandSourceStack> context, List<ItemStack> items, LootCommand.Callback callback) throws CommandSyntaxException;
-    }
-
-    @FunctionalInterface
-    interface TailProvider {
-        ArgumentBuilder<CommandSourceStack, ?> construct(ArgumentBuilder<CommandSourceStack, ?> builder, LootCommand.DropConsumer dropConsumer);
-    }
-}
diff --git a/net/minecraft/server/commands/MsgCommand.java b/net/minecraft/server/commands/MsgCommand.java
deleted file mode 100644
index 8ab8cb524cbeeb0c895eacda378819d7a863fb91..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/MsgCommand.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.tree.LiteralCommandNode;
-import java.util.Collection;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.commands.arguments.MessageArgument;
-import net.minecraft.network.chat.ChatType;
-import net.minecraft.network.chat.OutgoingChatMessage;
-import net.minecraft.network.chat.PlayerChatMessage;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.server.players.PlayerList;
-
-public class MsgCommand {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        LiteralCommandNode<CommandSourceStack> literalCommandNode = dispatcher.register(
-            Commands.literal("msg")
-                .then(Commands.argument("targets", EntityArgument.players()).then(Commands.argument("message", MessageArgument.message()).executes(context -> {
-                    Collection<ServerPlayer> players = EntityArgument.getPlayers(context, "targets");
-                    if (!players.isEmpty()) {
-                        MessageArgument.resolveChatMessage(context, "message", message -> sendMessage(context.getSource(), players, message));
-                    }
-
-                    return players.size();
-                })))
-        );
-        dispatcher.register(Commands.literal("tell").redirect(literalCommandNode));
-        dispatcher.register(Commands.literal("w").redirect(literalCommandNode));
-    }
-
-    private static void sendMessage(CommandSourceStack source, Collection<ServerPlayer> targets, PlayerChatMessage message) {
-        ChatType.Bound bound = ChatType.bind(ChatType.MSG_COMMAND_INCOMING, source);
-        OutgoingChatMessage outgoingChatMessage = OutgoingChatMessage.create(message);
-        boolean flag = false;
-
-        for (ServerPlayer serverPlayer : targets) {
-            ChatType.Bound bound1 = ChatType.bind(ChatType.MSG_COMMAND_OUTGOING, source).withTargetName(serverPlayer.getDisplayName());
-            source.sendChatMessage(outgoingChatMessage, false, bound1);
-            boolean shouldFilterMessageTo = source.shouldFilterMessageTo(serverPlayer);
-            serverPlayer.sendChatMessage(outgoingChatMessage, shouldFilterMessageTo, bound);
-            flag |= shouldFilterMessageTo && message.isFullyFiltered();
-        }
-
-        if (flag) {
-            source.sendSystemMessage(PlayerList.CHAT_FILTERED_FULL);
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/OpCommand.java b/net/minecraft/server/commands/OpCommand.java
deleted file mode 100644
index 5c0a04db38821dbb0cba2bb6f0787f113d167efd..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/OpCommand.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.authlib.GameProfile;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import java.util.Collection;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.SharedSuggestionProvider;
-import net.minecraft.commands.arguments.GameProfileArgument;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.players.PlayerList;
-
-public class OpCommand {
-    private static final SimpleCommandExceptionType ERROR_ALREADY_OP = new SimpleCommandExceptionType(Component.translatable("commands.op.failed"));
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("op")
-                .requires(source -> source.hasPermission(3))
-                .then(
-                    Commands.argument("targets", GameProfileArgument.gameProfile())
-                        .suggests(
-                            (context, builder) -> {
-                                PlayerList playerList = context.getSource().getServer().getPlayerList();
-                                return SharedSuggestionProvider.suggest(
-                                    playerList.getPlayers()
-                                        .stream()
-                                        .filter(player -> !playerList.isOp(player.getGameProfile()))
-                                        .map(player -> player.getGameProfile().getName()),
-                                    builder
-                                );
-                            }
-                        )
-                        .executes(context -> opPlayers(context.getSource(), GameProfileArgument.getGameProfiles(context, "targets")))
-                )
-        );
-    }
-
-    private static int opPlayers(CommandSourceStack source, Collection<GameProfile> gameProfiles) throws CommandSyntaxException {
-        PlayerList playerList = source.getServer().getPlayerList();
-        int i = 0;
-
-        for (GameProfile gameProfile : gameProfiles) {
-            if (!playerList.isOp(gameProfile)) {
-                playerList.op(gameProfile);
-                i++;
-                source.sendSuccess(() -> Component.translatable("commands.op.success", gameProfile.getName()), true); // Paper - fixes MC-253721
-            }
-        }
-
-        if (i == 0) {
-            throw ERROR_ALREADY_OP.create();
-        } else {
-            return i;
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/PardonCommand.java b/net/minecraft/server/commands/PardonCommand.java
deleted file mode 100644
index b9f8c714b443fd34edc89c923f602497625adc98..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/PardonCommand.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.authlib.GameProfile;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import java.util.Collection;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.SharedSuggestionProvider;
-import net.minecraft.commands.arguments.GameProfileArgument;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.players.UserBanList;
-
-public class PardonCommand {
-    private static final SimpleCommandExceptionType ERROR_NOT_BANNED = new SimpleCommandExceptionType(Component.translatable("commands.pardon.failed"));
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("pardon")
-                .requires(source -> source.hasPermission(3))
-                .then(
-                    Commands.argument("targets", GameProfileArgument.gameProfile())
-                        .suggests(
-                            (context, builder) -> SharedSuggestionProvider.suggest(
-                                context.getSource().getServer().getPlayerList().getBans().getUserList(), builder
-                            )
-                        )
-                        .executes(context -> pardonPlayers(context.getSource(), GameProfileArgument.getGameProfiles(context, "targets")))
-                )
-        );
-    }
-
-    private static int pardonPlayers(CommandSourceStack source, Collection<GameProfile> gameProfiles) throws CommandSyntaxException {
-        UserBanList bans = source.getServer().getPlayerList().getBans();
-        int i = 0;
-
-        for (GameProfile gameProfile : gameProfiles) {
-            if (bans.isBanned(gameProfile)) {
-                bans.remove(gameProfile);
-                i++;
-                source.sendSuccess(() -> Component.translatable("commands.pardon.success", Component.literal(gameProfile.getName())), true);
-            }
-        }
-
-        if (i == 0) {
-            throw ERROR_NOT_BANNED.create();
-        } else {
-            return i;
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/PardonIpCommand.java b/net/minecraft/server/commands/PardonIpCommand.java
deleted file mode 100644
index 944fa002c82d8f7dc86a2957fdc164b45796520d..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/PardonIpCommand.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.google.common.net.InetAddresses;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.StringArgumentType;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.SharedSuggestionProvider;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.players.IpBanList;
-
-public class PardonIpCommand {
-    private static final SimpleCommandExceptionType ERROR_INVALID = new SimpleCommandExceptionType(Component.translatable("commands.pardonip.invalid"));
-    private static final SimpleCommandExceptionType ERROR_NOT_BANNED = new SimpleCommandExceptionType(Component.translatable("commands.pardonip.failed"));
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("pardon-ip")
-                .requires(source -> source.hasPermission(3))
-                .then(
-                    Commands.argument("target", StringArgumentType.word())
-                        .suggests(
-                            (context, builder) -> SharedSuggestionProvider.suggest(
-                                context.getSource().getServer().getPlayerList().getIpBans().getUserList(), builder
-                            )
-                        )
-                        .executes(context -> unban(context.getSource(), StringArgumentType.getString(context, "target")))
-                )
-        );
-    }
-
-    private static int unban(CommandSourceStack source, String ipAddress) throws CommandSyntaxException {
-        if (!InetAddresses.isInetAddress(ipAddress)) {
-            throw ERROR_INVALID.create();
-        } else {
-            IpBanList ipBans = source.getServer().getPlayerList().getIpBans();
-            if (!ipBans.isBanned(ipAddress)) {
-                throw ERROR_NOT_BANNED.create();
-            } else {
-                ipBans.remove(ipAddress);
-                source.sendSuccess(() -> Component.translatable("commands.pardonip.success", ipAddress), true);
-                return 1;
-            }
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/PerfCommand.java b/net/minecraft/server/commands/PerfCommand.java
deleted file mode 100644
index a3192400b37274620977e5a40d4283bfec3ab9b3..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/PerfCommand.java
+++ /dev/null
@@ -1,107 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import com.mojang.logging.LogUtils;
-import java.io.IOException;
-import java.nio.file.Path;
-import java.nio.file.Paths;
-import java.util.Locale;
-import java.util.function.Consumer;
-import net.minecraft.FileUtil;
-import net.minecraft.SharedConstants;
-import net.minecraft.SystemReport;
-import net.minecraft.Util;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.util.FileZipper;
-import net.minecraft.util.TimeUtil;
-import net.minecraft.util.profiling.EmptyProfileResults;
-import net.minecraft.util.profiling.ProfileResults;
-import net.minecraft.util.profiling.metrics.storage.MetricsPersister;
-import org.apache.commons.io.FileUtils;
-import org.slf4j.Logger;
-
-public class PerfCommand {
-    private static final Logger LOGGER = LogUtils.getLogger();
-    private static final SimpleCommandExceptionType ERROR_NOT_RUNNING = new SimpleCommandExceptionType(Component.translatable("commands.perf.notRunning"));
-    private static final SimpleCommandExceptionType ERROR_ALREADY_RUNNING = new SimpleCommandExceptionType(
-        Component.translatable("commands.perf.alreadyRunning")
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("perf")
-                .requires(source -> source.hasPermission(4))
-                .then(Commands.literal("start").executes(context -> startProfilingDedicatedServer(context.getSource())))
-                .then(Commands.literal("stop").executes(context -> stopProfilingDedicatedServer(context.getSource())))
-        );
-    }
-
-    private static int startProfilingDedicatedServer(CommandSourceStack source) throws CommandSyntaxException {
-        MinecraftServer server = source.getServer();
-        if (server.isRecordingMetrics()) {
-            throw ERROR_ALREADY_RUNNING.create();
-        } else {
-            Consumer<ProfileResults> consumer = results -> whenStopped(source, results);
-            Consumer<Path> consumer1 = dumpPath -> saveResults(source, dumpPath, server);
-            server.startRecordingMetrics(consumer, consumer1);
-            source.sendSuccess(() -> Component.translatable("commands.perf.started"), false);
-            return 0;
-        }
-    }
-
-    private static int stopProfilingDedicatedServer(CommandSourceStack source) throws CommandSyntaxException {
-        MinecraftServer server = source.getServer();
-        if (!server.isRecordingMetrics()) {
-            throw ERROR_NOT_RUNNING.create();
-        } else {
-            server.finishRecordingMetrics();
-            return 0;
-        }
-    }
-
-    private static void saveResults(CommandSourceStack source, Path path, MinecraftServer server) {
-        String string = String.format(
-            Locale.ROOT, "%s-%s-%s", Util.getFilenameFormattedDateTime(), server.getWorldData().getLevelName(), SharedConstants.getCurrentVersion().getId()
-        );
-
-        String string1;
-        try {
-            string1 = FileUtil.findAvailableName(MetricsPersister.PROFILING_RESULTS_DIR, string, ".zip");
-        } catch (IOException var11) {
-            source.sendFailure(Component.translatable("commands.perf.reportFailed"));
-            LOGGER.error("Failed to create report name", (Throwable)var11);
-            return;
-        }
-
-        try (FileZipper fileZipper = new FileZipper(MetricsPersister.PROFILING_RESULTS_DIR.resolve(string1))) {
-            fileZipper.add(Paths.get("system.txt"), server.fillSystemReport(new SystemReport()).toLineSeparatedString());
-            fileZipper.add(path);
-        }
-
-        try {
-            FileUtils.forceDelete(path.toFile());
-        } catch (IOException var9) {
-            LOGGER.warn("Failed to delete temporary profiling file {}", path, var9);
-        }
-
-        source.sendSuccess(() -> Component.translatable("commands.perf.reportSaved", string1), false);
-    }
-
-    private static void whenStopped(CommandSourceStack source, ProfileResults results) {
-        if (results != EmptyProfileResults.EMPTY) {
-            int tickDuration = results.getTickDuration();
-            double d = (double)results.getNanoDuration() / TimeUtil.NANOSECONDS_PER_SECOND;
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.perf.stopped", String.format(Locale.ROOT, "%.2f", d), tickDuration, String.format(Locale.ROOT, "%.2f", tickDuration / d)
-                ),
-                false
-            );
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/PlaceCommand.java b/net/minecraft/server/commands/PlaceCommand.java
deleted file mode 100644
index f019285714cf6e7ac08d6b3b96fe705b8a564c28..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/PlaceCommand.java
+++ /dev/null
@@ -1,353 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.FloatArgumentType;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import com.mojang.brigadier.suggestion.SuggestionProvider;
-import java.util.Optional;
-import net.minecraft.ResourceLocationException;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.SharedSuggestionProvider;
-import net.minecraft.commands.arguments.ResourceKeyArgument;
-import net.minecraft.commands.arguments.ResourceLocationArgument;
-import net.minecraft.commands.arguments.TemplateMirrorArgument;
-import net.minecraft.commands.arguments.TemplateRotationArgument;
-import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Holder;
-import net.minecraft.core.SectionPos;
-import net.minecraft.core.registries.Registries;
-import net.minecraft.network.chat.Component;
-import net.minecraft.resources.ResourceLocation;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.world.level.ChunkPos;
-import net.minecraft.world.level.block.Mirror;
-import net.minecraft.world.level.block.Rotation;
-import net.minecraft.world.level.block.entity.StructureBlockEntity;
-import net.minecraft.world.level.chunk.ChunkGenerator;
-import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
-import net.minecraft.world.level.levelgen.structure.BoundingBox;
-import net.minecraft.world.level.levelgen.structure.Structure;
-import net.minecraft.world.level.levelgen.structure.StructureStart;
-import net.minecraft.world.level.levelgen.structure.pools.JigsawPlacement;
-import net.minecraft.world.level.levelgen.structure.pools.StructureTemplatePool;
-import net.minecraft.world.level.levelgen.structure.templatesystem.BlockRotProcessor;
-import net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings;
-import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate;
-import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
-
-public class PlaceCommand {
-    private static final SimpleCommandExceptionType ERROR_FEATURE_FAILED = new SimpleCommandExceptionType(
-        Component.translatable("commands.place.feature.failed")
-    );
-    private static final SimpleCommandExceptionType ERROR_JIGSAW_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.place.jigsaw.failed"));
-    private static final SimpleCommandExceptionType ERROR_STRUCTURE_FAILED = new SimpleCommandExceptionType(
-        Component.translatable("commands.place.structure.failed")
-    );
-    private static final DynamicCommandExceptionType ERROR_TEMPLATE_INVALID = new DynamicCommandExceptionType(
-        template -> Component.translatableEscape("commands.place.template.invalid", template)
-    );
-    private static final SimpleCommandExceptionType ERROR_TEMPLATE_FAILED = new SimpleCommandExceptionType(
-        Component.translatable("commands.place.template.failed")
-    );
-    private static final SuggestionProvider<CommandSourceStack> SUGGEST_TEMPLATES = (context, builder) -> {
-        StructureTemplateManager structureManager = context.getSource().getLevel().getStructureManager();
-        return SharedSuggestionProvider.suggestResource(structureManager.listTemplates(), builder);
-    };
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("place")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.literal("feature")
-                        .then(
-                            Commands.argument("feature", ResourceKeyArgument.key(Registries.CONFIGURED_FEATURE))
-                                .executes(
-                                    context -> placeFeature(
-                                        context.getSource(),
-                                        ResourceKeyArgument.getConfiguredFeature(context, "feature"),
-                                        BlockPos.containing(context.getSource().getPosition())
-                                    )
-                                )
-                                .then(
-                                    Commands.argument("pos", BlockPosArgument.blockPos())
-                                        .executes(
-                                            context -> placeFeature(
-                                                context.getSource(),
-                                                ResourceKeyArgument.getConfiguredFeature(context, "feature"),
-                                                BlockPosArgument.getLoadedBlockPos(context, "pos")
-                                            )
-                                        )
-                                )
-                        )
-                )
-                .then(
-                    Commands.literal("jigsaw")
-                        .then(
-                            Commands.argument("pool", ResourceKeyArgument.key(Registries.TEMPLATE_POOL))
-                                .then(
-                                    Commands.argument("target", ResourceLocationArgument.id())
-                                        .then(
-                                            Commands.argument("max_depth", IntegerArgumentType.integer(1, 20))
-                                                .executes(
-                                                    context -> placeJigsaw(
-                                                        context.getSource(),
-                                                        ResourceKeyArgument.getStructureTemplatePool(context, "pool"),
-                                                        ResourceLocationArgument.getId(context, "target"),
-                                                        IntegerArgumentType.getInteger(context, "max_depth"),
-                                                        BlockPos.containing(context.getSource().getPosition())
-                                                    )
-                                                )
-                                                .then(
-                                                    Commands.argument("position", BlockPosArgument.blockPos())
-                                                        .executes(
-                                                            context -> placeJigsaw(
-                                                                context.getSource(),
-                                                                ResourceKeyArgument.getStructureTemplatePool(context, "pool"),
-                                                                ResourceLocationArgument.getId(context, "target"),
-                                                                IntegerArgumentType.getInteger(context, "max_depth"),
-                                                                BlockPosArgument.getLoadedBlockPos(context, "position")
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                )
-                .then(
-                    Commands.literal("structure")
-                        .then(
-                            Commands.argument("structure", ResourceKeyArgument.key(Registries.STRUCTURE))
-                                .executes(
-                                    context -> placeStructure(
-                                        context.getSource(),
-                                        ResourceKeyArgument.getStructure(context, "structure"),
-                                        BlockPos.containing(context.getSource().getPosition())
-                                    )
-                                )
-                                .then(
-                                    Commands.argument("pos", BlockPosArgument.blockPos())
-                                        .executes(
-                                            context -> placeStructure(
-                                                context.getSource(),
-                                                ResourceKeyArgument.getStructure(context, "structure"),
-                                                BlockPosArgument.getLoadedBlockPos(context, "pos")
-                                            )
-                                        )
-                                )
-                        )
-                )
-                .then(
-                    Commands.literal("template")
-                        .then(
-                            Commands.argument("template", ResourceLocationArgument.id())
-                                .suggests(SUGGEST_TEMPLATES)
-                                .executes(
-                                    context -> placeTemplate(
-                                        context.getSource(),
-                                        ResourceLocationArgument.getId(context, "template"),
-                                        BlockPos.containing(context.getSource().getPosition()),
-                                        Rotation.NONE,
-                                        Mirror.NONE,
-                                        1.0F,
-                                        0
-                                    )
-                                )
-                                .then(
-                                    Commands.argument("pos", BlockPosArgument.blockPos())
-                                        .executes(
-                                            context -> placeTemplate(
-                                                context.getSource(),
-                                                ResourceLocationArgument.getId(context, "template"),
-                                                BlockPosArgument.getLoadedBlockPos(context, "pos"),
-                                                Rotation.NONE,
-                                                Mirror.NONE,
-                                                1.0F,
-                                                0
-                                            )
-                                        )
-                                        .then(
-                                            Commands.argument("rotation", TemplateRotationArgument.templateRotation())
-                                                .executes(
-                                                    context -> placeTemplate(
-                                                        context.getSource(),
-                                                        ResourceLocationArgument.getId(context, "template"),
-                                                        BlockPosArgument.getLoadedBlockPos(context, "pos"),
-                                                        TemplateRotationArgument.getRotation(context, "rotation"),
-                                                        Mirror.NONE,
-                                                        1.0F,
-                                                        0
-                                                    )
-                                                )
-                                                .then(
-                                                    Commands.argument("mirror", TemplateMirrorArgument.templateMirror())
-                                                        .executes(
-                                                            context -> placeTemplate(
-                                                                context.getSource(),
-                                                                ResourceLocationArgument.getId(context, "template"),
-                                                                BlockPosArgument.getLoadedBlockPos(context, "pos"),
-                                                                TemplateRotationArgument.getRotation(context, "rotation"),
-                                                                TemplateMirrorArgument.getMirror(context, "mirror"),
-                                                                1.0F,
-                                                                0
-                                                            )
-                                                        )
-                                                        .then(
-                                                            Commands.argument("integrity", FloatArgumentType.floatArg(0.0F, 1.0F))
-                                                                .executes(
-                                                                    context -> placeTemplate(
-                                                                        context.getSource(),
-                                                                        ResourceLocationArgument.getId(context, "template"),
-                                                                        BlockPosArgument.getLoadedBlockPos(context, "pos"),
-                                                                        TemplateRotationArgument.getRotation(context, "rotation"),
-                                                                        TemplateMirrorArgument.getMirror(context, "mirror"),
-                                                                        FloatArgumentType.getFloat(context, "integrity"),
-                                                                        0
-                                                                    )
-                                                                )
-                                                                .then(
-                                                                    Commands.argument("seed", IntegerArgumentType.integer())
-                                                                        .executes(
-                                                                            context -> placeTemplate(
-                                                                                context.getSource(),
-                                                                                ResourceLocationArgument.getId(context, "template"),
-                                                                                BlockPosArgument.getLoadedBlockPos(context, "pos"),
-                                                                                TemplateRotationArgument.getRotation(context, "rotation"),
-                                                                                TemplateMirrorArgument.getMirror(context, "mirror"),
-                                                                                FloatArgumentType.getFloat(context, "integrity"),
-                                                                                IntegerArgumentType.getInteger(context, "seed")
-                                                                            )
-                                                                        )
-                                                                )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    public static int placeFeature(CommandSourceStack source, Holder.Reference<ConfiguredFeature<?, ?>> feature, BlockPos pos) throws CommandSyntaxException {
-        ServerLevel level = source.getLevel();
-        ConfiguredFeature<?, ?> configuredFeature = feature.value();
-        ChunkPos chunkPos = new ChunkPos(pos);
-        checkLoaded(level, new ChunkPos(chunkPos.x - 1, chunkPos.z - 1), new ChunkPos(chunkPos.x + 1, chunkPos.z + 1));
-        if (!configuredFeature.place(level, level.getChunkSource().getGenerator(), level.getRandom(), pos)) {
-            throw ERROR_FEATURE_FAILED.create();
-        } else {
-            String string = feature.key().location().toString();
-            source.sendSuccess(() -> Component.translatable("commands.place.feature.success", string, pos.getX(), pos.getY(), pos.getZ()), true);
-            return 1;
-        }
-    }
-
-    public static int placeJigsaw(CommandSourceStack source, Holder<StructureTemplatePool> templatePool, ResourceLocation target, int maxDepth, BlockPos pos) throws CommandSyntaxException {
-        ServerLevel level = source.getLevel();
-        ChunkPos chunkPos = new ChunkPos(pos);
-        checkLoaded(level, chunkPos, chunkPos);
-        if (!JigsawPlacement.generateJigsaw(level, templatePool, target, maxDepth, pos, false)) {
-            throw ERROR_JIGSAW_FAILED.create();
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.place.jigsaw.success", pos.getX(), pos.getY(), pos.getZ()), true);
-            return 1;
-        }
-    }
-
-    public static int placeStructure(CommandSourceStack source, Holder.Reference<Structure> structure, BlockPos pos) throws CommandSyntaxException {
-        ServerLevel level = source.getLevel();
-        Structure structure1 = structure.value();
-        ChunkGenerator generator = level.getChunkSource().getGenerator();
-        StructureStart structureStart = structure1.generate(
-            structure,
-            level.dimension(),
-            source.registryAccess(),
-            generator,
-            generator.getBiomeSource(),
-            level.getChunkSource().randomState(),
-            level.getStructureManager(),
-            level.getSeed(),
-            new ChunkPos(pos),
-            0,
-            level,
-            biome -> true
-        );
-        if (!structureStart.isValid()) {
-            throw ERROR_STRUCTURE_FAILED.create();
-        } else {
-            structureStart.generationEventCause = org.bukkit.event.world.AsyncStructureGenerateEvent.Cause.COMMAND; // CraftBukkit - set AsyncStructureGenerateEvent.Cause.COMMAND as generation cause
-            BoundingBox boundingBox = structureStart.getBoundingBox();
-            ChunkPos chunkPos = new ChunkPos(SectionPos.blockToSectionCoord(boundingBox.minX()), SectionPos.blockToSectionCoord(boundingBox.minZ()));
-            ChunkPos chunkPos1 = new ChunkPos(SectionPos.blockToSectionCoord(boundingBox.maxX()), SectionPos.blockToSectionCoord(boundingBox.maxZ()));
-            checkLoaded(level, chunkPos, chunkPos1);
-            ChunkPos.rangeClosed(chunkPos, chunkPos1)
-                .forEach(
-                    chunkPos2 -> structureStart.placeInChunk(
-                        level,
-                        level.structureManager(),
-                        generator,
-                        level.getRandom(),
-                        new BoundingBox(
-                            chunkPos2.getMinBlockX(),
-                            level.getMinY(),
-                            chunkPos2.getMinBlockZ(),
-                            chunkPos2.getMaxBlockX(),
-                            level.getMaxY() + 1,
-                            chunkPos2.getMaxBlockZ()
-                        ),
-                        chunkPos2
-                    )
-                );
-            String string = structure.key().location().toString();
-            source.sendSuccess(() -> Component.translatable("commands.place.structure.success", string, pos.getX(), pos.getY(), pos.getZ()), true);
-            return 1;
-        }
-    }
-
-    public static int placeTemplate(
-        CommandSourceStack source, ResourceLocation template, BlockPos pos, Rotation rotation, Mirror mirror, float integrity, int seed
-    ) throws CommandSyntaxException {
-        ServerLevel level = source.getLevel();
-        StructureTemplateManager structureManager = level.getStructureManager();
-
-        Optional<StructureTemplate> optional;
-        try {
-            optional = structureManager.get(template);
-        } catch (ResourceLocationException var13) {
-            throw ERROR_TEMPLATE_INVALID.create(template);
-        }
-
-        if (optional.isEmpty()) {
-            throw ERROR_TEMPLATE_INVALID.create(template);
-        } else {
-            StructureTemplate structureTemplate = optional.get();
-            checkLoaded(level, new ChunkPos(pos), new ChunkPos(pos.offset(structureTemplate.getSize())));
-            StructurePlaceSettings structurePlaceSettings = new StructurePlaceSettings().setMirror(mirror).setRotation(rotation);
-            if (integrity < 1.0F) {
-                structurePlaceSettings.clearProcessors().addProcessor(new BlockRotProcessor(integrity)).setRandom(StructureBlockEntity.createRandom(seed));
-            }
-
-            boolean flag = structureTemplate.placeInWorld(level, pos, pos, structurePlaceSettings, StructureBlockEntity.createRandom(seed), 2);
-            if (!flag) {
-                throw ERROR_TEMPLATE_FAILED.create();
-            } else {
-                source.sendSuccess(
-                    () -> Component.translatable("commands.place.template.success", Component.translationArg(template), pos.getX(), pos.getY(), pos.getZ()),
-                    true
-                );
-                return 1;
-            }
-        }
-    }
-
-    private static void checkLoaded(ServerLevel level, ChunkPos start, ChunkPos end) throws CommandSyntaxException {
-        if (ChunkPos.rangeClosed(start, end).filter(chunkPos -> !level.isLoaded(chunkPos.getWorldPosition())).findAny().isPresent()) {
-            throw BlockPosArgument.ERROR_NOT_LOADED.create();
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/PublishCommand.java b/net/minecraft/server/commands/PublishCommand.java
deleted file mode 100644
index 37380622b33ecd242b7dbf2eebfba1e372ec92e6..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/PublishCommand.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.BoolArgumentType;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import javax.annotation.Nullable;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.GameModeArgument;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.ComponentUtils;
-import net.minecraft.network.chat.MutableComponent;
-import net.minecraft.util.HttpUtil;
-import net.minecraft.world.level.GameType;
-
-public class PublishCommand {
-    private static final SimpleCommandExceptionType ERROR_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.publish.failed"));
-    private static final DynamicCommandExceptionType ERROR_ALREADY_PUBLISHED = new DynamicCommandExceptionType(
-        port -> Component.translatableEscape("commands.publish.alreadyPublished", port)
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("publish")
-                .requires(source -> source.hasPermission(4))
-                .executes(context -> publish(context.getSource(), HttpUtil.getAvailablePort(), false, null))
-                .then(
-                    Commands.argument("allowCommands", BoolArgumentType.bool())
-                        .executes(
-                            context -> publish(context.getSource(), HttpUtil.getAvailablePort(), BoolArgumentType.getBool(context, "allowCommands"), null)
-                        )
-                        .then(
-                            Commands.argument("gamemode", GameModeArgument.gameMode())
-                                .executes(
-                                    context -> publish(
-                                        context.getSource(),
-                                        HttpUtil.getAvailablePort(),
-                                        BoolArgumentType.getBool(context, "allowCommands"),
-                                        GameModeArgument.getGameMode(context, "gamemode")
-                                    )
-                                )
-                                .then(
-                                    Commands.argument("port", IntegerArgumentType.integer(0, 65535))
-                                        .executes(
-                                            context -> publish(
-                                                context.getSource(),
-                                                IntegerArgumentType.getInteger(context, "port"),
-                                                BoolArgumentType.getBool(context, "allowCommands"),
-                                                GameModeArgument.getGameMode(context, "gamemode")
-                                            )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int publish(CommandSourceStack source, int port, boolean cheats, @Nullable GameType gameMode) throws CommandSyntaxException {
-        if (source.getServer().isPublished()) {
-            throw ERROR_ALREADY_PUBLISHED.create(source.getServer().getPort());
-        } else if (!source.getServer().publishServer(gameMode, cheats, port)) {
-            throw ERROR_FAILED.create();
-        } else {
-            source.sendSuccess(() -> getSuccessMessage(port), true);
-            return port;
-        }
-    }
-
-    public static MutableComponent getSuccessMessage(int port) {
-        Component component = ComponentUtils.copyOnClickText(String.valueOf(port));
-        return Component.translatable("commands.publish.started", component);
-    }
-}
diff --git a/net/minecraft/server/commands/RaidCommand.java b/net/minecraft/server/commands/RaidCommand.java
deleted file mode 100644
index 48b31bcd9e22a46585aedcd13f7540871bec8ec3..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/RaidCommand.java
+++ /dev/null
@@ -1,182 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import javax.annotation.Nullable;
-import net.minecraft.commands.CommandBuildContext;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.ComponentArgument;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.registries.Registries;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.sounds.SoundEvents;
-import net.minecraft.sounds.SoundSource;
-import net.minecraft.world.effect.MobEffectInstance;
-import net.minecraft.world.effect.MobEffects;
-import net.minecraft.world.entity.EntitySpawnReason;
-import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.EquipmentSlot;
-import net.minecraft.world.entity.raid.Raid;
-import net.minecraft.world.entity.raid.Raider;
-import net.minecraft.world.entity.raid.Raids;
-import net.minecraft.world.phys.Vec3;
-
-public class RaidCommand {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext context) {
-        dispatcher.register(
-            Commands.literal("raid")
-                .requires(source -> source.hasPermission(3))
-                .then(
-                    Commands.literal("start")
-                        .then(
-                            Commands.argument("omenlvl", IntegerArgumentType.integer(0))
-                                .executes(context1 -> start(context1.getSource(), IntegerArgumentType.getInteger(context1, "omenlvl")))
-                        )
-                )
-                .then(Commands.literal("stop").executes(context1 -> stop(context1.getSource())))
-                .then(Commands.literal("check").executes(context1 -> check(context1.getSource())))
-                .then(
-                    Commands.literal("sound")
-                        .then(
-                            Commands.argument("type", ComponentArgument.textComponent(context))
-                                .executes(context1 -> playSound(context1.getSource(), ComponentArgument.getComponent(context1, "type")))
-                        )
-                )
-                .then(Commands.literal("spawnleader").executes(context1 -> spawnLeader(context1.getSource())))
-                .then(
-                    Commands.literal("setomen")
-                        .then(
-                            Commands.argument("level", IntegerArgumentType.integer(0))
-                                .executes(context1 -> setRaidOmenLevel(context1.getSource(), IntegerArgumentType.getInteger(context1, "level")))
-                        )
-                )
-                .then(Commands.literal("glow").executes(context1 -> glow(context1.getSource())))
-        );
-    }
-
-    private static int glow(CommandSourceStack source) throws CommandSyntaxException {
-        Raid raid = getRaid(source.getPlayerOrException());
-        if (raid != null) {
-            for (Raider raider : raid.getAllRaiders()) {
-                raider.addEffect(new MobEffectInstance(MobEffects.GLOWING, 1000, 1));
-            }
-        }
-
-        return 1;
-    }
-
-    private static int setRaidOmenLevel(CommandSourceStack source, int level) throws CommandSyntaxException {
-        Raid raid = getRaid(source.getPlayerOrException());
-        if (raid != null) {
-            int maxRaidOmenLevel = raid.getMaxRaidOmenLevel();
-            if (level > maxRaidOmenLevel) {
-                source.sendFailure(Component.literal("Sorry, the max raid omen level you can set is " + maxRaidOmenLevel));
-            } else {
-                int raidOmenLevel = raid.getRaidOmenLevel();
-                raid.setRaidOmenLevel(level);
-                source.sendSuccess(() -> Component.literal("Changed village's raid omen level from " + raidOmenLevel + " to " + level), false);
-            }
-        } else {
-            source.sendFailure(Component.literal("No raid found here"));
-        }
-
-        return 1;
-    }
-
-    private static int spawnLeader(CommandSourceStack source) {
-        source.sendSuccess(() -> Component.literal("Spawned a raid captain"), false);
-        Raider raider = EntityType.PILLAGER.create(source.getLevel(), EntitySpawnReason.COMMAND);
-        if (raider == null) {
-            source.sendFailure(Component.literal("Pillager failed to spawn"));
-            return 0;
-        } else {
-            raider.setPatrolLeader(true);
-            raider.setItemSlot(EquipmentSlot.HEAD, Raid.getOminousBannerInstance(source.registryAccess().lookupOrThrow(Registries.BANNER_PATTERN)));
-            raider.setPos(source.getPosition().x, source.getPosition().y, source.getPosition().z);
-            raider.finalizeSpawn(
-                source.getLevel(), source.getLevel().getCurrentDifficultyAt(BlockPos.containing(source.getPosition())), EntitySpawnReason.COMMAND, null
-            );
-            source.getLevel().addFreshEntityWithPassengers(raider);
-            return 1;
-        }
-    }
-
-    private static int playSound(CommandSourceStack source, @Nullable Component type) {
-        if (type != null && type.getString().equals("local")) {
-            ServerLevel level = source.getLevel();
-            Vec3 vec3 = source.getPosition().add(5.0, 0.0, 0.0);
-            level.playSeededSound(null, vec3.x, vec3.y, vec3.z, SoundEvents.RAID_HORN, SoundSource.NEUTRAL, 2.0F, 1.0F, level.random.nextLong());
-        }
-
-        return 1;
-    }
-
-    private static int start(CommandSourceStack source, int badOmenLevel) throws CommandSyntaxException {
-        ServerPlayer playerOrException = source.getPlayerOrException();
-        BlockPos blockPos = playerOrException.blockPosition();
-        if (playerOrException.serverLevel().isRaided(blockPos)) {
-            source.sendFailure(Component.literal("Raid already started close by"));
-            return -1;
-        } else {
-            Raids raids = playerOrException.serverLevel().getRaids();
-            Raid raid = raids.createOrExtendRaid(playerOrException, playerOrException.blockPosition());
-            if (raid != null) {
-                raid.setRaidOmenLevel(badOmenLevel);
-                raids.setDirty();
-                source.sendSuccess(() -> Component.literal("Created a raid in your local village"), false);
-            } else {
-                source.sendFailure(Component.literal("Failed to create a raid in your local village"));
-            }
-
-            return 1;
-        }
-    }
-
-    private static int stop(CommandSourceStack source) throws CommandSyntaxException {
-        ServerPlayer playerOrException = source.getPlayerOrException();
-        BlockPos blockPos = playerOrException.blockPosition();
-        Raid raidAt = playerOrException.serverLevel().getRaidAt(blockPos);
-        if (raidAt != null) {
-            raidAt.stop();
-            source.sendSuccess(() -> Component.literal("Stopped raid"), false);
-            return 1;
-        } else {
-            source.sendFailure(Component.literal("No raid here"));
-            return -1;
-        }
-    }
-
-    private static int check(CommandSourceStack source) throws CommandSyntaxException {
-        Raid raid = getRaid(source.getPlayerOrException());
-        if (raid != null) {
-            StringBuilder stringBuilder = new StringBuilder();
-            stringBuilder.append("Found a started raid! ");
-            source.sendSuccess(() -> Component.literal(stringBuilder.toString()), false);
-            StringBuilder stringBuilder1 = new StringBuilder();
-            stringBuilder1.append("Num groups spawned: ");
-            stringBuilder1.append(raid.getGroupsSpawned());
-            stringBuilder1.append(" Raid omen level: ");
-            stringBuilder1.append(raid.getRaidOmenLevel());
-            stringBuilder1.append(" Num mobs: ");
-            stringBuilder1.append(raid.getTotalRaidersAlive());
-            stringBuilder1.append(" Raid health: ");
-            stringBuilder1.append(raid.getHealthOfLivingRaiders());
-            stringBuilder1.append(" / ");
-            stringBuilder1.append(raid.getTotalHealth());
-            source.sendSuccess(() -> Component.literal(stringBuilder1.toString()), false);
-            return 1;
-        } else {
-            source.sendFailure(Component.literal("Found no started raids"));
-            return 0;
-        }
-    }
-
-    @Nullable
-    private static Raid getRaid(ServerPlayer player) {
-        return player.serverLevel().getRaidAt(player.blockPosition());
-    }
-}
diff --git a/net/minecraft/server/commands/RandomCommand.java b/net/minecraft/server/commands/RandomCommand.java
deleted file mode 100644
index 81d81c293b09a8daac2571c39cfd5c773404f617..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/RandomCommand.java
+++ /dev/null
@@ -1,208 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.google.common.collect.Lists;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.BoolArgumentType;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import com.mojang.brigadier.builder.LiteralArgumentBuilder;
-import com.mojang.brigadier.context.CommandContext;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import com.mojang.brigadier.suggestion.Suggestions;
-import com.mojang.brigadier.suggestion.SuggestionsBuilder;
-import java.util.List;
-import java.util.concurrent.CompletableFuture;
-import javax.annotation.Nullable;
-import net.minecraft.advancements.critereon.MinMaxBounds;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.SharedSuggestionProvider;
-import net.minecraft.commands.arguments.RangeArgument;
-import net.minecraft.commands.arguments.ResourceLocationArgument;
-import net.minecraft.network.chat.Component;
-import net.minecraft.resources.ResourceLocation;
-import net.minecraft.util.Mth;
-import net.minecraft.util.RandomSource;
-import net.minecraft.world.RandomSequences;
-
-public class RandomCommand {
-    private static final SimpleCommandExceptionType ERROR_RANGE_TOO_LARGE = new SimpleCommandExceptionType(
-        Component.translatable("commands.random.error.range_too_large")
-    );
-    private static final SimpleCommandExceptionType ERROR_RANGE_TOO_SMALL = new SimpleCommandExceptionType(
-        Component.translatable("commands.random.error.range_too_small")
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("random")
-                .then(drawRandomValueTree("value", false))
-                .then(drawRandomValueTree("roll", true))
-                .then(
-                    Commands.literal("reset")
-                        .requires(commandSourceStack -> commandSourceStack.hasPermission(2))
-                        .then(
-                            Commands.literal("*")
-                                .executes(commandContext -> resetAllSequences(commandContext.getSource()))
-                                .then(
-                                    Commands.argument("seed", IntegerArgumentType.integer())
-                                        .executes(
-                                            commandContext -> resetAllSequencesAndSetNewDefaults(
-                                                commandContext.getSource(), IntegerArgumentType.getInteger(commandContext, "seed"), true, true
-                                            )
-                                        )
-                                        .then(
-                                            Commands.argument("includeWorldSeed", BoolArgumentType.bool())
-                                                .executes(
-                                                    commandContext -> resetAllSequencesAndSetNewDefaults(
-                                                        commandContext.getSource(),
-                                                        IntegerArgumentType.getInteger(commandContext, "seed"),
-                                                        BoolArgumentType.getBool(commandContext, "includeWorldSeed"),
-                                                        true
-                                                    )
-                                                )
-                                                .then(
-                                                    Commands.argument("includeSequenceId", BoolArgumentType.bool())
-                                                        .executes(
-                                                            commandContext -> resetAllSequencesAndSetNewDefaults(
-                                                                commandContext.getSource(),
-                                                                IntegerArgumentType.getInteger(commandContext, "seed"),
-                                                                BoolArgumentType.getBool(commandContext, "includeWorldSeed"),
-                                                                BoolArgumentType.getBool(commandContext, "includeSequenceId")
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                        .then(
-                            Commands.argument("sequence", ResourceLocationArgument.id())
-                                .suggests(RandomCommand::suggestRandomSequence)
-                                .executes(
-                                    commandContext -> resetSequence(commandContext.getSource(), ResourceLocationArgument.getId(commandContext, "sequence"))
-                                )
-                                .then(
-                                    Commands.argument("seed", IntegerArgumentType.integer())
-                                        .executes(
-                                            commandContext -> resetSequence(
-                                                commandContext.getSource(),
-                                                ResourceLocationArgument.getId(commandContext, "sequence"),
-                                                IntegerArgumentType.getInteger(commandContext, "seed"),
-                                                true,
-                                                true
-                                            )
-                                        )
-                                        .then(
-                                            Commands.argument("includeWorldSeed", BoolArgumentType.bool())
-                                                .executes(
-                                                    commandContext -> resetSequence(
-                                                        commandContext.getSource(),
-                                                        ResourceLocationArgument.getId(commandContext, "sequence"),
-                                                        IntegerArgumentType.getInteger(commandContext, "seed"),
-                                                        BoolArgumentType.getBool(commandContext, "includeWorldSeed"),
-                                                        true
-                                                    )
-                                                )
-                                                .then(
-                                                    Commands.argument("includeSequenceId", BoolArgumentType.bool())
-                                                        .executes(
-                                                            commandContext -> resetSequence(
-                                                                commandContext.getSource(),
-                                                                ResourceLocationArgument.getId(commandContext, "sequence"),
-                                                                IntegerArgumentType.getInteger(commandContext, "seed"),
-                                                                BoolArgumentType.getBool(commandContext, "includeWorldSeed"),
-                                                                BoolArgumentType.getBool(commandContext, "includeSequenceId")
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static LiteralArgumentBuilder<CommandSourceStack> drawRandomValueTree(String subcommand, boolean displayResult) {
-        return Commands.literal(subcommand)
-            .then(
-                Commands.argument("range", RangeArgument.intRange())
-                    .executes(
-                        commandContext -> randomSample(commandContext.getSource(), RangeArgument.Ints.getRange(commandContext, "range"), null, displayResult)
-                    )
-                    .then(
-                        Commands.argument("sequence", ResourceLocationArgument.id())
-                            .suggests(RandomCommand::suggestRandomSequence)
-                            .requires(commandSourceStack -> commandSourceStack.hasPermission(2))
-                            .executes(
-                                commandContext -> randomSample(
-                                    commandContext.getSource(),
-                                    RangeArgument.Ints.getRange(commandContext, "range"),
-                                    ResourceLocationArgument.getId(commandContext, "sequence"),
-                                    displayResult
-                                )
-                            )
-                    )
-            );
-    }
-
-    private static CompletableFuture<Suggestions> suggestRandomSequence(CommandContext<CommandSourceStack> context, SuggestionsBuilder suggestionsBuilder) {
-        List<String> list = Lists.newArrayList();
-        context.getSource().getLevel().getRandomSequences().forAllSequences((resourceLocation, randomSequence) -> list.add(resourceLocation.toString()));
-        return SharedSuggestionProvider.suggest(list, suggestionsBuilder);
-    }
-
-    private static int randomSample(CommandSourceStack source, MinMaxBounds.Ints range, @Nullable ResourceLocation sequence, boolean displayResult) throws CommandSyntaxException {
-        RandomSource randomSequence;
-        if (sequence != null) {
-            randomSequence = source.getLevel().getRandomSequence(sequence);
-        } else {
-            randomSequence = source.getLevel().getRandom();
-        }
-
-        int i = range.min().orElse(Integer.MIN_VALUE);
-        int i1 = range.max().orElse(Integer.MAX_VALUE);
-        long l = (long)i1 - i;
-        if (l == 0L) {
-            throw ERROR_RANGE_TOO_SMALL.create();
-        } else if (l >= 2147483647L) {
-            throw ERROR_RANGE_TOO_LARGE.create();
-        } else {
-            int i2 = Mth.randomBetweenInclusive(randomSequence, i, i1);
-            if (displayResult) {
-                source.getServer()
-                    .getPlayerList()
-                    .broadcastSystemMessage(Component.translatable("commands.random.roll", source.getDisplayName(), i2, i, i1), false);
-            } else {
-                source.sendSuccess(() -> Component.translatable("commands.random.sample.success", i2), false);
-            }
-
-            return i2;
-        }
-    }
-
-    private static int resetSequence(CommandSourceStack source, ResourceLocation sequence) throws CommandSyntaxException {
-        source.getLevel().getRandomSequences().reset(sequence);
-        source.sendSuccess(() -> Component.translatable("commands.random.reset.success", Component.translationArg(sequence)), false);
-        return 1;
-    }
-
-    private static int resetSequence(CommandSourceStack source, ResourceLocation sequence, int seed, boolean includeWorldSeed, boolean includeSequenceId) throws CommandSyntaxException {
-        source.getLevel().getRandomSequences().reset(sequence, seed, includeWorldSeed, includeSequenceId);
-        source.sendSuccess(() -> Component.translatable("commands.random.reset.success", Component.translationArg(sequence)), false);
-        return 1;
-    }
-
-    private static int resetAllSequences(CommandSourceStack source) {
-        int i = source.getLevel().getRandomSequences().clear();
-        source.sendSuccess(() -> Component.translatable("commands.random.reset.all.success", i), false);
-        return i;
-    }
-
-    private static int resetAllSequencesAndSetNewDefaults(CommandSourceStack source, int seed, boolean includeWorldSeed, boolean includeSequenceId) {
-        RandomSequences randomSequences = source.getLevel().getRandomSequences();
-        randomSequences.setSeedDefaults(seed, includeWorldSeed, includeSequenceId);
-        int i = randomSequences.clear();
-        source.sendSuccess(() -> Component.translatable("commands.random.reset.all.success", i), false);
-        return i;
-    }
-}
diff --git a/net/minecraft/server/commands/RecipeCommand.java b/net/minecraft/server/commands/RecipeCommand.java
deleted file mode 100644
index d171a5b8c1969f6a482f029afa5fb0228aefb04d..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/RecipeCommand.java
+++ /dev/null
@@ -1,123 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import java.util.Collection;
-import java.util.Collections;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.commands.arguments.ResourceKeyArgument;
-import net.minecraft.core.registries.Registries;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.world.item.crafting.RecipeHolder;
-
-public class RecipeCommand {
-    private static final SimpleCommandExceptionType ERROR_GIVE_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.recipe.give.failed"));
-    private static final SimpleCommandExceptionType ERROR_TAKE_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.recipe.take.failed"));
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("recipe")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.literal("give")
-                        .then(
-                            Commands.argument("targets", EntityArgument.players())
-                                .then(
-                                    Commands.argument("recipe", ResourceKeyArgument.key(Registries.RECIPE))
-                                        .executes(
-                                            context -> giveRecipes(
-                                                context.getSource(),
-                                                EntityArgument.getPlayers(context, "targets"),
-                                                Collections.singleton(ResourceKeyArgument.getRecipe(context, "recipe"))
-                                            )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("*")
-                                        .executes(
-                                            context -> giveRecipes(
-                                                context.getSource(),
-                                                EntityArgument.getPlayers(context, "targets"),
-                                                context.getSource().getServer().getRecipeManager().getRecipes()
-                                            )
-                                        )
-                                )
-                        )
-                )
-                .then(
-                    Commands.literal("take")
-                        .then(
-                            Commands.argument("targets", EntityArgument.players())
-                                .then(
-                                    Commands.argument("recipe", ResourceKeyArgument.key(Registries.RECIPE))
-                                        .executes(
-                                            context -> takeRecipes(
-                                                context.getSource(),
-                                                EntityArgument.getPlayers(context, "targets"),
-                                                Collections.singleton(ResourceKeyArgument.getRecipe(context, "recipe"))
-                                            )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("*")
-                                        .executes(
-                                            context -> takeRecipes(
-                                                context.getSource(),
-                                                EntityArgument.getPlayers(context, "targets"),
-                                                context.getSource().getServer().getRecipeManager().getRecipes()
-                                            )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int giveRecipes(CommandSourceStack source, Collection<ServerPlayer> targets, Collection<RecipeHolder<?>> recipes) throws CommandSyntaxException {
-        int i = 0;
-
-        for (ServerPlayer serverPlayer : targets) {
-            i += serverPlayer.awardRecipes(recipes);
-        }
-
-        if (i == 0) {
-            throw ERROR_GIVE_FAILED.create();
-        } else {
-            if (targets.size() == 1) {
-                source.sendSuccess(
-                    () -> Component.translatable("commands.recipe.give.success.single", recipes.size(), targets.iterator().next().getDisplayName()), true
-                );
-            } else {
-                source.sendSuccess(() -> Component.translatable("commands.recipe.give.success.multiple", recipes.size(), targets.size()), true);
-            }
-
-            return i;
-        }
-    }
-
-    private static int takeRecipes(CommandSourceStack source, Collection<ServerPlayer> targets, Collection<RecipeHolder<?>> recipes) throws CommandSyntaxException {
-        int i = 0;
-
-        for (ServerPlayer serverPlayer : targets) {
-            i += serverPlayer.resetRecipes(recipes);
-        }
-
-        if (i == 0) {
-            throw ERROR_TAKE_FAILED.create();
-        } else {
-            if (targets.size() == 1) {
-                source.sendSuccess(
-                    () -> Component.translatable("commands.recipe.take.success.single", recipes.size(), targets.iterator().next().getDisplayName()), true
-                );
-            } else {
-                source.sendSuccess(() -> Component.translatable("commands.recipe.take.success.multiple", recipes.size(), targets.size()), true);
-            }
-
-            return i;
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/ReloadCommand.java b/net/minecraft/server/commands/ReloadCommand.java
deleted file mode 100644
index 42ffdbeb21324cec477a665cf455afcaae82e041..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/ReloadCommand.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.google.common.collect.Lists;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.logging.LogUtils;
-import java.util.Collection;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.server.packs.repository.PackRepository;
-import net.minecraft.world.level.storage.WorldData;
-import org.slf4j.Logger;
-
-public class ReloadCommand {
-    private static final Logger LOGGER = LogUtils.getLogger();
-
-    public static void reloadPacks(Collection<String> selectedIds, CommandSourceStack source) {
-        source.getServer().reloadResources(selectedIds, io.papermc.paper.event.server.ServerResourcesReloadedEvent.Cause.COMMAND).exceptionally(throwable -> { // Paper - Add ServerResourcesReloadedEvent
-            LOGGER.warn("Failed to execute reload", throwable);
-            source.sendFailure(Component.translatable("commands.reload.failure"));
-            return null;
-        });
-    }
-
-    private static Collection<String> discoverNewPacks(PackRepository packRepository, WorldData worldData, Collection<String> selectedIds) {
-        packRepository.reload(true); // Paper - will perform a full reload
-        Collection<String> list = Lists.newArrayList(selectedIds);
-        Collection<String> disabled = worldData.getDataConfiguration().dataPacks().getDisabled();
-
-        for (String string : packRepository.getAvailableIds()) {
-            if (!disabled.contains(string) && !list.contains(string)) {
-                list.add(string);
-            }
-        }
-
-        return list;
-    }
-
-    // CraftBukkit start
-    public static void reload(MinecraftServer server) {
-        PackRepository packRepository = server.getPackRepository();
-        WorldData worldData = server.getWorldData();
-        Collection<String> selectedIds = packRepository.getSelectedIds();
-        Collection<String> collection = discoverNewPacks(packRepository, worldData, selectedIds);
-        server.reloadResources(collection, io.papermc.paper.event.server.ServerResourcesReloadedEvent.Cause.PLUGIN); // Paper - Add ServerResourcesReloadedEvent
-    }
-    // CraftBukkit end
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(Commands.literal("reload").requires(source -> source.hasPermission(2)).executes(context -> {
-            CommandSourceStack commandSourceStack = context.getSource();
-            MinecraftServer server = commandSourceStack.getServer();
-            PackRepository packRepository = server.getPackRepository();
-            WorldData worldData = server.getWorldData();
-            Collection<String> selectedIds = packRepository.getSelectedIds();
-            Collection<String> collection = discoverNewPacks(packRepository, worldData, selectedIds);
-            commandSourceStack.sendSuccess(() -> Component.translatable("commands.reload.success"), true);
-            reloadPacks(collection, commandSourceStack);
-            return 0;
-        }));
-    }
-}
diff --git a/net/minecraft/server/commands/ReturnCommand.java b/net/minecraft/server/commands/ReturnCommand.java
deleted file mode 100644
index 95c2a0ddd4b76625441af05d9d99380b091144b4..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/ReturnCommand.java
+++ /dev/null
@@ -1,68 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import com.mojang.brigadier.builder.LiteralArgumentBuilder;
-import com.mojang.brigadier.builder.RequiredArgumentBuilder;
-import com.mojang.brigadier.context.ContextChain;
-import java.util.List;
-import net.minecraft.commands.ExecutionCommandSource;
-import net.minecraft.commands.execution.ChainModifiers;
-import net.minecraft.commands.execution.CustomCommandExecutor;
-import net.minecraft.commands.execution.CustomModifierExecutor;
-import net.minecraft.commands.execution.ExecutionControl;
-import net.minecraft.commands.execution.Frame;
-import net.minecraft.commands.execution.tasks.BuildContexts;
-import net.minecraft.commands.execution.tasks.FallthroughTask;
-
-public class ReturnCommand {
-    public static <T extends ExecutionCommandSource<T>> void register(CommandDispatcher<T> dispatcher) {
-        dispatcher.register(
-            (LiteralArgumentBuilder<T>)LiteralArgumentBuilder.<T>literal("return")
-                .requires(executionCommandSource -> executionCommandSource.hasPermission(2))
-                .then(
-                    RequiredArgumentBuilder.<T, Integer>argument("value", IntegerArgumentType.integer())
-                        .executes(new ReturnCommand.ReturnValueCustomExecutor<>())
-                )
-                .then(LiteralArgumentBuilder.<T>literal("fail").executes(new ReturnCommand.ReturnFailCustomExecutor<>()))
-                .then(LiteralArgumentBuilder.<T>literal("run").forward(dispatcher.getRoot(), new ReturnCommand.ReturnFromCommandCustomModifier<>(), false))
-        );
-    }
-
-    static class ReturnFailCustomExecutor<T extends ExecutionCommandSource<T>> implements CustomCommandExecutor.CommandAdapter<T> {
-        @Override
-        public void run(T source, ContextChain<T> contextChain, ChainModifiers chainModifiers, ExecutionControl<T> executionControl) {
-            source.callback().onFailure();
-            Frame frame = executionControl.currentFrame();
-            frame.returnFailure();
-            frame.discard();
-        }
-    }
-
-    static class ReturnFromCommandCustomModifier<T extends ExecutionCommandSource<T>> implements CustomModifierExecutor.ModifierAdapter<T> {
-        @Override
-        public void apply(T originalSource, List<T> soruces, ContextChain<T> contextChain, ChainModifiers chainModifiers, ExecutionControl<T> executionControl) {
-            if (soruces.isEmpty()) {
-                if (chainModifiers.isReturn()) {
-                    executionControl.queueNext(FallthroughTask.instance());
-                }
-            } else {
-                executionControl.currentFrame().discard();
-                ContextChain<T> contextChain1 = contextChain.nextStage();
-                String input = contextChain1.getTopContext().getInput();
-                executionControl.queueNext(new BuildContexts.Continuation<>(input, contextChain1, chainModifiers.setReturn(), originalSource, soruces));
-            }
-        }
-    }
-
-    static class ReturnValueCustomExecutor<T extends ExecutionCommandSource<T>> implements CustomCommandExecutor.CommandAdapter<T> {
-        @Override
-        public void run(T source, ContextChain<T> contextChain, ChainModifiers chainModifiers, ExecutionControl<T> executionControl) {
-            int integer = IntegerArgumentType.getInteger(contextChain.getTopContext(), "value");
-            source.callback().onSuccess(integer);
-            Frame frame = executionControl.currentFrame();
-            frame.returnSuccess(integer);
-            frame.discard();
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/RideCommand.java b/net/minecraft/server/commands/RideCommand.java
deleted file mode 100644
index 281c54b870f095743f0d32180070b41bf85440f2..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/RideCommand.java
+++ /dev/null
@@ -1,85 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
-import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.network.chat.Component;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.EntityType;
-
-public class RideCommand {
-    private static final DynamicCommandExceptionType ERROR_NOT_RIDING = new DynamicCommandExceptionType(
-        target -> Component.translatableEscape("commands.ride.not_riding", target)
-    );
-    private static final Dynamic2CommandExceptionType ERROR_ALREADY_RIDING = new Dynamic2CommandExceptionType(
-        (target, vehicle) -> Component.translatableEscape("commands.ride.already_riding", target, vehicle)
-    );
-    private static final Dynamic2CommandExceptionType ERROR_MOUNT_FAILED = new Dynamic2CommandExceptionType(
-        (target, vehicle) -> Component.translatableEscape("commands.ride.mount.failure.generic", target, vehicle)
-    );
-    private static final SimpleCommandExceptionType ERROR_MOUNTING_PLAYER = new SimpleCommandExceptionType(
-        Component.translatable("commands.ride.mount.failure.cant_ride_players")
-    );
-    private static final SimpleCommandExceptionType ERROR_MOUNTING_LOOP = new SimpleCommandExceptionType(
-        Component.translatable("commands.ride.mount.failure.loop")
-    );
-    private static final SimpleCommandExceptionType ERROR_WRONG_DIMENSION = new SimpleCommandExceptionType(
-        Component.translatable("commands.ride.mount.failure.wrong_dimension")
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("ride")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.argument("target", EntityArgument.entity())
-                        .then(
-                            Commands.literal("mount")
-                                .then(
-                                    Commands.argument("vehicle", EntityArgument.entity())
-                                        .executes(
-                                            context -> mount(
-                                                context.getSource(), EntityArgument.getEntity(context, "target"), EntityArgument.getEntity(context, "vehicle")
-                                            )
-                                        )
-                                )
-                        )
-                        .then(Commands.literal("dismount").executes(context -> dismount(context.getSource(), EntityArgument.getEntity(context, "target"))))
-                )
-        );
-    }
-
-    private static int mount(CommandSourceStack source, Entity target, Entity vehicle) throws CommandSyntaxException {
-        Entity vehicle1 = target.getVehicle();
-        if (vehicle1 != null) {
-            throw ERROR_ALREADY_RIDING.create(target.getDisplayName(), vehicle1.getDisplayName());
-        } else if (vehicle.getType() == EntityType.PLAYER && !io.papermc.paper.configuration.GlobalConfiguration.get().commands.rideCommandAllowPlayerAsVehicle) { // Paper - allow player as vehicle
-            throw ERROR_MOUNTING_PLAYER.create();
-        } else if (target.getSelfAndPassengers().anyMatch(passenger -> passenger == vehicle)) {
-            throw ERROR_MOUNTING_LOOP.create();
-        } else if (target.level() != vehicle.level()) {
-            throw ERROR_WRONG_DIMENSION.create();
-        } else if (!target.startRiding(vehicle, true)) {
-            throw ERROR_MOUNT_FAILED.create(target.getDisplayName(), vehicle.getDisplayName());
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.ride.mount.success", target.getDisplayName(), vehicle.getDisplayName()), true);
-            return 1;
-        }
-    }
-
-    private static int dismount(CommandSourceStack source, Entity target) throws CommandSyntaxException {
-        Entity vehicle = target.getVehicle();
-        if (vehicle == null) {
-            throw ERROR_NOT_RIDING.create(target.getDisplayName());
-        } else {
-            target.stopRiding();
-            source.sendSuccess(() -> Component.translatable("commands.ride.dismount.success", target.getDisplayName(), vehicle.getDisplayName()), true);
-            return 1;
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/RotateCommand.java b/net/minecraft/server/commands/RotateCommand.java
deleted file mode 100644
index bd7bd783367eb12ac5423406455cd41d9bc929a1..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/RotateCommand.java
+++ /dev/null
@@ -1,87 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.EntityAnchorArgument;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.commands.arguments.coordinates.Coordinates;
-import net.minecraft.commands.arguments.coordinates.RotationArgument;
-import net.minecraft.commands.arguments.coordinates.Vec3Argument;
-import net.minecraft.network.chat.Component;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.phys.Vec2;
-
-public class RotateCommand {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("rotate")
-                .requires(commandSourceStack -> commandSourceStack.hasPermission(2))
-                .then(
-                    Commands.argument("target", EntityArgument.entity())
-                        .then(
-                            Commands.argument("rotation", RotationArgument.rotation())
-                                .executes(
-                                    context -> rotate(
-                                        context.getSource(), EntityArgument.getEntity(context, "target"), RotationArgument.getRotation(context, "rotation")
-                                    )
-                                )
-                        )
-                        .then(
-                            Commands.literal("facing")
-                                .then(
-                                    Commands.literal("entity")
-                                        .then(
-                                            Commands.argument("facingEntity", EntityArgument.entity())
-                                                .executes(
-                                                    context -> rotate(
-                                                        context.getSource(),
-                                                        EntityArgument.getEntity(context, "target"),
-                                                        new LookAt.LookAtEntity(
-                                                            EntityArgument.getEntity(context, "facingEntity"), EntityAnchorArgument.Anchor.FEET
-                                                        )
-                                                    )
-                                                )
-                                                .then(
-                                                    Commands.argument("facingAnchor", EntityAnchorArgument.anchor())
-                                                        .executes(
-                                                            context -> rotate(
-                                                                context.getSource(),
-                                                                EntityArgument.getEntity(context, "target"),
-                                                                new LookAt.LookAtEntity(
-                                                                    EntityArgument.getEntity(context, "facingEntity"),
-                                                                    EntityAnchorArgument.getAnchor(context, "facingAnchor")
-                                                                )
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.argument("facingLocation", Vec3Argument.vec3())
-                                        .executes(
-                                            commandContext -> rotate(
-                                                commandContext.getSource(),
-                                                EntityArgument.getEntity(commandContext, "target"),
-                                                new LookAt.LookAtPosition(Vec3Argument.getVec3(commandContext, "facingLocation"))
-                                            )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int rotate(CommandSourceStack source, Entity entity, Coordinates coordinates) {
-        Vec2 rotation = coordinates.getRotation(source);
-        entity.forceSetRotation(rotation.y, rotation.x);
-        source.sendSuccess(() -> Component.translatable("commands.rotate.success", entity.getDisplayName()), true);
-        return 1;
-    }
-
-    private static int rotate(CommandSourceStack source, Entity entity, LookAt lookAt) {
-        lookAt.perform(source, entity);
-        source.sendSuccess(() -> Component.translatable("commands.rotate.success", entity.getDisplayName()), true);
-        return 1;
-    }
-}
diff --git a/net/minecraft/server/commands/SaveOffCommand.java b/net/minecraft/server/commands/SaveOffCommand.java
deleted file mode 100644
index 1050fdc531905a33b51b5b9b60d7ab063d9c2d81..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/SaveOffCommand.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.level.ServerLevel;
-
-public class SaveOffCommand {
-    private static final SimpleCommandExceptionType ERROR_ALREADY_OFF = new SimpleCommandExceptionType(Component.translatable("commands.save.alreadyOff"));
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(Commands.literal("save-off").requires(source -> source.hasPermission(4)).executes(context -> {
-            CommandSourceStack commandSourceStack = context.getSource();
-            boolean flag = false;
-
-            for (ServerLevel serverLevel : commandSourceStack.getServer().getAllLevels()) {
-                if (serverLevel != null && !serverLevel.noSave) {
-                    serverLevel.noSave = true;
-                    flag = true;
-                }
-            }
-
-            if (!flag) {
-                throw ERROR_ALREADY_OFF.create();
-            } else {
-                commandSourceStack.sendSuccess(() -> Component.translatable("commands.save.disabled"), true);
-                return 1;
-            }
-        }));
-    }
-}
diff --git a/net/minecraft/server/commands/SaveOnCommand.java b/net/minecraft/server/commands/SaveOnCommand.java
deleted file mode 100644
index 91c4b403104c9d73e274cd5dc7a4a0dead8b6add..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/SaveOnCommand.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.level.ServerLevel;
-
-public class SaveOnCommand {
-    private static final SimpleCommandExceptionType ERROR_ALREADY_ON = new SimpleCommandExceptionType(Component.translatable("commands.save.alreadyOn"));
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(Commands.literal("save-on").requires(source -> source.hasPermission(4)).executes(context -> {
-            CommandSourceStack commandSourceStack = context.getSource();
-            boolean flag = false;
-
-            for (ServerLevel serverLevel : commandSourceStack.getServer().getAllLevels()) {
-                if (serverLevel != null && serverLevel.noSave) {
-                    serverLevel.noSave = false;
-                    flag = true;
-                }
-            }
-
-            if (!flag) {
-                throw ERROR_ALREADY_ON.create();
-            } else {
-                commandSourceStack.sendSuccess(() -> Component.translatable("commands.save.enabled"), true);
-                return 1;
-            }
-        }));
-    }
-}
diff --git a/net/minecraft/server/commands/SayCommand.java b/net/minecraft/server/commands/SayCommand.java
deleted file mode 100644
index da8a2f1ed8d2e7202f8de5713d6871d516df7930..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/SayCommand.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.MessageArgument;
-import net.minecraft.network.chat.ChatType;
-import net.minecraft.server.players.PlayerList;
-
-public class SayCommand {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("say")
-                .requires(source -> source.hasPermission(2))
-                .then(Commands.argument("message", MessageArgument.message()).executes(context -> {
-                    MessageArgument.resolveChatMessage(context, "message", message -> {
-                        CommandSourceStack commandSourceStack = context.getSource();
-                        PlayerList playerList = commandSourceStack.getServer().getPlayerList();
-                        playerList.broadcastChatMessage(message, commandSourceStack, ChatType.bind(ChatType.SAY_COMMAND, commandSourceStack));
-                    });
-                    return 1;
-                }))
-        );
-    }
-}
diff --git a/net/minecraft/server/commands/ScheduleCommand.java b/net/minecraft/server/commands/ScheduleCommand.java
deleted file mode 100644
index d545b48a31ca15a0c668f0d76906334fff43cdf3..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/ScheduleCommand.java
+++ /dev/null
@@ -1,143 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import com.mojang.brigadier.arguments.StringArgumentType;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import com.mojang.brigadier.suggestion.SuggestionProvider;
-import com.mojang.datafixers.util.Either;
-import com.mojang.datafixers.util.Pair;
-import java.util.Collection;
-import java.util.Optional;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.SharedSuggestionProvider;
-import net.minecraft.commands.arguments.TimeArgument;
-import net.minecraft.commands.arguments.item.FunctionArgument;
-import net.minecraft.commands.functions.CommandFunction;
-import net.minecraft.commands.functions.MacroFunction;
-import net.minecraft.network.chat.Component;
-import net.minecraft.resources.ResourceLocation;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.world.level.timers.FunctionCallback;
-import net.minecraft.world.level.timers.FunctionTagCallback;
-import net.minecraft.world.level.timers.TimerQueue;
-
-public class ScheduleCommand {
-    private static final SimpleCommandExceptionType ERROR_SAME_TICK = new SimpleCommandExceptionType(Component.translatable("commands.schedule.same_tick"));
-    private static final DynamicCommandExceptionType ERROR_CANT_REMOVE = new DynamicCommandExceptionType(
-        functionName -> Component.translatableEscape("commands.schedule.cleared.failure", functionName)
-    );
-    private static final SimpleCommandExceptionType ERROR_MACRO = new SimpleCommandExceptionType(Component.translatableEscape("commands.schedule.macro"));
-    private static final SuggestionProvider<CommandSourceStack> SUGGEST_SCHEDULE = (context, builder) -> SharedSuggestionProvider.suggest(
-        context.getSource().getLevel().serverLevelData.getScheduledEvents().getEventsIds(), builder // Paper - Make schedule command per-world
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("schedule")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.literal("function")
-                        .then(
-                            Commands.argument("function", FunctionArgument.functions())
-                                .suggests(FunctionCommand.SUGGEST_FUNCTION)
-                                .then(
-                                    Commands.argument("time", TimeArgument.time())
-                                        .executes(
-                                            context -> schedule(
-                                                context.getSource(),
-                                                FunctionArgument.getFunctionOrTag(context, "function"),
-                                                IntegerArgumentType.getInteger(context, "time"),
-                                                true
-                                            )
-                                        )
-                                        .then(
-                                            Commands.literal("append")
-                                                .executes(
-                                                    context -> schedule(
-                                                        context.getSource(),
-                                                        FunctionArgument.getFunctionOrTag(context, "function"),
-                                                        IntegerArgumentType.getInteger(context, "time"),
-                                                        false
-                                                    )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.literal("replace")
-                                                .executes(
-                                                    context -> schedule(
-                                                        context.getSource(),
-                                                        FunctionArgument.getFunctionOrTag(context, "function"),
-                                                        IntegerArgumentType.getInteger(context, "time"),
-                                                        true
-                                                    )
-                                                )
-                                        )
-                                )
-                        )
-                )
-                .then(
-                    Commands.literal("clear")
-                        .then(
-                            Commands.argument("function", StringArgumentType.greedyString())
-                                .suggests(SUGGEST_SCHEDULE)
-                                .executes(context -> remove(context.getSource(), StringArgumentType.getString(context, "function")))
-                        )
-                )
-        );
-    }
-
-    private static int schedule(
-        CommandSourceStack source,
-        Pair<ResourceLocation, Either<CommandFunction<CommandSourceStack>, Collection<CommandFunction<CommandSourceStack>>>> function,
-        int time,
-        boolean append
-    ) throws CommandSyntaxException {
-        if (time == 0) {
-            throw ERROR_SAME_TICK.create();
-        } else {
-            long l = source.getLevel().getGameTime() + time;
-            ResourceLocation resourceLocation = function.getFirst();
-            TimerQueue<MinecraftServer> scheduledEvents = source.getLevel().serverLevelData.overworldData().getScheduledEvents(); // CraftBukkit - SPIGOT-6667: Use world specific function timer
-            Optional<CommandFunction<CommandSourceStack>> optional = function.getSecond().left();
-            if (optional.isPresent()) {
-                if (optional.get() instanceof MacroFunction) {
-                    throw ERROR_MACRO.create();
-                }
-
-                String string = resourceLocation.toString();
-                if (append) {
-                    scheduledEvents.remove(string);
-                }
-
-                scheduledEvents.schedule(string, l, new FunctionCallback(resourceLocation));
-                source.sendSuccess(
-                    () -> Component.translatable("commands.schedule.created.function", Component.translationArg(resourceLocation), time, l), true
-                );
-            } else {
-                String string = "#" + resourceLocation;
-                if (append) {
-                    scheduledEvents.remove(string);
-                }
-
-                scheduledEvents.schedule(string, l, new FunctionTagCallback(resourceLocation));
-                source.sendSuccess(() -> Component.translatable("commands.schedule.created.tag", Component.translationArg(resourceLocation), time, l), true);
-            }
-
-            return Math.floorMod(l, Integer.MAX_VALUE);
-        }
-    }
-
-    private static int remove(CommandSourceStack source, String function) throws CommandSyntaxException {
-        int i = source.getLevel().serverLevelData.overworldData().getScheduledEvents().remove(function); // Paper - Make schedule command per-world
-        if (i == 0) {
-            throw ERROR_CANT_REMOVE.create(function);
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.schedule.cleared.success", i, function), true);
-            return i;
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/ScoreboardCommand.java b/net/minecraft/server/commands/ScoreboardCommand.java
deleted file mode 100644
index b9ba094aac50d83e3b32d1ef0b4a4769a278eceb..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/ScoreboardCommand.java
+++ /dev/null
@@ -1,917 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.google.common.collect.Lists;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.BoolArgumentType;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import com.mojang.brigadier.arguments.StringArgumentType;
-import com.mojang.brigadier.builder.ArgumentBuilder;
-import com.mojang.brigadier.builder.LiteralArgumentBuilder;
-import com.mojang.brigadier.context.CommandContext;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import com.mojang.brigadier.suggestion.Suggestions;
-import com.mojang.brigadier.suggestion.SuggestionsBuilder;
-import it.unimi.dsi.fastutil.objects.Object2IntMap;
-import it.unimi.dsi.fastutil.objects.Object2IntMaps;
-import java.util.Collection;
-import java.util.List;
-import java.util.concurrent.CompletableFuture;
-import javax.annotation.Nullable;
-import net.minecraft.commands.CommandBuildContext;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.SharedSuggestionProvider;
-import net.minecraft.commands.arguments.ComponentArgument;
-import net.minecraft.commands.arguments.ObjectiveArgument;
-import net.minecraft.commands.arguments.ObjectiveCriteriaArgument;
-import net.minecraft.commands.arguments.OperationArgument;
-import net.minecraft.commands.arguments.ScoreHolderArgument;
-import net.minecraft.commands.arguments.ScoreboardSlotArgument;
-import net.minecraft.commands.arguments.StyleArgument;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.ComponentUtils;
-import net.minecraft.network.chat.Style;
-import net.minecraft.network.chat.numbers.BlankFormat;
-import net.minecraft.network.chat.numbers.FixedFormat;
-import net.minecraft.network.chat.numbers.NumberFormat;
-import net.minecraft.network.chat.numbers.StyledFormat;
-import net.minecraft.world.scores.DisplaySlot;
-import net.minecraft.world.scores.Objective;
-import net.minecraft.world.scores.ReadOnlyScoreInfo;
-import net.minecraft.world.scores.ScoreAccess;
-import net.minecraft.world.scores.ScoreHolder;
-import net.minecraft.world.scores.Scoreboard;
-import net.minecraft.world.scores.criteria.ObjectiveCriteria;
-
-public class ScoreboardCommand {
-    private static final SimpleCommandExceptionType ERROR_OBJECTIVE_ALREADY_EXISTS = new SimpleCommandExceptionType(
-        Component.translatable("commands.scoreboard.objectives.add.duplicate")
-    );
-    private static final SimpleCommandExceptionType ERROR_DISPLAY_SLOT_ALREADY_EMPTY = new SimpleCommandExceptionType(
-        Component.translatable("commands.scoreboard.objectives.display.alreadyEmpty")
-    );
-    private static final SimpleCommandExceptionType ERROR_DISPLAY_SLOT_ALREADY_SET = new SimpleCommandExceptionType(
-        Component.translatable("commands.scoreboard.objectives.display.alreadySet")
-    );
-    private static final SimpleCommandExceptionType ERROR_TRIGGER_ALREADY_ENABLED = new SimpleCommandExceptionType(
-        Component.translatable("commands.scoreboard.players.enable.failed")
-    );
-    private static final SimpleCommandExceptionType ERROR_NOT_TRIGGER = new SimpleCommandExceptionType(
-        Component.translatable("commands.scoreboard.players.enable.invalid")
-    );
-    private static final Dynamic2CommandExceptionType ERROR_NO_VALUE = new Dynamic2CommandExceptionType(
-        (objective, target) -> Component.translatableEscape("commands.scoreboard.players.get.null", objective, target)
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext context) {
-        dispatcher.register(
-            Commands.literal("scoreboard")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.literal("objectives")
-                        .then(Commands.literal("list").executes(context1 -> listObjectives(context1.getSource())))
-                        .then(
-                            Commands.literal("add")
-                                .then(
-                                    Commands.argument("objective", StringArgumentType.word())
-                                        .then(
-                                            Commands.argument("criteria", ObjectiveCriteriaArgument.criteria())
-                                                .executes(
-                                                    context1 -> addObjective(
-                                                        context1.getSource(),
-                                                        StringArgumentType.getString(context1, "objective"),
-                                                        ObjectiveCriteriaArgument.getCriteria(context1, "criteria"),
-                                                        Component.literal(StringArgumentType.getString(context1, "objective"))
-                                                    )
-                                                )
-                                                .then(
-                                                    Commands.argument("displayName", ComponentArgument.textComponent(context))
-                                                        .executes(
-                                                            context1 -> addObjective(
-                                                                context1.getSource(),
-                                                                StringArgumentType.getString(context1, "objective"),
-                                                                ObjectiveCriteriaArgument.getCriteria(context1, "criteria"),
-                                                                ComponentArgument.getComponent(context1, "displayName")
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                        .then(
-                            Commands.literal("modify")
-                                .then(
-                                    Commands.argument("objective", ObjectiveArgument.objective())
-                                        .then(
-                                            Commands.literal("displayname")
-                                                .then(
-                                                    Commands.argument("displayName", ComponentArgument.textComponent(context))
-                                                        .executes(
-                                                            context1 -> setDisplayName(
-                                                                context1.getSource(),
-                                                                ObjectiveArgument.getObjective(context1, "objective"),
-                                                                ComponentArgument.getComponent(context1, "displayName")
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                        .then(createRenderTypeModify())
-                                        .then(
-                                            Commands.literal("displayautoupdate")
-                                                .then(
-                                                    Commands.argument("value", BoolArgumentType.bool())
-                                                        .executes(
-                                                            context1 -> setDisplayAutoUpdate(
-                                                                context1.getSource(),
-                                                                ObjectiveArgument.getObjective(context1, "objective"),
-                                                                BoolArgumentType.getBool(context1, "value")
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                        .then(
-                                            addNumberFormats(
-                                                context,
-                                                Commands.literal("numberformat"),
-                                                (context1, format) -> setObjectiveFormat(
-                                                    context1.getSource(), ObjectiveArgument.getObjective(context1, "objective"), format
-                                                )
-                                            )
-                                        )
-                                )
-                        )
-                        .then(
-                            Commands.literal("remove")
-                                .then(
-                                    Commands.argument("objective", ObjectiveArgument.objective())
-                                        .executes(context1 -> removeObjective(context1.getSource(), ObjectiveArgument.getObjective(context1, "objective")))
-                                )
-                        )
-                        .then(
-                            Commands.literal("setdisplay")
-                                .then(
-                                    Commands.argument("slot", ScoreboardSlotArgument.displaySlot())
-                                        .executes(context1 -> clearDisplaySlot(context1.getSource(), ScoreboardSlotArgument.getDisplaySlot(context1, "slot")))
-                                        .then(
-                                            Commands.argument("objective", ObjectiveArgument.objective())
-                                                .executes(
-                                                    context1 -> setDisplaySlot(
-                                                        context1.getSource(),
-                                                        ScoreboardSlotArgument.getDisplaySlot(context1, "slot"),
-                                                        ObjectiveArgument.getObjective(context1, "objective")
-                                                    )
-                                                )
-                                        )
-                                )
-                        )
-                )
-                .then(
-                    Commands.literal("players")
-                        .then(
-                            Commands.literal("list")
-                                .executes(context1 -> listTrackedPlayers(context1.getSource()))
-                                .then(
-                                    Commands.argument("target", ScoreHolderArgument.scoreHolder())
-                                        .suggests(ScoreHolderArgument.SUGGEST_SCORE_HOLDERS)
-                                        .executes(context1 -> listTrackedPlayerScores(context1.getSource(), ScoreHolderArgument.getName(context1, "target")))
-                                )
-                        )
-                        .then(
-                            Commands.literal("set")
-                                .then(
-                                    Commands.argument("targets", ScoreHolderArgument.scoreHolders())
-                                        .suggests(ScoreHolderArgument.SUGGEST_SCORE_HOLDERS)
-                                        .then(
-                                            Commands.argument("objective", ObjectiveArgument.objective())
-                                                .then(
-                                                    Commands.argument("score", IntegerArgumentType.integer())
-                                                        .executes(
-                                                            context1 -> setScore(
-                                                                context1.getSource(),
-                                                                ScoreHolderArgument.getNamesWithDefaultWildcard(context1, "targets"),
-                                                                ObjectiveArgument.getWritableObjective(context1, "objective"),
-                                                                IntegerArgumentType.getInteger(context1, "score")
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                        .then(
-                            Commands.literal("get")
-                                .then(
-                                    Commands.argument("target", ScoreHolderArgument.scoreHolder())
-                                        .suggests(ScoreHolderArgument.SUGGEST_SCORE_HOLDERS)
-                                        .then(
-                                            Commands.argument("objective", ObjectiveArgument.objective())
-                                                .executes(
-                                                    context1 -> getScore(
-                                                        context1.getSource(),
-                                                        ScoreHolderArgument.getName(context1, "target"),
-                                                        ObjectiveArgument.getObjective(context1, "objective")
-                                                    )
-                                                )
-                                        )
-                                )
-                        )
-                        .then(
-                            Commands.literal("add")
-                                .then(
-                                    Commands.argument("targets", ScoreHolderArgument.scoreHolders())
-                                        .suggests(ScoreHolderArgument.SUGGEST_SCORE_HOLDERS)
-                                        .then(
-                                            Commands.argument("objective", ObjectiveArgument.objective())
-                                                .then(
-                                                    Commands.argument("score", IntegerArgumentType.integer(0))
-                                                        .executes(
-                                                            context1 -> addScore(
-                                                                context1.getSource(),
-                                                                ScoreHolderArgument.getNamesWithDefaultWildcard(context1, "targets"),
-                                                                ObjectiveArgument.getWritableObjective(context1, "objective"),
-                                                                IntegerArgumentType.getInteger(context1, "score")
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                        .then(
-                            Commands.literal("remove")
-                                .then(
-                                    Commands.argument("targets", ScoreHolderArgument.scoreHolders())
-                                        .suggests(ScoreHolderArgument.SUGGEST_SCORE_HOLDERS)
-                                        .then(
-                                            Commands.argument("objective", ObjectiveArgument.objective())
-                                                .then(
-                                                    Commands.argument("score", IntegerArgumentType.integer(0))
-                                                        .executes(
-                                                            context1 -> removeScore(
-                                                                context1.getSource(),
-                                                                ScoreHolderArgument.getNamesWithDefaultWildcard(context1, "targets"),
-                                                                ObjectiveArgument.getWritableObjective(context1, "objective"),
-                                                                IntegerArgumentType.getInteger(context1, "score")
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                        .then(
-                            Commands.literal("reset")
-                                .then(
-                                    Commands.argument("targets", ScoreHolderArgument.scoreHolders())
-                                        .suggests(ScoreHolderArgument.SUGGEST_SCORE_HOLDERS)
-                                        .executes(
-                                            commandContext -> resetScores(
-                                                commandContext.getSource(), ScoreHolderArgument.getNamesWithDefaultWildcard(commandContext, "targets")
-                                            )
-                                        )
-                                        .then(
-                                            Commands.argument("objective", ObjectiveArgument.objective())
-                                                .executes(
-                                                    context1 -> resetScore(
-                                                        context1.getSource(),
-                                                        ScoreHolderArgument.getNamesWithDefaultWildcard(context1, "targets"),
-                                                        ObjectiveArgument.getObjective(context1, "objective")
-                                                    )
-                                                )
-                                        )
-                                )
-                        )
-                        .then(
-                            Commands.literal("enable")
-                                .then(
-                                    Commands.argument("targets", ScoreHolderArgument.scoreHolders())
-                                        .suggests(ScoreHolderArgument.SUGGEST_SCORE_HOLDERS)
-                                        .then(
-                                            Commands.argument("objective", ObjectiveArgument.objective())
-                                                .suggests(
-                                                    (commandContext, suggestionsBuilder) -> suggestTriggers(
-                                                        commandContext.getSource(),
-                                                        ScoreHolderArgument.getNamesWithDefaultWildcard(commandContext, "targets"),
-                                                        suggestionsBuilder
-                                                    )
-                                                )
-                                                .executes(
-                                                    commandContext -> enableTrigger(
-                                                        commandContext.getSource(),
-                                                        ScoreHolderArgument.getNamesWithDefaultWildcard(commandContext, "targets"),
-                                                        ObjectiveArgument.getObjective(commandContext, "objective")
-                                                    )
-                                                )
-                                        )
-                                )
-                        )
-                        .then(
-                            Commands.literal("display")
-                                .then(
-                                    Commands.literal("name")
-                                        .then(
-                                            Commands.argument("targets", ScoreHolderArgument.scoreHolders())
-                                                .suggests(ScoreHolderArgument.SUGGEST_SCORE_HOLDERS)
-                                                .then(
-                                                    Commands.argument("objective", ObjectiveArgument.objective())
-                                                        .then(
-                                                            Commands.argument("name", ComponentArgument.textComponent(context))
-                                                                .executes(
-                                                                    commandContext -> setScoreDisplay(
-                                                                        commandContext.getSource(),
-                                                                        ScoreHolderArgument.getNamesWithDefaultWildcard(commandContext, "targets"),
-                                                                        ObjectiveArgument.getObjective(commandContext, "objective"),
-                                                                        ComponentArgument.getComponent(commandContext, "name")
-                                                                    )
-                                                                )
-                                                        )
-                                                        .executes(
-                                                            commandContext -> setScoreDisplay(
-                                                                commandContext.getSource(),
-                                                                ScoreHolderArgument.getNamesWithDefaultWildcard(commandContext, "targets"),
-                                                                ObjectiveArgument.getObjective(commandContext, "objective"),
-                                                                null
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("numberformat")
-                                        .then(
-                                            Commands.argument("targets", ScoreHolderArgument.scoreHolders())
-                                                .suggests(ScoreHolderArgument.SUGGEST_SCORE_HOLDERS)
-                                                .then(
-                                                    addNumberFormats(
-                                                        context,
-                                                        Commands.argument("objective", ObjectiveArgument.objective()),
-                                                        (context1, format) -> setScoreNumberFormat(
-                                                            context1.getSource(),
-                                                            ScoreHolderArgument.getNamesWithDefaultWildcard(context1, "targets"),
-                                                            ObjectiveArgument.getObjective(context1, "objective"),
-                                                            format
-                                                        )
-                                                    )
-                                                )
-                                        )
-                                )
-                        )
-                        .then(
-                            Commands.literal("operation")
-                                .then(
-                                    Commands.argument("targets", ScoreHolderArgument.scoreHolders())
-                                        .suggests(ScoreHolderArgument.SUGGEST_SCORE_HOLDERS)
-                                        .then(
-                                            Commands.argument("targetObjective", ObjectiveArgument.objective())
-                                                .then(
-                                                    Commands.argument("operation", OperationArgument.operation())
-                                                        .then(
-                                                            Commands.argument("source", ScoreHolderArgument.scoreHolders())
-                                                                .suggests(ScoreHolderArgument.SUGGEST_SCORE_HOLDERS)
-                                                                .then(
-                                                                    Commands.argument("sourceObjective", ObjectiveArgument.objective())
-                                                                        .executes(
-                                                                            commandContext -> performOperation(
-                                                                                commandContext.getSource(),
-                                                                                ScoreHolderArgument.getNamesWithDefaultWildcard(commandContext, "targets"),
-                                                                                ObjectiveArgument.getWritableObjective(commandContext, "targetObjective"),
-                                                                                OperationArgument.getOperation(commandContext, "operation"),
-                                                                                ScoreHolderArgument.getNamesWithDefaultWildcard(commandContext, "source"),
-                                                                                ObjectiveArgument.getObjective(commandContext, "sourceObjective")
-                                                                            )
-                                                                        )
-                                                                )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static ArgumentBuilder<CommandSourceStack, ?> addNumberFormats(
-        CommandBuildContext context, ArgumentBuilder<CommandSourceStack, ?> argumentBuilder, ScoreboardCommand.NumberFormatCommandExecutor executor
-    ) {
-        return argumentBuilder.then(Commands.literal("blank").executes(commandContext -> executor.run(commandContext, BlankFormat.INSTANCE)))
-            .then(Commands.literal("fixed").then(Commands.argument("contents", ComponentArgument.textComponent(context)).executes(commandContext -> {
-                Component component = ComponentArgument.getComponent(commandContext, "contents");
-                return executor.run(commandContext, new FixedFormat(component));
-            })))
-            .then(Commands.literal("styled").then(Commands.argument("style", StyleArgument.style(context)).executes(commandContext -> {
-                Style style = StyleArgument.getStyle(commandContext, "style");
-                return executor.run(commandContext, new StyledFormat(style));
-            })))
-            .executes(commandContext -> executor.run(commandContext, null));
-    }
-
-    private static LiteralArgumentBuilder<CommandSourceStack> createRenderTypeModify() {
-        LiteralArgumentBuilder<CommandSourceStack> literalArgumentBuilder = Commands.literal("rendertype");
-
-        for (ObjectiveCriteria.RenderType renderType : ObjectiveCriteria.RenderType.values()) {
-            literalArgumentBuilder.then(
-                Commands.literal(renderType.getId())
-                    .executes(
-                        commandContext -> setRenderType(commandContext.getSource(), ObjectiveArgument.getObjective(commandContext, "objective"), renderType)
-                    )
-            );
-        }
-
-        return literalArgumentBuilder;
-    }
-
-    private static CompletableFuture<Suggestions> suggestTriggers(CommandSourceStack source, Collection<ScoreHolder> targets, SuggestionsBuilder suggestions) {
-        List<String> list = Lists.newArrayList();
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-
-        for (Objective objective : scoreboard.getObjectives()) {
-            if (objective.getCriteria() == ObjectiveCriteria.TRIGGER) {
-                boolean flag = false;
-
-                for (ScoreHolder scoreHolder : targets) {
-                    ReadOnlyScoreInfo playerScoreInfo = scoreboard.getPlayerScoreInfo(scoreHolder, objective);
-                    if (playerScoreInfo == null || playerScoreInfo.isLocked()) {
-                        flag = true;
-                        break;
-                    }
-                }
-
-                if (flag) {
-                    list.add(objective.getName());
-                }
-            }
-        }
-
-        return SharedSuggestionProvider.suggest(list, suggestions);
-    }
-
-    private static int getScore(CommandSourceStack source, ScoreHolder scoreHolder, Objective objective) throws CommandSyntaxException {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-        ReadOnlyScoreInfo playerScoreInfo = scoreboard.getPlayerScoreInfo(scoreHolder, objective);
-        if (playerScoreInfo == null) {
-            throw ERROR_NO_VALUE.create(objective.getName(), scoreHolder.getFeedbackDisplayName());
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.scoreboard.players.get.success",
-                    scoreHolder.getFeedbackDisplayName(),
-                    playerScoreInfo.value(),
-                    objective.getFormattedDisplayName()
-                ),
-                false
-            );
-            return playerScoreInfo.value();
-        }
-    }
-
-    private static Component getFirstTargetName(Collection<ScoreHolder> scores) {
-        return scores.iterator().next().getFeedbackDisplayName();
-    }
-
-    private static int performOperation(
-        CommandSourceStack source,
-        Collection<ScoreHolder> targets,
-        Objective targetObjectives,
-        OperationArgument.Operation operation,
-        Collection<ScoreHolder> sourceEntities,
-        Objective sourceObjective
-    ) throws CommandSyntaxException {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-        int i = 0;
-
-        for (ScoreHolder scoreHolder : targets) {
-            ScoreAccess playerScore = scoreboard.getOrCreatePlayerScore(scoreHolder, targetObjectives);
-
-            for (ScoreHolder scoreHolder1 : sourceEntities) {
-                ScoreAccess playerScore1 = scoreboard.getOrCreatePlayerScore(scoreHolder1, sourceObjective);
-                operation.apply(playerScore, playerScore1);
-            }
-
-            i += playerScore.get();
-        }
-
-        if (targets.size() == 1) {
-            int i1 = i;
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.scoreboard.players.operation.success.single", targetObjectives.getFormattedDisplayName(), getFirstTargetName(targets), i1
-                ),
-                true
-            );
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.scoreboard.players.operation.success.multiple", targetObjectives.getFormattedDisplayName(), targets.size()
-                ),
-                true
-            );
-        }
-
-        return i;
-    }
-
-    private static int enableTrigger(CommandSourceStack source, Collection<ScoreHolder> targets, Objective objective) throws CommandSyntaxException {
-        if (objective.getCriteria() != ObjectiveCriteria.TRIGGER) {
-            throw ERROR_NOT_TRIGGER.create();
-        } else {
-            Scoreboard scoreboard = source.getServer().getScoreboard();
-            int i = 0;
-
-            for (ScoreHolder scoreHolder : targets) {
-                ScoreAccess playerScore = scoreboard.getOrCreatePlayerScore(scoreHolder, objective);
-                if (playerScore.locked()) {
-                    playerScore.unlock();
-                    i++;
-                }
-            }
-
-            if (i == 0) {
-                throw ERROR_TRIGGER_ALREADY_ENABLED.create();
-            } else {
-                if (targets.size() == 1) {
-                    source.sendSuccess(
-                        () -> Component.translatable(
-                            "commands.scoreboard.players.enable.success.single", objective.getFormattedDisplayName(), getFirstTargetName(targets)
-                        ),
-                        true
-                    );
-                } else {
-                    source.sendSuccess(
-                        () -> Component.translatable("commands.scoreboard.players.enable.success.multiple", objective.getFormattedDisplayName(), targets.size()),
-                        true
-                    );
-                }
-
-                return i;
-            }
-        }
-    }
-
-    private static int resetScores(CommandSourceStack source, Collection<ScoreHolder> targets) {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-
-        for (ScoreHolder scoreHolder : targets) {
-            scoreboard.resetAllPlayerScores(scoreHolder);
-        }
-
-        if (targets.size() == 1) {
-            source.sendSuccess(() -> Component.translatable("commands.scoreboard.players.reset.all.single", getFirstTargetName(targets)), true);
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.scoreboard.players.reset.all.multiple", targets.size()), true);
-        }
-
-        return targets.size();
-    }
-
-    private static int resetScore(CommandSourceStack source, Collection<ScoreHolder> targets, Objective objective) {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-
-        for (ScoreHolder scoreHolder : targets) {
-            scoreboard.resetSinglePlayerScore(scoreHolder, objective);
-        }
-
-        if (targets.size() == 1) {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.scoreboard.players.reset.specific.single", objective.getFormattedDisplayName(), getFirstTargetName(targets)
-                ),
-                true
-            );
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable("commands.scoreboard.players.reset.specific.multiple", objective.getFormattedDisplayName(), targets.size()), true
-            );
-        }
-
-        return targets.size();
-    }
-
-    private static int setScore(CommandSourceStack source, Collection<ScoreHolder> targets, Objective objective, int newValue) {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-
-        for (ScoreHolder scoreHolder : targets) {
-            scoreboard.getOrCreatePlayerScore(scoreHolder, objective).set(newValue);
-        }
-
-        if (targets.size() == 1) {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.scoreboard.players.set.success.single", objective.getFormattedDisplayName(), getFirstTargetName(targets), newValue
-                ),
-                true
-            );
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable("commands.scoreboard.players.set.success.multiple", objective.getFormattedDisplayName(), targets.size(), newValue),
-                true
-            );
-        }
-
-        return newValue * targets.size();
-    }
-
-    private static int setScoreDisplay(CommandSourceStack source, Collection<ScoreHolder> targets, Objective objective, @Nullable Component displayName) {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-
-        for (ScoreHolder scoreHolder : targets) {
-            scoreboard.getOrCreatePlayerScore(scoreHolder, objective).display(displayName);
-        }
-
-        if (displayName == null) {
-            if (targets.size() == 1) {
-                source.sendSuccess(
-                    () -> Component.translatable(
-                        "commands.scoreboard.players.display.name.clear.success.single", getFirstTargetName(targets), objective.getFormattedDisplayName()
-                    ),
-                    true
-                );
-            } else {
-                source.sendSuccess(
-                    () -> Component.translatable(
-                        "commands.scoreboard.players.display.name.clear.success.multiple", targets.size(), objective.getFormattedDisplayName()
-                    ),
-                    true
-                );
-            }
-        } else if (targets.size() == 1) {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.scoreboard.players.display.name.set.success.single",
-                    displayName,
-                    getFirstTargetName(targets),
-                    objective.getFormattedDisplayName()
-                ),
-                true
-            );
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.scoreboard.players.display.name.set.success.multiple", displayName, targets.size(), objective.getFormattedDisplayName()
-                ),
-                true
-            );
-        }
-
-        return targets.size();
-    }
-
-    private static int setScoreNumberFormat(
-        CommandSourceStack source, Collection<ScoreHolder> targets, Objective objective, @Nullable NumberFormat numberFormat
-    ) {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-
-        for (ScoreHolder scoreHolder : targets) {
-            scoreboard.getOrCreatePlayerScore(scoreHolder, objective).numberFormatOverride(numberFormat);
-        }
-
-        if (numberFormat == null) {
-            if (targets.size() == 1) {
-                source.sendSuccess(
-                    () -> Component.translatable(
-                        "commands.scoreboard.players.display.numberFormat.clear.success.single",
-                        getFirstTargetName(targets),
-                        objective.getFormattedDisplayName()
-                    ),
-                    true
-                );
-            } else {
-                source.sendSuccess(
-                    () -> Component.translatable(
-                        "commands.scoreboard.players.display.numberFormat.clear.success.multiple", targets.size(), objective.getFormattedDisplayName()
-                    ),
-                    true
-                );
-            }
-        } else if (targets.size() == 1) {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.scoreboard.players.display.numberFormat.set.success.single", getFirstTargetName(targets), objective.getFormattedDisplayName()
-                ),
-                true
-            );
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.scoreboard.players.display.numberFormat.set.success.multiple", targets.size(), objective.getFormattedDisplayName()
-                ),
-                true
-            );
-        }
-
-        return targets.size();
-    }
-
-    private static int addScore(CommandSourceStack source, Collection<ScoreHolder> targets, Objective objective, int amount) {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-        int i = 0;
-
-        for (ScoreHolder scoreHolder : targets) {
-            ScoreAccess playerScore = scoreboard.getOrCreatePlayerScore(scoreHolder, objective);
-            playerScore.set(playerScore.get() + amount);
-            i += playerScore.get();
-        }
-
-        if (targets.size() == 1) {
-            int i1 = i;
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.scoreboard.players.add.success.single", amount, objective.getFormattedDisplayName(), getFirstTargetName(targets), i1
-                ),
-                true
-            );
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable("commands.scoreboard.players.add.success.multiple", amount, objective.getFormattedDisplayName(), targets.size()),
-                true
-            );
-        }
-
-        return i;
-    }
-
-    private static int removeScore(CommandSourceStack source, Collection<ScoreHolder> targets, Objective objective, int amount) {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-        int i = 0;
-
-        for (ScoreHolder scoreHolder : targets) {
-            ScoreAccess playerScore = scoreboard.getOrCreatePlayerScore(scoreHolder, objective);
-            playerScore.set(playerScore.get() - amount);
-            i += playerScore.get();
-        }
-
-        if (targets.size() == 1) {
-            int i1 = i;
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.scoreboard.players.remove.success.single", amount, objective.getFormattedDisplayName(), getFirstTargetName(targets), i1
-                ),
-                true
-            );
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable("commands.scoreboard.players.remove.success.multiple", amount, objective.getFormattedDisplayName(), targets.size()),
-                true
-            );
-        }
-
-        return i;
-    }
-
-    private static int listTrackedPlayers(CommandSourceStack source) {
-        Collection<ScoreHolder> trackedPlayers = source.getServer().getScoreboard().getTrackedPlayers();
-        if (trackedPlayers.isEmpty()) {
-            source.sendSuccess(() -> Component.translatable("commands.scoreboard.players.list.empty"), false);
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.scoreboard.players.list.success",
-                    trackedPlayers.size(),
-                    ComponentUtils.formatList(trackedPlayers, ScoreHolder::getFeedbackDisplayName)
-                ),
-                false
-            );
-        }
-
-        return trackedPlayers.size();
-    }
-
-    private static int listTrackedPlayerScores(CommandSourceStack source, ScoreHolder score) {
-        Object2IntMap<Objective> map = source.getServer().getScoreboard().listPlayerScores(score);
-        if (map.isEmpty()) {
-            source.sendSuccess(() -> Component.translatable("commands.scoreboard.players.list.entity.empty", score.getFeedbackDisplayName()), false);
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable("commands.scoreboard.players.list.entity.success", score.getFeedbackDisplayName(), map.size()), false
-            );
-            Object2IntMaps.fastForEach(
-                map,
-                entry -> source.sendSuccess(
-                    () -> Component.translatable(
-                        "commands.scoreboard.players.list.entity.entry", ((Objective)entry.getKey()).getFormattedDisplayName(), entry.getIntValue()
-                    ),
-                    false
-                )
-            );
-        }
-
-        return map.size();
-    }
-
-    private static int clearDisplaySlot(CommandSourceStack source, DisplaySlot slot) throws CommandSyntaxException {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-        if (scoreboard.getDisplayObjective(slot) == null) {
-            throw ERROR_DISPLAY_SLOT_ALREADY_EMPTY.create();
-        } else {
-            scoreboard.setDisplayObjective(slot, null);
-            source.sendSuccess(() -> Component.translatable("commands.scoreboard.objectives.display.cleared", slot.getSerializedName()), true);
-            return 0;
-        }
-    }
-
-    private static int setDisplaySlot(CommandSourceStack source, DisplaySlot slot, Objective objective) throws CommandSyntaxException {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-        if (scoreboard.getDisplayObjective(slot) == objective) {
-            throw ERROR_DISPLAY_SLOT_ALREADY_SET.create();
-        } else {
-            scoreboard.setDisplayObjective(slot, objective);
-            source.sendSuccess(
-                () -> Component.translatable("commands.scoreboard.objectives.display.set", slot.getSerializedName(), objective.getDisplayName()), true
-            );
-            return 0;
-        }
-    }
-
-    private static int setDisplayName(CommandSourceStack source, Objective objective, Component displayName) {
-        if (!objective.getDisplayName().equals(displayName)) {
-            objective.setDisplayName(displayName);
-            source.sendSuccess(
-                () -> Component.translatable("commands.scoreboard.objectives.modify.displayname", objective.getName(), objective.getFormattedDisplayName()),
-                true
-            );
-        }
-
-        return 0;
-    }
-
-    private static int setDisplayAutoUpdate(CommandSourceStack source, Objective objective, boolean displayAutoUpdate) {
-        if (objective.displayAutoUpdate() != displayAutoUpdate) {
-            objective.setDisplayAutoUpdate(displayAutoUpdate);
-            if (displayAutoUpdate) {
-                source.sendSuccess(
-                    () -> Component.translatable(
-                        "commands.scoreboard.objectives.modify.displayAutoUpdate.enable", objective.getName(), objective.getFormattedDisplayName()
-                    ),
-                    true
-                );
-            } else {
-                source.sendSuccess(
-                    () -> Component.translatable(
-                        "commands.scoreboard.objectives.modify.displayAutoUpdate.disable", objective.getName(), objective.getFormattedDisplayName()
-                    ),
-                    true
-                );
-            }
-        }
-
-        return 0;
-    }
-
-    private static int setObjectiveFormat(CommandSourceStack source, Objective objective, @Nullable NumberFormat format) {
-        objective.setNumberFormat(format);
-        if (format != null) {
-            source.sendSuccess(() -> Component.translatable("commands.scoreboard.objectives.modify.objectiveFormat.set", objective.getName()), true);
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.scoreboard.objectives.modify.objectiveFormat.clear", objective.getName()), true);
-        }
-
-        return 0;
-    }
-
-    private static int setRenderType(CommandSourceStack source, Objective objective, ObjectiveCriteria.RenderType renderType) {
-        if (objective.getRenderType() != renderType) {
-            objective.setRenderType(renderType);
-            source.sendSuccess(() -> Component.translatable("commands.scoreboard.objectives.modify.rendertype", objective.getFormattedDisplayName()), true);
-        }
-
-        return 0;
-    }
-
-    private static int removeObjective(CommandSourceStack source, Objective objective) {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-        scoreboard.removeObjective(objective);
-        source.sendSuccess(() -> Component.translatable("commands.scoreboard.objectives.remove.success", objective.getFormattedDisplayName()), true);
-        return scoreboard.getObjectives().size();
-    }
-
-    private static int addObjective(CommandSourceStack source, String name, ObjectiveCriteria criteria, Component displayName) throws CommandSyntaxException {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-        if (scoreboard.getObjective(name) != null) {
-            throw ERROR_OBJECTIVE_ALREADY_EXISTS.create();
-        } else {
-            scoreboard.addObjective(name, criteria, displayName, criteria.getDefaultRenderType(), false, null);
-            Objective objective = scoreboard.getObjective(name);
-            source.sendSuccess(() -> Component.translatable("commands.scoreboard.objectives.add.success", objective.getFormattedDisplayName()), true);
-            return scoreboard.getObjectives().size();
-        }
-    }
-
-    private static int listObjectives(CommandSourceStack source) {
-        Collection<Objective> objectives = source.getServer().getScoreboard().getObjectives();
-        if (objectives.isEmpty()) {
-            source.sendSuccess(() -> Component.translatable("commands.scoreboard.objectives.list.empty"), false);
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.scoreboard.objectives.list.success", objectives.size(), ComponentUtils.formatList(objectives, Objective::getFormattedDisplayName)
-                ),
-                false
-            );
-        }
-
-        return objectives.size();
-    }
-
-    @FunctionalInterface
-    public interface NumberFormatCommandExecutor {
-        int run(CommandContext<CommandSourceStack> context, @Nullable NumberFormat format) throws CommandSyntaxException;
-    }
-}
diff --git a/net/minecraft/server/commands/SeedCommand.java b/net/minecraft/server/commands/SeedCommand.java
deleted file mode 100644
index a65affc41a4fc299bc2281f0f53f2e075633899d..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/SeedCommand.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.ComponentUtils;
-
-public class SeedCommand {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, boolean notIntegratedServer) {
-        dispatcher.register(Commands.literal("seed").requires(source -> !notIntegratedServer || source.hasPermission(2)).executes(context -> {
-            long seed = context.getSource().getLevel().getSeed();
-            Component component = ComponentUtils.copyOnClickText(String.valueOf(seed));
-            context.getSource().sendSuccess(() -> Component.translatable("commands.seed.success", component), false);
-            return (int)seed;
-        }));
-    }
-}
diff --git a/net/minecraft/server/commands/ServerPackCommand.java b/net/minecraft/server/commands/ServerPackCommand.java
deleted file mode 100644
index 2ac1ddbf8cdc04a534ffa00548a22e38861e3638..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/ServerPackCommand.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.StringArgumentType;
-import java.nio.charset.StandardCharsets;
-import java.util.Optional;
-import java.util.UUID;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.UuidArgument;
-import net.minecraft.network.protocol.Packet;
-import net.minecraft.network.protocol.common.ClientboundResourcePackPopPacket;
-import net.minecraft.network.protocol.common.ClientboundResourcePackPushPacket;
-
-public class ServerPackCommand {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("serverpack")
-                .requires(commandSourceStack -> commandSourceStack.hasPermission(2))
-                .then(
-                    Commands.literal("push")
-                        .then(
-                            Commands.argument("url", StringArgumentType.string())
-                                .then(
-                                    Commands.argument("uuid", UuidArgument.uuid())
-                                        .then(
-                                            Commands.argument("hash", StringArgumentType.word())
-                                                .executes(
-                                                    commandContext -> pushPack(
-                                                        commandContext.getSource(),
-                                                        StringArgumentType.getString(commandContext, "url"),
-                                                        Optional.of(UuidArgument.getUuid(commandContext, "uuid")),
-                                                        Optional.of(StringArgumentType.getString(commandContext, "hash"))
-                                                    )
-                                                )
-                                        )
-                                        .executes(
-                                            commandContext -> pushPack(
-                                                commandContext.getSource(),
-                                                StringArgumentType.getString(commandContext, "url"),
-                                                Optional.of(UuidArgument.getUuid(commandContext, "uuid")),
-                                                Optional.empty()
-                                            )
-                                        )
-                                )
-                                .executes(
-                                    commandContext -> pushPack(
-                                        commandContext.getSource(), StringArgumentType.getString(commandContext, "url"), Optional.empty(), Optional.empty()
-                                    )
-                                )
-                        )
-                )
-                .then(
-                    Commands.literal("pop")
-                        .then(
-                            Commands.argument("uuid", UuidArgument.uuid())
-                                .executes(commandContext -> popPack(commandContext.getSource(), UuidArgument.getUuid(commandContext, "uuid")))
-                        )
-                )
-        );
-    }
-
-    private static void sendToAllConnections(CommandSourceStack source, Packet<?> packet) {
-        source.getServer().getConnection().getConnections().forEach(connection -> connection.send(packet));
-    }
-
-    private static int pushPack(CommandSourceStack source, String url, Optional<UUID> uuid, Optional<String> hash) {
-        UUID uuid1 = uuid.orElseGet(() -> UUID.nameUUIDFromBytes(url.getBytes(StandardCharsets.UTF_8)));
-        String string = hash.orElse("");
-        ClientboundResourcePackPushPacket clientboundResourcePackPushPacket = new ClientboundResourcePackPushPacket(uuid1, url, string, false, null);
-        sendToAllConnections(source, clientboundResourcePackPushPacket);
-        return 0;
-    }
-
-    private static int popPack(CommandSourceStack source, UUID uuid) {
-        ClientboundResourcePackPopPacket clientboundResourcePackPopPacket = new ClientboundResourcePackPopPacket(Optional.of(uuid));
-        sendToAllConnections(source, clientboundResourcePackPopPacket);
-        return 0;
-    }
-}
diff --git a/net/minecraft/server/commands/SetBlockCommand.java b/net/minecraft/server/commands/SetBlockCommand.java
deleted file mode 100644
index 8b72116b80da0497e255ce5a3f3c7bccb6321aec..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/SetBlockCommand.java
+++ /dev/null
@@ -1,119 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import java.util.function.Predicate;
-import javax.annotation.Nullable;
-import net.minecraft.commands.CommandBuildContext;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.blocks.BlockInput;
-import net.minecraft.commands.arguments.blocks.BlockStateArgument;
-import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
-import net.minecraft.core.BlockPos;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.world.Clearable;
-import net.minecraft.world.level.block.entity.BlockEntity;
-import net.minecraft.world.level.block.state.pattern.BlockInWorld;
-import net.minecraft.world.level.levelgen.structure.BoundingBox;
-
-public class SetBlockCommand {
-    private static final SimpleCommandExceptionType ERROR_FAILED = new SimpleCommandExceptionType(Component.translatable("commands.setblock.failed"));
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext context) {
-        dispatcher.register(
-            Commands.literal("setblock")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.argument("pos", BlockPosArgument.blockPos())
-                        .then(
-                            Commands.argument("block", BlockStateArgument.block(context))
-                                .executes(
-                                    context1 -> setBlock(
-                                        context1.getSource(),
-                                        BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                        BlockStateArgument.getBlock(context1, "block"),
-                                        SetBlockCommand.Mode.REPLACE,
-                                        null
-                                    )
-                                )
-                                .then(
-                                    Commands.literal("destroy")
-                                        .executes(
-                                            context1 -> setBlock(
-                                                context1.getSource(),
-                                                BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                                BlockStateArgument.getBlock(context1, "block"),
-                                                SetBlockCommand.Mode.DESTROY,
-                                                null
-                                            )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("keep")
-                                        .executes(
-                                            context1 -> setBlock(
-                                                context1.getSource(),
-                                                BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                                BlockStateArgument.getBlock(context1, "block"),
-                                                SetBlockCommand.Mode.REPLACE,
-                                                pos -> pos.getLevel().isEmptyBlock(pos.getPos())
-                                            )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("replace")
-                                        .executes(
-                                            context1 -> setBlock(
-                                                context1.getSource(),
-                                                BlockPosArgument.getLoadedBlockPos(context1, "pos"),
-                                                BlockStateArgument.getBlock(context1, "block"),
-                                                SetBlockCommand.Mode.REPLACE,
-                                                null
-                                            )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int setBlock(
-        CommandSourceStack source, BlockPos pos, BlockInput state, SetBlockCommand.Mode mode, @Nullable Predicate<BlockInWorld> predicate
-    ) throws CommandSyntaxException {
-        ServerLevel level = source.getLevel();
-        if (predicate != null && !predicate.test(new BlockInWorld(level, pos, true))) {
-            throw ERROR_FAILED.create();
-        } else {
-            boolean flag;
-            if (mode == SetBlockCommand.Mode.DESTROY) {
-                level.destroyBlock(pos, true);
-                flag = !state.getState().isAir() || !level.getBlockState(pos).isAir();
-            } else {
-                BlockEntity blockEntity = level.getBlockEntity(pos);
-                Clearable.tryClear(blockEntity);
-                flag = true;
-            }
-
-            if (flag && !state.place(level, pos, 2)) {
-                throw ERROR_FAILED.create();
-            } else {
-                level.blockUpdated(pos, state.getState().getBlock());
-                source.sendSuccess(() -> Component.translatable("commands.setblock.success", pos.getX(), pos.getY(), pos.getZ()), true);
-                return 1;
-            }
-        }
-    }
-
-    public interface Filter {
-        @Nullable
-        BlockInput filter(BoundingBox boundingBox, BlockPos pos, BlockInput blockInput, ServerLevel level);
-    }
-
-    public static enum Mode {
-        REPLACE,
-        DESTROY;
-    }
-}
diff --git a/net/minecraft/server/commands/SetPlayerIdleTimeoutCommand.java b/net/minecraft/server/commands/SetPlayerIdleTimeoutCommand.java
deleted file mode 100644
index 18663b335ef0e298f8afdef2841c3b815c1fc60c..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/SetPlayerIdleTimeoutCommand.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.network.chat.Component;
-
-public class SetPlayerIdleTimeoutCommand {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("setidletimeout")
-                .requires(source -> source.hasPermission(3))
-                .then(
-                    Commands.argument("minutes", IntegerArgumentType.integer(0))
-                        .executes(context -> setIdleTimeout(context.getSource(), IntegerArgumentType.getInteger(context, "minutes")))
-                )
-        );
-    }
-
-    private static int setIdleTimeout(CommandSourceStack source, int idleTimeout) {
-        source.getServer().setPlayerIdleTimeout(idleTimeout);
-        if (idleTimeout > 0) {
-            source.sendSuccess(() -> Component.translatable("commands.setidletimeout.success", idleTimeout), true);
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.setidletimeout.success.disabled"), true);
-        }
-
-        return idleTimeout;
-    }
-}
diff --git a/net/minecraft/server/commands/SetSpawnCommand.java b/net/minecraft/server/commands/SetSpawnCommand.java
deleted file mode 100644
index e38c7f012098e46337561b2225b31a7097495647..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/SetSpawnCommand.java
+++ /dev/null
@@ -1,99 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import java.util.Collection;
-import java.util.Collections;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.AngleArgument;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
-import net.minecraft.core.BlockPos;
-import net.minecraft.network.chat.Component;
-import net.minecraft.resources.ResourceKey;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.world.level.Level;
-
-public class SetSpawnCommand {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("spawnpoint")
-                .requires(source -> source.hasPermission(2))
-                .executes(
-                    context -> setSpawn(
-                        context.getSource(),
-                        Collections.singleton(context.getSource().getPlayerOrException()),
-                        BlockPos.containing(context.getSource().getPosition()),
-                        0.0F
-                    )
-                )
-                .then(
-                    Commands.argument("targets", EntityArgument.players())
-                        .executes(
-                            context -> setSpawn(
-                                context.getSource(),
-                                EntityArgument.getPlayers(context, "targets"),
-                                BlockPos.containing(context.getSource().getPosition()),
-                                0.0F
-                            )
-                        )
-                        .then(
-                            Commands.argument("pos", BlockPosArgument.blockPos())
-                                .executes(
-                                    context -> setSpawn(
-                                        context.getSource(),
-                                        EntityArgument.getPlayers(context, "targets"),
-                                        BlockPosArgument.getSpawnablePos(context, "pos"),
-                                        0.0F
-                                    )
-                                )
-                                .then(
-                                    Commands.argument("angle", AngleArgument.angle())
-                                        .executes(
-                                            context -> setSpawn(
-                                                context.getSource(),
-                                                EntityArgument.getPlayers(context, "targets"),
-                                                BlockPosArgument.getSpawnablePos(context, "pos"),
-                                                AngleArgument.getAngle(context, "angle")
-                                            )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int setSpawn(CommandSourceStack source, Collection<ServerPlayer> targets, BlockPos pos, float angle) {
-        ResourceKey<Level> resourceKey = source.getLevel().dimension();
-
-        final Collection<ServerPlayer> actualTargets = new java.util.ArrayList<>(); // Paper - Add PlayerSetSpawnEvent
-        for (ServerPlayer serverPlayer : targets) {
-            // Paper start - Add PlayerSetSpawnEvent
-            if (serverPlayer.setRespawnPosition(resourceKey, pos, angle, true, false, com.destroystokyo.paper.event.player.PlayerSetSpawnEvent.Cause.COMMAND)) {
-                actualTargets.add(serverPlayer);
-            }
-            // Paper end - Add PlayerSetSpawnEvent
-        }
-        // Paper start - Add PlayerSetSpawnEvent
-        if (actualTargets.isEmpty()) {
-            return 0;
-        }
-        // Paper end - Add PlayerSetSpawnEvent
-
-        String string = resourceKey.location().toString();
-        if (actualTargets.size() == 1) { // Paper - Add PlayerSetSpawnEvent
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.spawnpoint.success.single", pos.getX(), pos.getY(), pos.getZ(), angle, string, actualTargets.iterator().next().getDisplayName() // Paper - Add PlayerSetSpawnEvent
-                ),
-                true
-            );
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable("commands.spawnpoint.success.multiple", pos.getX(), pos.getY(), pos.getZ(), angle, string, actualTargets.size()), true // Paper - Add PlayerSetSpawnEvent
-            );
-        }
-
-        return actualTargets.size(); // Paper - Add PlayerSetSpawnEvent
-    }
-}
diff --git a/net/minecraft/server/commands/SetWorldSpawnCommand.java b/net/minecraft/server/commands/SetWorldSpawnCommand.java
index 303ee5c3431fbbcb15046cb61719961891e9eec5..752bc9d2687748c49a39a5229b364497cb5a2c7d 100644
--- a/net/minecraft/server/commands/SetWorldSpawnCommand.java
+++ b/net/minecraft/server/commands/SetWorldSpawnCommand.java
@@ -6,9 +6,7 @@ import net.minecraft.commands.Commands;
 import net.minecraft.commands.arguments.AngleArgument;
 import net.minecraft.commands.arguments.coordinates.BlockPosArgument;
 import net.minecraft.core.BlockPos;
-import net.minecraft.network.chat.Component;
 import net.minecraft.server.level.ServerLevel;
-import net.minecraft.world.level.Level;
 
 public class SetWorldSpawnCommand {
     public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
@@ -33,13 +31,8 @@ public class SetWorldSpawnCommand {
 
     private static int setSpawn(CommandSourceStack source, BlockPos pos, float angle) {
         ServerLevel level = source.getLevel();
-        if (false && level.dimension() != Level.OVERWORLD) { // CraftBukkit - SPIGOT-7649: allow in all worlds
-            source.sendFailure(Component.translatable("commands.setworldspawn.failure.not_overworld"));
-            return 0;
-        } else {
-            level.setDefaultSpawnPos(pos, angle);
-            source.sendSuccess(() -> Component.translatable("commands.setworldspawn.success", pos.getX(), pos.getY(), pos.getZ(), angle), true);
-            return 1;
-        }
+        level.setDefaultSpawnPos(pos, angle);
+        source.sendSuccess(() -> net.minecraft.network.chat.Component.translatable("commands.setworldspawn.success", pos.getX(), pos.getY(), pos.getZ(), angle), true);
+        return 1;
     }
 }
diff --git a/net/minecraft/server/commands/SpawnArmorTrimsCommand.java b/net/minecraft/server/commands/SpawnArmorTrimsCommand.java
deleted file mode 100644
index 46612127fafd435ed5feeab71168609d801c6208..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/SpawnArmorTrimsCommand.java
+++ /dev/null
@@ -1,144 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import java.util.Comparator;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.function.ToIntFunction;
-import java.util.stream.Collectors;
-import net.minecraft.Util;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Holder;
-import net.minecraft.core.HolderLookup;
-import net.minecraft.core.NonNullList;
-import net.minecraft.core.Registry;
-import net.minecraft.core.component.DataComponents;
-import net.minecraft.core.registries.Registries;
-import net.minecraft.network.chat.Component;
-import net.minecraft.resources.ResourceKey;
-import net.minecraft.world.entity.EquipmentSlot;
-import net.minecraft.world.entity.decoration.ArmorStand;
-import net.minecraft.world.entity.player.Player;
-import net.minecraft.world.item.Item;
-import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.item.Items;
-import net.minecraft.world.item.equipment.EquipmentAsset;
-import net.minecraft.world.item.equipment.Equippable;
-import net.minecraft.world.item.equipment.trim.ArmorTrim;
-import net.minecraft.world.item.equipment.trim.TrimMaterial;
-import net.minecraft.world.item.equipment.trim.TrimMaterials;
-import net.minecraft.world.item.equipment.trim.TrimPattern;
-import net.minecraft.world.item.equipment.trim.TrimPatterns;
-import net.minecraft.world.level.Level;
-
-public class SpawnArmorTrimsCommand {
-    private static final List<ResourceKey<TrimPattern>> VANILLA_TRIM_PATTERNS = List.of(
-        TrimPatterns.SENTRY,
-        TrimPatterns.DUNE,
-        TrimPatterns.COAST,
-        TrimPatterns.WILD,
-        TrimPatterns.WARD,
-        TrimPatterns.EYE,
-        TrimPatterns.VEX,
-        TrimPatterns.TIDE,
-        TrimPatterns.SNOUT,
-        TrimPatterns.RIB,
-        TrimPatterns.SPIRE,
-        TrimPatterns.WAYFINDER,
-        TrimPatterns.SHAPER,
-        TrimPatterns.SILENCE,
-        TrimPatterns.RAISER,
-        TrimPatterns.HOST,
-        TrimPatterns.FLOW,
-        TrimPatterns.BOLT
-    );
-    private static final List<ResourceKey<TrimMaterial>> VANILLA_TRIM_MATERIALS = List.of(
-        TrimMaterials.QUARTZ,
-        TrimMaterials.IRON,
-        TrimMaterials.NETHERITE,
-        TrimMaterials.REDSTONE,
-        TrimMaterials.COPPER,
-        TrimMaterials.GOLD,
-        TrimMaterials.EMERALD,
-        TrimMaterials.DIAMOND,
-        TrimMaterials.LAPIS,
-        TrimMaterials.AMETHYST,
-        TrimMaterials.RESIN
-    );
-    private static final ToIntFunction<ResourceKey<TrimPattern>> TRIM_PATTERN_ORDER = Util.createIndexLookup(VANILLA_TRIM_PATTERNS);
-    private static final ToIntFunction<ResourceKey<TrimMaterial>> TRIM_MATERIAL_ORDER = Util.createIndexLookup(VANILLA_TRIM_MATERIALS);
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("spawn_armor_trims")
-                .requires(commandSourceStack -> commandSourceStack.hasPermission(2))
-                .executes(commandContext -> spawnArmorTrims(commandContext.getSource(), commandContext.getSource().getPlayerOrException()))
-        );
-    }
-
-    private static int spawnArmorTrims(CommandSourceStack source, Player player) {
-        Level level = player.level();
-        NonNullList<ArmorTrim> list = NonNullList.create();
-        Registry<TrimPattern> registry = level.registryAccess().lookupOrThrow(Registries.TRIM_PATTERN);
-        Registry<TrimMaterial> registry1 = level.registryAccess().lookupOrThrow(Registries.TRIM_MATERIAL);
-        HolderLookup<Item> holderLookup = level.holderLookup(Registries.ITEM);
-        Map<ResourceKey<EquipmentAsset>, List<Item>> map = holderLookup.listElements().map(Holder.Reference::value).filter(item1 -> {
-            Equippable equippable1 = item1.components().get(DataComponents.EQUIPPABLE);
-            return equippable1 != null && equippable1.slot().getType() == EquipmentSlot.Type.HUMANOID_ARMOR && equippable1.assetId().isPresent();
-        }).collect(Collectors.groupingBy(item1 -> item1.components().get(DataComponents.EQUIPPABLE).assetId().get()));
-        registry.stream()
-            .sorted(Comparator.comparing(trimPattern -> TRIM_PATTERN_ORDER.applyAsInt(registry.getResourceKey(trimPattern).orElse(null))))
-            .forEachOrdered(
-                trimPattern -> registry1.stream()
-                    .sorted(Comparator.comparing(trimMaterial -> TRIM_MATERIAL_ORDER.applyAsInt(registry1.getResourceKey(trimMaterial).orElse(null))))
-                    .forEachOrdered(trimMaterial -> list.add(new ArmorTrim(registry1.wrapAsHolder(trimMaterial), registry.wrapAsHolder(trimPattern))))
-            );
-        BlockPos blockPos = player.blockPosition().relative(player.getDirection(), 5);
-        int i = map.size() - 1;
-        double d = 3.0;
-        int i1 = 0;
-        int i2 = 0;
-
-        for (ArmorTrim armorTrim : list) {
-            for (List<Item> list1 : map.values()) {
-                double d1 = blockPos.getX() + 0.5 - i1 % registry1.size() * 3.0;
-                double d2 = blockPos.getY() + 0.5 + i2 % i * 3.0;
-                double d3 = blockPos.getZ() + 0.5 + i1 / registry1.size() * 10;
-                ArmorStand armorStand = new ArmorStand(level, d1, d2, d3);
-                armorStand.setYRot(180.0F);
-                armorStand.setNoGravity(true);
-
-                for (Item item : list1) {
-                    Equippable equippable = Objects.requireNonNull(item.components().get(DataComponents.EQUIPPABLE));
-                    ItemStack itemStack = new ItemStack(item);
-                    itemStack.set(DataComponents.TRIM, armorTrim);
-                    armorStand.setItemSlot(equippable.slot(), itemStack);
-                    if (itemStack.is(Items.TURTLE_HELMET)) {
-                        armorStand.setCustomName(
-                            armorTrim.pattern()
-                                .value()
-                                .copyWithStyle(armorTrim.material())
-                                .copy()
-                                .append(" ")
-                                .append(armorTrim.material().value().description())
-                        );
-                        armorStand.setCustomNameVisible(true);
-                    } else {
-                        armorStand.setInvisible(true);
-                    }
-                }
-
-                level.addFreshEntity(armorStand);
-                i2++;
-            }
-
-            i1++;
-        }
-
-        source.sendSuccess(() -> Component.literal("Armorstands with trimmed armor spawned around you"), true);
-        return 1;
-    }
-}
diff --git a/net/minecraft/server/commands/SpectateCommand.java b/net/minecraft/server/commands/SpectateCommand.java
deleted file mode 100644
index 951f0a3c32e7d5ad925ef7588d53481a074a00d7..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/SpectateCommand.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import javax.annotation.Nullable;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.level.GameType;
-
-public class SpectateCommand {
-    private static final SimpleCommandExceptionType ERROR_SELF = new SimpleCommandExceptionType(Component.translatable("commands.spectate.self"));
-    private static final DynamicCommandExceptionType ERROR_NOT_SPECTATOR = new DynamicCommandExceptionType(
-        player -> Component.translatableEscape("commands.spectate.not_spectator", player)
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("spectate")
-                .requires(source -> source.hasPermission(2))
-                .executes(context -> spectate(context.getSource(), null, context.getSource().getPlayerOrException()))
-                .then(
-                    Commands.argument("target", EntityArgument.entity())
-                        .executes(
-                            context -> spectate(context.getSource(), EntityArgument.getEntity(context, "target"), context.getSource().getPlayerOrException())
-                        )
-                        .then(
-                            Commands.argument("player", EntityArgument.player())
-                                .executes(
-                                    context -> spectate(
-                                        context.getSource(), EntityArgument.getEntity(context, "target"), EntityArgument.getPlayer(context, "player")
-                                    )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int spectate(CommandSourceStack source, @Nullable Entity target, ServerPlayer player) throws CommandSyntaxException {
-        if (player == target) {
-            throw ERROR_SELF.create();
-        } else if (player.gameMode.getGameModeForPlayer() != GameType.SPECTATOR) {
-            throw ERROR_NOT_SPECTATOR.create(player.getDisplayName());
-        } else {
-            player.setCamera(target);
-            if (target != null) {
-                source.sendSuccess(() -> Component.translatable("commands.spectate.success.started", target.getDisplayName()), false);
-            } else {
-                source.sendSuccess(() -> Component.translatable("commands.spectate.success.stopped"), false);
-            }
-
-            return 1;
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/SpreadPlayersCommand.java b/net/minecraft/server/commands/SpreadPlayersCommand.java
deleted file mode 100644
index d381800ad054be6b054dcca43fbe80d3f0c0c771..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/SpreadPlayersCommand.java
+++ /dev/null
@@ -1,364 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.BoolArgumentType;
-import com.mojang.brigadier.arguments.FloatArgumentType;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
-import com.mojang.brigadier.exceptions.Dynamic4CommandExceptionType;
-import java.util.Collection;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Set;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.commands.arguments.coordinates.Vec2Argument;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Direction;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.tags.BlockTags;
-import net.minecraft.util.Mth;
-import net.minecraft.util.RandomSource;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.player.Player;
-import net.minecraft.world.level.BlockGetter;
-import net.minecraft.world.level.block.state.BlockState;
-import net.minecraft.world.phys.Vec2;
-import net.minecraft.world.scores.Team;
-
-public class SpreadPlayersCommand {
-    private static final int MAX_ITERATION_COUNT = 10000;
-    private static final Dynamic4CommandExceptionType ERROR_FAILED_TO_SPREAD_TEAMS = new Dynamic4CommandExceptionType(
-        (teamCount, x, z, suggestedSpread) -> Component.translatableEscape("commands.spreadplayers.failed.teams", teamCount, x, z, suggestedSpread)
-    );
-    private static final Dynamic4CommandExceptionType ERROR_FAILED_TO_SPREAD_ENTITIES = new Dynamic4CommandExceptionType(
-        (entityCount, x, z, suggestedSpread) -> Component.translatableEscape("commands.spreadplayers.failed.entities", entityCount, x, z, suggestedSpread)
-    );
-    private static final Dynamic2CommandExceptionType ERROR_INVALID_MAX_HEIGHT = new Dynamic2CommandExceptionType(
-        (maxHeight, worldMin) -> Component.translatableEscape("commands.spreadplayers.failed.invalid.height", maxHeight, worldMin)
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("spreadplayers")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.argument("center", Vec2Argument.vec2())
-                        .then(
-                            Commands.argument("spreadDistance", FloatArgumentType.floatArg(0.0F))
-                                .then(
-                                    Commands.argument("maxRange", FloatArgumentType.floatArg(1.0F))
-                                        .then(
-                                            Commands.argument("respectTeams", BoolArgumentType.bool())
-                                                .then(
-                                                    Commands.argument("targets", EntityArgument.entities())
-                                                        .executes(
-                                                            context -> spreadPlayers(
-                                                                context.getSource(),
-                                                                Vec2Argument.getVec2(context, "center"),
-                                                                FloatArgumentType.getFloat(context, "spreadDistance"),
-                                                                FloatArgumentType.getFloat(context, "maxRange"),
-                                                                context.getSource().getLevel().getMaxY() + 1,
-                                                                BoolArgumentType.getBool(context, "respectTeams"),
-                                                                EntityArgument.getEntities(context, "targets")
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.literal("under")
-                                                .then(
-                                                    Commands.argument("maxHeight", IntegerArgumentType.integer())
-                                                        .then(
-                                                            Commands.argument("respectTeams", BoolArgumentType.bool())
-                                                                .then(
-                                                                    Commands.argument("targets", EntityArgument.entities())
-                                                                        .executes(
-                                                                            context -> spreadPlayers(
-                                                                                context.getSource(),
-                                                                                Vec2Argument.getVec2(context, "center"),
-                                                                                FloatArgumentType.getFloat(context, "spreadDistance"),
-                                                                                FloatArgumentType.getFloat(context, "maxRange"),
-                                                                                IntegerArgumentType.getInteger(context, "maxHeight"),
-                                                                                BoolArgumentType.getBool(context, "respectTeams"),
-                                                                                EntityArgument.getEntities(context, "targets")
-                                                                            )
-                                                                        )
-                                                                )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int spreadPlayers(
-        CommandSourceStack source, Vec2 center, float spreadDistance, float maxRange, int maxHeight, boolean respectTeams, Collection<? extends Entity> targets
-    ) throws CommandSyntaxException {
-        ServerLevel level = source.getLevel();
-        int minY = level.getMinY();
-        if (maxHeight < minY) {
-            throw ERROR_INVALID_MAX_HEIGHT.create(maxHeight, minY);
-        } else {
-            RandomSource randomSource = RandomSource.create();
-            double d = center.x - maxRange;
-            double d1 = center.y - maxRange;
-            double d2 = center.x + maxRange;
-            double d3 = center.y + maxRange;
-            SpreadPlayersCommand.Position[] positions = createInitialPositions(
-                randomSource, respectTeams ? getNumberOfTeams(targets) : targets.size(), d, d1, d2, d3
-            );
-            spreadPositions(center, spreadDistance, level, randomSource, d, d1, d2, d3, maxHeight, positions, respectTeams);
-            double d4 = setPlayerPositions(targets, level, positions, maxHeight, respectTeams);
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.spreadplayers.success." + (respectTeams ? "teams" : "entities"),
-                    positions.length,
-                    center.x,
-                    center.y,
-                    String.format(Locale.ROOT, "%.2f", d4)
-                ),
-                true
-            );
-            return positions.length;
-        }
-    }
-
-    private static int getNumberOfTeams(Collection<? extends Entity> entities) {
-        Set<Team> set = Sets.newHashSet();
-
-        for (Entity entity : entities) {
-            if (entity instanceof Player) {
-                set.add(entity.getTeam());
-            } else {
-                set.add(null);
-            }
-        }
-
-        return set.size();
-    }
-
-    private static void spreadPositions(
-        Vec2 center,
-        double spreadDistance,
-        ServerLevel level,
-        RandomSource random,
-        double minX,
-        double minZ,
-        double maxX,
-        double maxZ,
-        int maxHeight,
-        SpreadPlayersCommand.Position[] positions,
-        boolean respectTeams
-    ) throws CommandSyntaxException {
-        boolean flag = true;
-        double d = Float.MAX_VALUE;
-
-        int i;
-        for (i = 0; i < 10000 && flag; i++) {
-            flag = false;
-            d = Float.MAX_VALUE;
-
-            for (int i1 = 0; i1 < positions.length; i1++) {
-                SpreadPlayersCommand.Position position = positions[i1];
-                int i2 = 0;
-                SpreadPlayersCommand.Position position1 = new SpreadPlayersCommand.Position();
-
-                for (int i3 = 0; i3 < positions.length; i3++) {
-                    if (i1 != i3) {
-                        SpreadPlayersCommand.Position position2 = positions[i3];
-                        double d1 = position.dist(position2);
-                        d = Math.min(d1, d);
-                        if (d1 < spreadDistance) {
-                            i2++;
-                            position1.x = position1.x + (position2.x - position.x);
-                            position1.z = position1.z + (position2.z - position.z);
-                        }
-                    }
-                }
-
-                if (i2 > 0) {
-                    position1.x /= i2;
-                    position1.z /= i2;
-                    double length = position1.getLength();
-                    if (length > 0.0) {
-                        position1.normalize();
-                        position.moveAway(position1);
-                    } else {
-                        position.randomize(random, minX, minZ, maxX, maxZ);
-                    }
-
-                    flag = true;
-                }
-
-                if (position.clamp(minX, minZ, maxX, maxZ)) {
-                    flag = true;
-                }
-            }
-
-            if (!flag) {
-                for (SpreadPlayersCommand.Position position1 : positions) {
-                    if (!position1.isSafe(level, maxHeight)) {
-                        position1.randomize(random, minX, minZ, maxX, maxZ);
-                        flag = true;
-                    }
-                }
-            }
-        }
-
-        if (d == Float.MAX_VALUE) {
-            d = 0.0;
-        }
-
-        if (i >= 10000) {
-            if (respectTeams) {
-                throw ERROR_FAILED_TO_SPREAD_TEAMS.create(positions.length, center.x, center.y, String.format(Locale.ROOT, "%.2f", d));
-            } else {
-                throw ERROR_FAILED_TO_SPREAD_ENTITIES.create(positions.length, center.x, center.y, String.format(Locale.ROOT, "%.2f", d));
-            }
-        }
-    }
-
-    private static double setPlayerPositions(
-        Collection<? extends Entity> targets, ServerLevel level, SpreadPlayersCommand.Position[] positions, int maxHeight, boolean respectTeams
-    ) {
-        double d = 0.0;
-        int i = 0;
-        Map<Team, SpreadPlayersCommand.Position> map = Maps.newHashMap();
-
-        for (Entity entity : targets) {
-            SpreadPlayersCommand.Position position;
-            if (respectTeams) {
-                Team team = entity instanceof Player ? entity.getTeam() : null;
-                if (!map.containsKey(team)) {
-                    map.put(team, positions[i++]);
-                }
-
-                position = map.get(team);
-            } else {
-                position = positions[i++];
-            }
-
-            entity.teleportTo(
-                level,
-                Mth.floor(position.x) + 0.5,
-                position.getSpawnY(level, maxHeight),
-                Mth.floor(position.z) + 0.5,
-                Set.of(),
-                entity.getYRot(),
-                entity.getXRot(),
-                true
-                , org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.COMMAND // CraftBukkit - handle teleport reason
-            );
-            double d1 = Double.MAX_VALUE;
-
-            for (SpreadPlayersCommand.Position position1 : positions) {
-                if (position != position1) {
-                    double d2 = position.dist(position1);
-                    d1 = Math.min(d2, d1);
-                }
-            }
-
-            d += d1;
-        }
-
-        return targets.size() < 2 ? 0.0 : d / targets.size();
-    }
-
-    private static SpreadPlayersCommand.Position[] createInitialPositions(RandomSource random, int count, double minX, double minZ, double maxX, double maxZ) {
-        SpreadPlayersCommand.Position[] positions = new SpreadPlayersCommand.Position[count];
-
-        for (int i = 0; i < positions.length; i++) {
-            SpreadPlayersCommand.Position position = new SpreadPlayersCommand.Position();
-            position.randomize(random, minX, minZ, maxX, maxZ);
-            positions[i] = position;
-        }
-
-        return positions;
-    }
-
-    static class Position {
-        double x;
-        double z;
-
-        double dist(SpreadPlayersCommand.Position other) {
-            double d = this.x - other.x;
-            double d1 = this.z - other.z;
-            return Math.sqrt(d * d + d1 * d1);
-        }
-
-        void normalize() {
-            double length = this.getLength();
-            this.x /= length;
-            this.z /= length;
-        }
-
-        double getLength() {
-            return Math.sqrt(this.x * this.x + this.z * this.z);
-        }
-
-        public void moveAway(SpreadPlayersCommand.Position other) {
-            this.x = this.x - other.x;
-            this.z = this.z - other.z;
-        }
-
-        public boolean clamp(double minX, double minZ, double maxX, double maxZ) {
-            boolean flag = false;
-            if (this.x < minX) {
-                this.x = minX;
-                flag = true;
-            } else if (this.x > maxX) {
-                this.x = maxX;
-                flag = true;
-            }
-
-            if (this.z < minZ) {
-                this.z = minZ;
-                flag = true;
-            } else if (this.z > maxZ) {
-                this.z = maxZ;
-                flag = true;
-            }
-
-            return flag;
-        }
-
-        public int getSpawnY(BlockGetter level, int y) {
-            BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos(this.x, (double)(y + 1), this.z);
-            boolean isAir = level.getBlockState(mutableBlockPos).isAir();
-            mutableBlockPos.move(Direction.DOWN);
-            boolean isAir1 = level.getBlockState(mutableBlockPos).isAir();
-
-            while (mutableBlockPos.getY() > level.getMinY()) {
-                mutableBlockPos.move(Direction.DOWN);
-                boolean isAir2 = level.getBlockState(mutableBlockPos).isAir();
-                if (!isAir2 && isAir1 && isAir) {
-                    return mutableBlockPos.getY() + 1;
-                }
-
-                isAir = isAir1;
-                isAir1 = isAir2;
-            }
-
-            return y + 1;
-        }
-
-        public boolean isSafe(BlockGetter level, int y) {
-            BlockPos blockPos = BlockPos.containing(this.x, this.getSpawnY(level, y) - 1, this.z);
-            BlockState blockState = level.getBlockState(blockPos);
-            return blockPos.getY() < y && !blockState.liquid() && !blockState.is(BlockTags.FIRE);
-        }
-
-        public void randomize(RandomSource random, double minX, double minZ, double maxX, double maxZ) {
-            this.x = Mth.nextDouble(random, minX, maxX);
-            this.z = Mth.nextDouble(random, minZ, maxZ);
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/StopSoundCommand.java b/net/minecraft/server/commands/StopSoundCommand.java
deleted file mode 100644
index 29d1f08c8aa8f386bb1d849575ce2c143455226d..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/StopSoundCommand.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.builder.RequiredArgumentBuilder;
-import java.util.Collection;
-import javax.annotation.Nullable;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.commands.arguments.ResourceLocationArgument;
-import net.minecraft.commands.arguments.selector.EntitySelector;
-import net.minecraft.commands.synchronization.SuggestionProviders;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.protocol.game.ClientboundStopSoundPacket;
-import net.minecraft.resources.ResourceLocation;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.sounds.SoundSource;
-
-public class StopSoundCommand {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        RequiredArgumentBuilder<CommandSourceStack, EntitySelector> requiredArgumentBuilder = Commands.argument("targets", EntityArgument.players())
-            .executes(context -> stopSound(context.getSource(), EntityArgument.getPlayers(context, "targets"), null, null))
-            .then(
-                Commands.literal("*")
-                    .then(
-                        Commands.argument("sound", ResourceLocationArgument.id())
-                            .suggests(SuggestionProviders.AVAILABLE_SOUNDS)
-                            .executes(
-                                context -> stopSound(
-                                    context.getSource(), EntityArgument.getPlayers(context, "targets"), null, ResourceLocationArgument.getId(context, "sound")
-                                )
-                            )
-                    )
-            );
-
-        for (SoundSource soundSource : SoundSource.values()) {
-            requiredArgumentBuilder.then(
-                Commands.literal(soundSource.getName())
-                    .executes(context -> stopSound(context.getSource(), EntityArgument.getPlayers(context, "targets"), soundSource, null))
-                    .then(
-                        Commands.argument("sound", ResourceLocationArgument.id())
-                            .suggests(SuggestionProviders.AVAILABLE_SOUNDS)
-                            .executes(
-                                context -> stopSound(
-                                    context.getSource(),
-                                    EntityArgument.getPlayers(context, "targets"),
-                                    soundSource,
-                                    ResourceLocationArgument.getId(context, "sound")
-                                )
-                            )
-                    )
-            );
-        }
-
-        dispatcher.register(Commands.literal("stopsound").requires(source -> source.hasPermission(2)).then(requiredArgumentBuilder));
-    }
-
-    private static int stopSound(CommandSourceStack source, Collection<ServerPlayer> targets, @Nullable SoundSource category, @Nullable ResourceLocation sound) {
-        ClientboundStopSoundPacket clientboundStopSoundPacket = new ClientboundStopSoundPacket(sound, category);
-
-        for (ServerPlayer serverPlayer : targets) {
-            serverPlayer.connection.send(clientboundStopSoundPacket);
-        }
-
-        if (category != null) {
-            if (sound != null) {
-                source.sendSuccess(
-                    () -> Component.translatable("commands.stopsound.success.source.sound", Component.translationArg(sound), category.getName()), true
-                );
-            } else {
-                source.sendSuccess(() -> Component.translatable("commands.stopsound.success.source.any", category.getName()), true);
-            }
-        } else if (sound != null) {
-            source.sendSuccess(() -> Component.translatable("commands.stopsound.success.sourceless.sound", Component.translationArg(sound)), true);
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.stopsound.success.sourceless.any"), true);
-        }
-
-        return targets.size();
-    }
-}
diff --git a/net/minecraft/server/commands/TeamCommand.java b/net/minecraft/server/commands/TeamCommand.java
deleted file mode 100644
index 5fc2a8aa1805012eeea78b0889ada44dd624db62..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/TeamCommand.java
+++ /dev/null
@@ -1,536 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.google.common.collect.Lists;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.BoolArgumentType;
-import com.mojang.brigadier.arguments.StringArgumentType;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import java.util.Collection;
-import java.util.Collections;
-import net.minecraft.ChatFormatting;
-import net.minecraft.commands.CommandBuildContext;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.ColorArgument;
-import net.minecraft.commands.arguments.ComponentArgument;
-import net.minecraft.commands.arguments.ScoreHolderArgument;
-import net.minecraft.commands.arguments.TeamArgument;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.ComponentUtils;
-import net.minecraft.world.scores.PlayerTeam;
-import net.minecraft.world.scores.ScoreHolder;
-import net.minecraft.world.scores.Scoreboard;
-import net.minecraft.world.scores.Team;
-
-public class TeamCommand {
-    private static final SimpleCommandExceptionType ERROR_TEAM_ALREADY_EXISTS = new SimpleCommandExceptionType(
-        Component.translatable("commands.team.add.duplicate")
-    );
-    private static final SimpleCommandExceptionType ERROR_TEAM_ALREADY_EMPTY = new SimpleCommandExceptionType(
-        Component.translatable("commands.team.empty.unchanged")
-    );
-    private static final SimpleCommandExceptionType ERROR_TEAM_ALREADY_NAME = new SimpleCommandExceptionType(
-        Component.translatable("commands.team.option.name.unchanged")
-    );
-    private static final SimpleCommandExceptionType ERROR_TEAM_ALREADY_COLOR = new SimpleCommandExceptionType(
-        Component.translatable("commands.team.option.color.unchanged")
-    );
-    private static final SimpleCommandExceptionType ERROR_TEAM_ALREADY_FRIENDLYFIRE_ENABLED = new SimpleCommandExceptionType(
-        Component.translatable("commands.team.option.friendlyfire.alreadyEnabled")
-    );
-    private static final SimpleCommandExceptionType ERROR_TEAM_ALREADY_FRIENDLYFIRE_DISABLED = new SimpleCommandExceptionType(
-        Component.translatable("commands.team.option.friendlyfire.alreadyDisabled")
-    );
-    private static final SimpleCommandExceptionType ERROR_TEAM_ALREADY_FRIENDLYINVISIBLES_ENABLED = new SimpleCommandExceptionType(
-        Component.translatable("commands.team.option.seeFriendlyInvisibles.alreadyEnabled")
-    );
-    private static final SimpleCommandExceptionType ERROR_TEAM_ALREADY_FRIENDLYINVISIBLES_DISABLED = new SimpleCommandExceptionType(
-        Component.translatable("commands.team.option.seeFriendlyInvisibles.alreadyDisabled")
-    );
-    private static final SimpleCommandExceptionType ERROR_TEAM_NAMETAG_VISIBLITY_UNCHANGED = new SimpleCommandExceptionType(
-        Component.translatable("commands.team.option.nametagVisibility.unchanged")
-    );
-    private static final SimpleCommandExceptionType ERROR_TEAM_DEATH_MESSAGE_VISIBLITY_UNCHANGED = new SimpleCommandExceptionType(
-        Component.translatable("commands.team.option.deathMessageVisibility.unchanged")
-    );
-    private static final SimpleCommandExceptionType ERROR_TEAM_COLLISION_UNCHANGED = new SimpleCommandExceptionType(
-        Component.translatable("commands.team.option.collisionRule.unchanged")
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext context) {
-        dispatcher.register(
-            Commands.literal("team")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.literal("list")
-                        .executes(context1 -> listTeams(context1.getSource()))
-                        .then(
-                            Commands.argument("team", TeamArgument.team())
-                                .executes(context1 -> listMembers(context1.getSource(), TeamArgument.getTeam(context1, "team")))
-                        )
-                )
-                .then(
-                    Commands.literal("add")
-                        .then(
-                            Commands.argument("team", StringArgumentType.word())
-                                .executes(context1 -> createTeam(context1.getSource(), StringArgumentType.getString(context1, "team")))
-                                .then(
-                                    Commands.argument("displayName", ComponentArgument.textComponent(context))
-                                        .executes(
-                                            context1 -> createTeam(
-                                                context1.getSource(),
-                                                StringArgumentType.getString(context1, "team"),
-                                                ComponentArgument.getComponent(context1, "displayName")
-                                            )
-                                        )
-                                )
-                        )
-                )
-                .then(
-                    Commands.literal("remove")
-                        .then(
-                            Commands.argument("team", TeamArgument.team())
-                                .executes(context1 -> deleteTeam(context1.getSource(), TeamArgument.getTeam(context1, "team")))
-                        )
-                )
-                .then(
-                    Commands.literal("empty")
-                        .then(
-                            Commands.argument("team", TeamArgument.team())
-                                .executes(context1 -> emptyTeam(context1.getSource(), TeamArgument.getTeam(context1, "team")))
-                        )
-                )
-                .then(
-                    Commands.literal("join")
-                        .then(
-                            Commands.argument("team", TeamArgument.team())
-                                .executes(
-                                    context1 -> joinTeam(
-                                        context1.getSource(),
-                                        TeamArgument.getTeam(context1, "team"),
-                                        Collections.singleton(context1.getSource().getEntityOrException())
-                                    )
-                                )
-                                .then(
-                                    Commands.argument("members", ScoreHolderArgument.scoreHolders())
-                                        .suggests(ScoreHolderArgument.SUGGEST_SCORE_HOLDERS)
-                                        .executes(
-                                            context1 -> joinTeam(
-                                                context1.getSource(),
-                                                TeamArgument.getTeam(context1, "team"),
-                                                ScoreHolderArgument.getNamesWithDefaultWildcard(context1, "members")
-                                            )
-                                        )
-                                )
-                        )
-                )
-                .then(
-                    Commands.literal("leave")
-                        .then(
-                            Commands.argument("members", ScoreHolderArgument.scoreHolders())
-                                .suggests(ScoreHolderArgument.SUGGEST_SCORE_HOLDERS)
-                                .executes(context1 -> leaveTeam(context1.getSource(), ScoreHolderArgument.getNamesWithDefaultWildcard(context1, "members")))
-                        )
-                )
-                .then(
-                    Commands.literal("modify")
-                        .then(
-                            Commands.argument("team", TeamArgument.team())
-                                .then(
-                                    Commands.literal("displayName")
-                                        .then(
-                                            Commands.argument("displayName", ComponentArgument.textComponent(context))
-                                                .executes(
-                                                    context1 -> setDisplayName(
-                                                        context1.getSource(),
-                                                        TeamArgument.getTeam(context1, "team"),
-                                                        ComponentArgument.getComponent(context1, "displayName")
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("color")
-                                        .then(
-                                            Commands.argument("value", ColorArgument.color())
-                                                .executes(
-                                                    context1 -> setColor(
-                                                        context1.getSource(), TeamArgument.getTeam(context1, "team"), ColorArgument.getColor(context1, "value")
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("friendlyFire")
-                                        .then(
-                                            Commands.argument("allowed", BoolArgumentType.bool())
-                                                .executes(
-                                                    context1 -> setFriendlyFire(
-                                                        context1.getSource(),
-                                                        TeamArgument.getTeam(context1, "team"),
-                                                        BoolArgumentType.getBool(context1, "allowed")
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("seeFriendlyInvisibles")
-                                        .then(
-                                            Commands.argument("allowed", BoolArgumentType.bool())
-                                                .executes(
-                                                    context1 -> setFriendlySight(
-                                                        context1.getSource(),
-                                                        TeamArgument.getTeam(context1, "team"),
-                                                        BoolArgumentType.getBool(context1, "allowed")
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("nametagVisibility")
-                                        .then(
-                                            Commands.literal("never")
-                                                .executes(
-                                                    context1 -> setNametagVisibility(
-                                                        context1.getSource(), TeamArgument.getTeam(context1, "team"), Team.Visibility.NEVER
-                                                    )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.literal("hideForOtherTeams")
-                                                .executes(
-                                                    context1 -> setNametagVisibility(
-                                                        context1.getSource(), TeamArgument.getTeam(context1, "team"), Team.Visibility.HIDE_FOR_OTHER_TEAMS
-                                                    )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.literal("hideForOwnTeam")
-                                                .executes(
-                                                    context1 -> setNametagVisibility(
-                                                        context1.getSource(), TeamArgument.getTeam(context1, "team"), Team.Visibility.HIDE_FOR_OWN_TEAM
-                                                    )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.literal("always")
-                                                .executes(
-                                                    context1 -> setNametagVisibility(
-                                                        context1.getSource(), TeamArgument.getTeam(context1, "team"), Team.Visibility.ALWAYS
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("deathMessageVisibility")
-                                        .then(
-                                            Commands.literal("never")
-                                                .executes(
-                                                    context1 -> setDeathMessageVisibility(
-                                                        context1.getSource(), TeamArgument.getTeam(context1, "team"), Team.Visibility.NEVER
-                                                    )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.literal("hideForOtherTeams")
-                                                .executes(
-                                                    context1 -> setDeathMessageVisibility(
-                                                        context1.getSource(), TeamArgument.getTeam(context1, "team"), Team.Visibility.HIDE_FOR_OTHER_TEAMS
-                                                    )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.literal("hideForOwnTeam")
-                                                .executes(
-                                                    context1 -> setDeathMessageVisibility(
-                                                        context1.getSource(), TeamArgument.getTeam(context1, "team"), Team.Visibility.HIDE_FOR_OWN_TEAM
-                                                    )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.literal("always")
-                                                .executes(
-                                                    context1 -> setDeathMessageVisibility(
-                                                        context1.getSource(), TeamArgument.getTeam(context1, "team"), Team.Visibility.ALWAYS
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("collisionRule")
-                                        .then(
-                                            Commands.literal("never")
-                                                .executes(
-                                                    context1 -> setCollision(
-                                                        context1.getSource(), TeamArgument.getTeam(context1, "team"), Team.CollisionRule.NEVER
-                                                    )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.literal("pushOwnTeam")
-                                                .executes(
-                                                    context1 -> setCollision(
-                                                        context1.getSource(), TeamArgument.getTeam(context1, "team"), Team.CollisionRule.PUSH_OWN_TEAM
-                                                    )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.literal("pushOtherTeams")
-                                                .executes(
-                                                    context1 -> setCollision(
-                                                        context1.getSource(), TeamArgument.getTeam(context1, "team"), Team.CollisionRule.PUSH_OTHER_TEAMS
-                                                    )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.literal("always")
-                                                .executes(
-                                                    context1 -> setCollision(
-                                                        context1.getSource(), TeamArgument.getTeam(context1, "team"), Team.CollisionRule.ALWAYS
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("prefix")
-                                        .then(
-                                            Commands.argument("prefix", ComponentArgument.textComponent(context))
-                                                .executes(
-                                                    context1 -> setPrefix(
-                                                        context1.getSource(),
-                                                        TeamArgument.getTeam(context1, "team"),
-                                                        ComponentArgument.getComponent(context1, "prefix")
-                                                    )
-                                                )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("suffix")
-                                        .then(
-                                            Commands.argument("suffix", ComponentArgument.textComponent(context))
-                                                .executes(
-                                                    context1 -> setSuffix(
-                                                        context1.getSource(),
-                                                        TeamArgument.getTeam(context1, "team"),
-                                                        ComponentArgument.getComponent(context1, "suffix")
-                                                    )
-                                                )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static Component getFirstMemberName(Collection<ScoreHolder> scores) {
-        return scores.iterator().next().getFeedbackDisplayName();
-    }
-
-    private static int leaveTeam(CommandSourceStack source, Collection<ScoreHolder> players) {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-
-        for (ScoreHolder scoreHolder : players) {
-            scoreboard.removePlayerFromTeam(scoreHolder.getScoreboardName());
-        }
-
-        if (players.size() == 1) {
-            source.sendSuccess(() -> Component.translatable("commands.team.leave.success.single", getFirstMemberName(players)), true);
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.team.leave.success.multiple", players.size()), true);
-        }
-
-        return players.size();
-    }
-
-    private static int joinTeam(CommandSourceStack source, PlayerTeam team, Collection<ScoreHolder> players) {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-
-        for (ScoreHolder scoreHolder : players) {
-            scoreboard.addPlayerToTeam(scoreHolder.getScoreboardName(), team);
-        }
-
-        if (players.size() == 1) {
-            source.sendSuccess(
-                () -> Component.translatable("commands.team.join.success.single", getFirstMemberName(players), team.getFormattedDisplayName()), true
-            );
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.team.join.success.multiple", players.size(), team.getFormattedDisplayName()), true);
-        }
-
-        return players.size();
-    }
-
-    private static int setNametagVisibility(CommandSourceStack source, PlayerTeam team, Team.Visibility visibility) throws CommandSyntaxException {
-        if (team.getNameTagVisibility() == visibility) {
-            throw ERROR_TEAM_NAMETAG_VISIBLITY_UNCHANGED.create();
-        } else {
-            team.setNameTagVisibility(visibility);
-            source.sendSuccess(
-                () -> Component.translatable("commands.team.option.nametagVisibility.success", team.getFormattedDisplayName(), visibility.getDisplayName()),
-                true
-            );
-            return 0;
-        }
-    }
-
-    private static int setDeathMessageVisibility(CommandSourceStack source, PlayerTeam team, Team.Visibility visibility) throws CommandSyntaxException {
-        if (team.getDeathMessageVisibility() == visibility) {
-            throw ERROR_TEAM_DEATH_MESSAGE_VISIBLITY_UNCHANGED.create();
-        } else {
-            team.setDeathMessageVisibility(visibility);
-            source.sendSuccess(
-                () -> Component.translatable("commands.team.option.deathMessageVisibility.success", team.getFormattedDisplayName(), visibility.getDisplayName()),
-                true
-            );
-            return 0;
-        }
-    }
-
-    private static int setCollision(CommandSourceStack source, PlayerTeam team, Team.CollisionRule rule) throws CommandSyntaxException {
-        if (team.getCollisionRule() == rule) {
-            throw ERROR_TEAM_COLLISION_UNCHANGED.create();
-        } else {
-            team.setCollisionRule(rule);
-            source.sendSuccess(
-                () -> Component.translatable("commands.team.option.collisionRule.success", team.getFormattedDisplayName(), rule.getDisplayName()), true
-            );
-            return 0;
-        }
-    }
-
-    private static int setFriendlySight(CommandSourceStack source, PlayerTeam team, boolean value) throws CommandSyntaxException {
-        if (team.canSeeFriendlyInvisibles() == value) {
-            if (value) {
-                throw ERROR_TEAM_ALREADY_FRIENDLYINVISIBLES_ENABLED.create();
-            } else {
-                throw ERROR_TEAM_ALREADY_FRIENDLYINVISIBLES_DISABLED.create();
-            }
-        } else {
-            team.setSeeFriendlyInvisibles(value);
-            source.sendSuccess(
-                () -> Component.translatable("commands.team.option.seeFriendlyInvisibles." + (value ? "enabled" : "disabled"), team.getFormattedDisplayName()),
-                true
-            );
-            return 0;
-        }
-    }
-
-    private static int setFriendlyFire(CommandSourceStack source, PlayerTeam team, boolean value) throws CommandSyntaxException {
-        if (team.isAllowFriendlyFire() == value) {
-            if (value) {
-                throw ERROR_TEAM_ALREADY_FRIENDLYFIRE_ENABLED.create();
-            } else {
-                throw ERROR_TEAM_ALREADY_FRIENDLYFIRE_DISABLED.create();
-            }
-        } else {
-            team.setAllowFriendlyFire(value);
-            source.sendSuccess(
-                () -> Component.translatable("commands.team.option.friendlyfire." + (value ? "enabled" : "disabled"), team.getFormattedDisplayName()), true
-            );
-            return 0;
-        }
-    }
-
-    private static int setDisplayName(CommandSourceStack source, PlayerTeam team, Component value) throws CommandSyntaxException {
-        if (team.getDisplayName().equals(value)) {
-            throw ERROR_TEAM_ALREADY_NAME.create();
-        } else {
-            team.setDisplayName(value);
-            source.sendSuccess(() -> Component.translatable("commands.team.option.name.success", team.getFormattedDisplayName()), true);
-            return 0;
-        }
-    }
-
-    private static int setColor(CommandSourceStack source, PlayerTeam team, ChatFormatting value) throws CommandSyntaxException {
-        if (team.getColor() == value) {
-            throw ERROR_TEAM_ALREADY_COLOR.create();
-        } else {
-            team.setColor(value);
-            source.sendSuccess(() -> Component.translatable("commands.team.option.color.success", team.getFormattedDisplayName(), value.getName()), true);
-            return 0;
-        }
-    }
-
-    private static int emptyTeam(CommandSourceStack source, PlayerTeam team) throws CommandSyntaxException {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-        Collection<String> list = Lists.newArrayList(team.getPlayers());
-        if (list.isEmpty()) {
-            throw ERROR_TEAM_ALREADY_EMPTY.create();
-        } else {
-            for (String string : list) {
-                scoreboard.removePlayerFromTeam(string, team);
-            }
-
-            source.sendSuccess(() -> Component.translatable("commands.team.empty.success", list.size(), team.getFormattedDisplayName()), true);
-            return list.size();
-        }
-    }
-
-    private static int deleteTeam(CommandSourceStack source, PlayerTeam team) {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-        scoreboard.removePlayerTeam(team);
-        source.sendSuccess(() -> Component.translatable("commands.team.remove.success", team.getFormattedDisplayName()), true);
-        return scoreboard.getPlayerTeams().size();
-    }
-
-    private static int createTeam(CommandSourceStack source, String name) throws CommandSyntaxException {
-        return createTeam(source, name, Component.literal(name));
-    }
-
-    private static int createTeam(CommandSourceStack source, String name, Component displayName) throws CommandSyntaxException {
-        Scoreboard scoreboard = source.getServer().getScoreboard();
-        if (scoreboard.getPlayerTeam(name) != null) {
-            throw ERROR_TEAM_ALREADY_EXISTS.create();
-        } else {
-            PlayerTeam playerTeam = scoreboard.addPlayerTeam(name);
-            playerTeam.setDisplayName(displayName);
-            source.sendSuccess(() -> Component.translatable("commands.team.add.success", playerTeam.getFormattedDisplayName()), true);
-            return scoreboard.getPlayerTeams().size();
-        }
-    }
-
-    private static int listMembers(CommandSourceStack source, PlayerTeam team) {
-        Collection<String> players = team.getPlayers();
-        if (players.isEmpty()) {
-            source.sendSuccess(() -> Component.translatable("commands.team.list.members.empty", team.getFormattedDisplayName()), false);
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.team.list.members.success", team.getFormattedDisplayName(), players.size(), ComponentUtils.formatList(players)
-                ),
-                false
-            );
-        }
-
-        return players.size();
-    }
-
-    private static int listTeams(CommandSourceStack source) {
-        Collection<PlayerTeam> playerTeams = source.getServer().getScoreboard().getPlayerTeams();
-        if (playerTeams.isEmpty()) {
-            source.sendSuccess(() -> Component.translatable("commands.team.list.teams.empty"), false);
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.team.list.teams.success", playerTeams.size(), ComponentUtils.formatList(playerTeams, PlayerTeam::getFormattedDisplayName)
-                ),
-                false
-            );
-        }
-
-        return playerTeams.size();
-    }
-
-    private static int setPrefix(CommandSourceStack source, PlayerTeam team, Component prefix) {
-        team.setPlayerPrefix(prefix);
-        source.sendSuccess(() -> Component.translatable("commands.team.option.prefix.success", prefix), false);
-        return 1;
-    }
-
-    private static int setSuffix(CommandSourceStack source, PlayerTeam team, Component suffix) {
-        team.setPlayerSuffix(suffix);
-        source.sendSuccess(() -> Component.translatable("commands.team.option.suffix.success", suffix), false);
-        return 1;
-    }
-}
diff --git a/net/minecraft/server/commands/TeamMsgCommand.java b/net/minecraft/server/commands/TeamMsgCommand.java
deleted file mode 100644
index 928a315968e6ef00c0595c385439a7dbdd77492d..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/TeamMsgCommand.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import com.mojang.brigadier.tree.LiteralCommandNode;
-import java.util.List;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.MessageArgument;
-import net.minecraft.network.chat.ChatType;
-import net.minecraft.network.chat.ClickEvent;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.HoverEvent;
-import net.minecraft.network.chat.OutgoingChatMessage;
-import net.minecraft.network.chat.PlayerChatMessage;
-import net.minecraft.network.chat.Style;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.server.players.PlayerList;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.scores.PlayerTeam;
-
-public class TeamMsgCommand {
-    private static final Style SUGGEST_STYLE = Style.EMPTY
-        .withHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, Component.translatable("chat.type.team.hover")))
-        .withClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, "/teammsg "));
-    private static final SimpleCommandExceptionType ERROR_NOT_ON_TEAM = new SimpleCommandExceptionType(Component.translatable("commands.teammsg.failed.noteam"));
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        LiteralCommandNode<CommandSourceStack> literalCommandNode = dispatcher.register(
-            Commands.literal("teammsg")
-                .then(
-                    Commands.argument("message", MessageArgument.message())
-                        .executes(
-                            context -> {
-                                CommandSourceStack commandSourceStack = context.getSource();
-                                Entity entityOrException = commandSourceStack.getEntityOrException();
-                                PlayerTeam team = entityOrException.getTeam();
-                                if (team == null) {
-                                    throw ERROR_NOT_ON_TEAM.create();
-                                } else {
-                                    List<ServerPlayer> list = commandSourceStack.getServer()
-                                        .getPlayerList()
-                                        .getPlayers()
-                                        .stream()
-                                        .filter(player -> player == entityOrException || player.getTeam() == team)
-                                        .toList();
-                                    if (!list.isEmpty()) {
-                                        MessageArgument.resolveChatMessage(
-                                            context, "message", message -> sendMessage(commandSourceStack, entityOrException, team, list, message)
-                                        );
-                                    }
-
-                                    return list.size();
-                                }
-                            }
-                        )
-                )
-        );
-        dispatcher.register(Commands.literal("tm").redirect(literalCommandNode));
-    }
-
-    private static void sendMessage(CommandSourceStack source, Entity sender, PlayerTeam team, List<ServerPlayer> teamMembers, PlayerChatMessage chatMessage) {
-        Component component = team.getFormattedDisplayName().withStyle(SUGGEST_STYLE);
-        ChatType.Bound bound = ChatType.bind(ChatType.TEAM_MSG_COMMAND_INCOMING, source).withTargetName(component);
-        ChatType.Bound bound1 = ChatType.bind(ChatType.TEAM_MSG_COMMAND_OUTGOING, source).withTargetName(component);
-        OutgoingChatMessage outgoingChatMessage = OutgoingChatMessage.create(chatMessage);
-        boolean flag = false;
-
-        for (ServerPlayer serverPlayer : teamMembers) {
-            ChatType.Bound bound2 = serverPlayer == sender ? bound1 : bound;
-            boolean shouldFilterMessageTo = source.shouldFilterMessageTo(serverPlayer);
-            serverPlayer.sendChatMessage(outgoingChatMessage, shouldFilterMessageTo, bound2);
-            flag |= shouldFilterMessageTo && chatMessage.isFullyFiltered();
-        }
-
-        if (flag) {
-            source.sendSystemMessage(PlayerList.CHAT_FILTERED_FULL);
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/TeleportCommand.java b/net/minecraft/server/commands/TeleportCommand.java
deleted file mode 100644
index 01f8e2fec232210c9311565197860cf0257081fd..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/TeleportCommand.java
+++ /dev/null
@@ -1,333 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import com.mojang.brigadier.tree.LiteralCommandNode;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.Locale;
-import java.util.Set;
-import javax.annotation.Nullable;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.EntityAnchorArgument;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.commands.arguments.coordinates.Coordinates;
-import net.minecraft.commands.arguments.coordinates.RotationArgument;
-import net.minecraft.commands.arguments.coordinates.Vec3Argument;
-import net.minecraft.core.BlockPos;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.util.Mth;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.PathfinderMob;
-import net.minecraft.world.entity.Relative;
-import net.minecraft.world.level.Level;
-import net.minecraft.world.phys.Vec2;
-import net.minecraft.world.phys.Vec3;
-
-public class TeleportCommand {
-    private static final SimpleCommandExceptionType INVALID_POSITION = new SimpleCommandExceptionType(
-        Component.translatable("commands.teleport.invalidPosition")
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        LiteralCommandNode<CommandSourceStack> literalCommandNode = dispatcher.register(
-            Commands.literal("teleport")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.argument("location", Vec3Argument.vec3())
-                        .executes(
-                            context -> teleportToPos(
-                                context.getSource(),
-                                Collections.singleton(context.getSource().getEntityOrException()),
-                                context.getSource().getLevel(),
-                                Vec3Argument.getCoordinates(context, "location"),
-                                null,
-                                null
-                            )
-                        )
-                )
-                .then(
-                    Commands.argument("destination", EntityArgument.entity())
-                        .executes(
-                            context -> teleportToEntity(
-                                context.getSource(),
-                                Collections.singleton(context.getSource().getEntityOrException()),
-                                EntityArgument.getEntity(context, "destination")
-                            )
-                        )
-                )
-                .then(
-                    Commands.argument("targets", EntityArgument.entities())
-                        .then(
-                            Commands.argument("location", Vec3Argument.vec3())
-                                .executes(
-                                    context -> teleportToPos(
-                                        context.getSource(),
-                                        EntityArgument.getEntities(context, "targets"),
-                                        context.getSource().getLevel(),
-                                        Vec3Argument.getCoordinates(context, "location"),
-                                        null,
-                                        null
-                                    )
-                                )
-                                .then(
-                                    Commands.argument("rotation", RotationArgument.rotation())
-                                        .executes(
-                                            context -> teleportToPos(
-                                                context.getSource(),
-                                                EntityArgument.getEntities(context, "targets"),
-                                                context.getSource().getLevel(),
-                                                Vec3Argument.getCoordinates(context, "location"),
-                                                RotationArgument.getRotation(context, "rotation"),
-                                                null
-                                            )
-                                        )
-                                )
-                                .then(
-                                    Commands.literal("facing")
-                                        .then(
-                                            Commands.literal("entity")
-                                                .then(
-                                                    Commands.argument("facingEntity", EntityArgument.entity())
-                                                        .executes(
-                                                            context -> teleportToPos(
-                                                                context.getSource(),
-                                                                EntityArgument.getEntities(context, "targets"),
-                                                                context.getSource().getLevel(),
-                                                                Vec3Argument.getCoordinates(context, "location"),
-                                                                null,
-                                                                new LookAt.LookAtEntity(
-                                                                    EntityArgument.getEntity(context, "facingEntity"), EntityAnchorArgument.Anchor.FEET
-                                                                )
-                                                            )
-                                                        )
-                                                        .then(
-                                                            Commands.argument("facingAnchor", EntityAnchorArgument.anchor())
-                                                                .executes(
-                                                                    context -> teleportToPos(
-                                                                        context.getSource(),
-                                                                        EntityArgument.getEntities(context, "targets"),
-                                                                        context.getSource().getLevel(),
-                                                                        Vec3Argument.getCoordinates(context, "location"),
-                                                                        null,
-                                                                        new LookAt.LookAtEntity(
-                                                                            EntityArgument.getEntity(context, "facingEntity"),
-                                                                            EntityAnchorArgument.getAnchor(context, "facingAnchor")
-                                                                        )
-                                                                    )
-                                                                )
-                                                        )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.argument("facingLocation", Vec3Argument.vec3())
-                                                .executes(
-                                                    context -> teleportToPos(
-                                                        context.getSource(),
-                                                        EntityArgument.getEntities(context, "targets"),
-                                                        context.getSource().getLevel(),
-                                                        Vec3Argument.getCoordinates(context, "location"),
-                                                        null,
-                                                        new LookAt.LookAtPosition(Vec3Argument.getVec3(context, "facingLocation"))
-                                                    )
-                                                )
-                                        )
-                                )
-                        )
-                        .then(
-                            Commands.argument("destination", EntityArgument.entity())
-                                .executes(
-                                    context -> teleportToEntity(
-                                        context.getSource(), EntityArgument.getEntities(context, "targets"), EntityArgument.getEntity(context, "destination")
-                                    )
-                                )
-                        )
-                )
-        );
-        dispatcher.register(Commands.literal("tp").requires(source -> source.hasPermission(2)).redirect(literalCommandNode));
-    }
-
-    private static int teleportToEntity(CommandSourceStack source, Collection<? extends Entity> targets, Entity destination) throws CommandSyntaxException {
-        for (Entity entity : targets) {
-            performTeleport(
-                source,
-                entity,
-                (ServerLevel)destination.level(),
-                destination.getX(),
-                destination.getY(),
-                destination.getZ(),
-                EnumSet.noneOf(Relative.class),
-                destination.getYRot(),
-                destination.getXRot(),
-                null
-            );
-        }
-
-        if (targets.size() == 1) {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.teleport.success.entity.single", targets.iterator().next().getDisplayName(), destination.getDisplayName()
-                ),
-                true
-            );
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.teleport.success.entity.multiple", targets.size(), destination.getDisplayName()), true);
-        }
-
-        return targets.size();
-    }
-
-    private static int teleportToPos(
-        CommandSourceStack source,
-        Collection<? extends Entity> targets,
-        ServerLevel level,
-        Coordinates position,
-        @Nullable Coordinates rotation,
-        @Nullable LookAt lookAt
-    ) throws CommandSyntaxException {
-        Vec3 position1 = position.getPosition(source);
-        Vec2 vec2 = rotation == null ? null : rotation.getRotation(source);
-
-        for (Entity entity : targets) {
-            Set<Relative> relatives = getRelatives(position, rotation, entity.level().dimension() == level.dimension());
-            if (vec2 == null) {
-                performTeleport(source, entity, level, position1.x, position1.y, position1.z, relatives, entity.getYRot(), entity.getXRot(), lookAt);
-            } else {
-                performTeleport(source, entity, level, position1.x, position1.y, position1.z, relatives, vec2.y, vec2.x, lookAt);
-            }
-        }
-
-        if (targets.size() == 1) {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.teleport.success.location.single",
-                    targets.iterator().next().getDisplayName(),
-                    formatDouble(position1.x),
-                    formatDouble(position1.y),
-                    formatDouble(position1.z)
-                ),
-                true
-            );
-        } else {
-            source.sendSuccess(
-                () -> Component.translatable(
-                    "commands.teleport.success.location.multiple",
-                    targets.size(),
-                    formatDouble(position1.x),
-                    formatDouble(position1.y),
-                    formatDouble(position1.z)
-                ),
-                true
-            );
-        }
-
-        return targets.size();
-    }
-
-    private static Set<Relative> getRelatives(Coordinates position, @Nullable Coordinates rotation, boolean absolute) {
-        Set<Relative> set = EnumSet.noneOf(Relative.class);
-        if (position.isXRelative()) {
-            set.add(Relative.DELTA_X);
-            if (absolute) {
-                set.add(Relative.X);
-            }
-        }
-
-        if (position.isYRelative()) {
-            set.add(Relative.DELTA_Y);
-            if (absolute) {
-                set.add(Relative.Y);
-            }
-        }
-
-        if (position.isZRelative()) {
-            set.add(Relative.DELTA_Z);
-            if (absolute) {
-                set.add(Relative.Z);
-            }
-        }
-
-        if (rotation == null || rotation.isXRelative()) {
-            set.add(Relative.X_ROT);
-        }
-
-        if (rotation == null || rotation.isYRelative()) {
-            set.add(Relative.Y_ROT);
-        }
-
-        return set;
-    }
-
-    private static String formatDouble(double value) {
-        return String.format(Locale.ROOT, "%f", value);
-    }
-
-    private static void performTeleport(
-        CommandSourceStack source,
-        Entity target,
-        ServerLevel level,
-        double x,
-        double y,
-        double z,
-        Set<Relative> relatives,
-        float yRot,
-        float xRot,
-        @Nullable LookAt lookAt
-    ) throws CommandSyntaxException {
-        BlockPos blockPos = BlockPos.containing(x, y, z);
-        if (!Level.isInSpawnableBounds(blockPos)) {
-            throw INVALID_POSITION.create();
-        } else {
-            double d = relatives.contains(Relative.X) ? x - target.getX() : x;
-            double d1 = relatives.contains(Relative.Y) ? y - target.getY() : y;
-            double d2 = relatives.contains(Relative.Z) ? z - target.getZ() : z;
-            float f = relatives.contains(Relative.Y_ROT) ? yRot - target.getYRot() : yRot;
-            float f1 = relatives.contains(Relative.X_ROT) ? xRot - target.getXRot() : xRot;
-            float f2 = Mth.wrapDegrees(f);
-            float f3 = Mth.wrapDegrees(f1);
-            // CraftBukkit start - Teleport event
-            boolean result;
-            if (target instanceof final net.minecraft.server.level.ServerPlayer player) {
-                result = player.teleportTo(level, d, d1, d2, relatives, f2, f3, true, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.COMMAND);
-            } else {
-                org.bukkit.Location to = new org.bukkit.Location(level.getWorld(), d, d1, d2, f2, f3);
-                org.bukkit.event.entity.EntityTeleportEvent event = new org.bukkit.event.entity.EntityTeleportEvent(target.getBukkitEntity(), target.getBukkitEntity().getLocation(), to);
-                level.getCraftServer().getPluginManager().callEvent(event);
-                if (event.isCancelled() || event.getTo() == null) { // Paper
-                    return;
-                }
-                to = event.getTo(); // Paper - actually track new location
-
-                d = to.getX();
-                d1 = to.getY();
-                d2 = to.getZ();
-                f2 = to.getYaw();
-                f3 = to.getPitch();
-                level = ((org.bukkit.craftbukkit.CraftWorld) to.getWorld()).getHandle();
-
-                result = target.teleportTo(level, d, d1, d2, relatives, f2, f3, true);
-            }
-
-            if (result) {
-                // CraftBukkit end
-                if (lookAt != null) {
-                    lookAt.perform(source, target);
-                }
-
-                if (!(target instanceof LivingEntity livingEntity && livingEntity.isFallFlying())) {
-                    target.setDeltaMovement(target.getDeltaMovement().multiply(1.0, 0.0, 1.0));
-                    target.setOnGround(true);
-                }
-
-                if (target instanceof PathfinderMob pathfinderMob) {
-                    pathfinderMob.getNavigation().stop();
-                }
-            }
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/TellRawCommand.java b/net/minecraft/server/commands/TellRawCommand.java
deleted file mode 100644
index 29bdfdeced659cf1a5cb83274fd9e8eedf59ba7c..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/TellRawCommand.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import net.minecraft.commands.CommandBuildContext;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.ComponentArgument;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.network.chat.ComponentUtils;
-import net.minecraft.server.level.ServerPlayer;
-
-public class TellRawCommand {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext context) {
-        dispatcher.register(
-            Commands.literal("tellraw")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.argument("targets", EntityArgument.players())
-                        .then(
-                            Commands.argument("message", ComponentArgument.textComponent(context))
-                                .executes(
-                                    context1 -> {
-                                        int i = 0;
-
-                                        for (ServerPlayer serverPlayer : EntityArgument.getPlayers(context1, "targets")) {
-                                            serverPlayer.sendSystemMessage(
-                                                ComponentUtils.updateForEntity(
-                                                    context1.getSource(), ComponentArgument.getComponent(context1, "message"), serverPlayer, 0
-                                                ),
-                                                false
-                                            );
-                                            i++;
-                                        }
-
-                                        return i;
-                                    }
-                                )
-                        )
-                )
-        );
-    }
-}
diff --git a/net/minecraft/server/commands/TickCommand.java b/net/minecraft/server/commands/TickCommand.java
index 6b6c8ce49eda6806c8288d70848dd143ba2c4703..d78172faca2ed3c45bd5dafa71716b2ea214015e 100644
--- a/net/minecraft/server/commands/TickCommand.java
+++ b/net/minecraft/server/commands/TickCommand.java
@@ -25,7 +25,7 @@ public class TickCommand {
                 .then(
                     Commands.literal("rate")
                         .then(
-                            Commands.argument("rate", FloatArgumentType.floatArg(1.0F, 10000.0F))
+                            Commands.argument("rate", FloatArgumentType.floatArg(1.0F, MAX_TICKRATE))
                                 .suggests(
                                     (commandContext, suggestionsBuilder) -> SharedSuggestionProvider.suggest(new String[]{DEFAULT_TICKRATE}, suggestionsBuilder)
                                 )
diff --git a/net/minecraft/server/commands/TitleCommand.java b/net/minecraft/server/commands/TitleCommand.java
deleted file mode 100644
index df6a0597a18239450710f468fddb6bc8932f787a..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/TitleCommand.java
+++ /dev/null
@@ -1,166 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import java.util.Collection;
-import java.util.function.Function;
-import net.minecraft.commands.CommandBuildContext;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.ComponentArgument;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.commands.arguments.TimeArgument;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.ComponentUtils;
-import net.minecraft.network.protocol.Packet;
-import net.minecraft.network.protocol.game.ClientboundClearTitlesPacket;
-import net.minecraft.network.protocol.game.ClientboundSetActionBarTextPacket;
-import net.minecraft.network.protocol.game.ClientboundSetSubtitleTextPacket;
-import net.minecraft.network.protocol.game.ClientboundSetTitleTextPacket;
-import net.minecraft.network.protocol.game.ClientboundSetTitlesAnimationPacket;
-import net.minecraft.server.level.ServerPlayer;
-
-public class TitleCommand {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext context) {
-        dispatcher.register(
-            Commands.literal("title")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.argument("targets", EntityArgument.players())
-                        .then(Commands.literal("clear").executes(context1 -> clearTitle(context1.getSource(), EntityArgument.getPlayers(context1, "targets"))))
-                        .then(Commands.literal("reset").executes(context1 -> resetTitle(context1.getSource(), EntityArgument.getPlayers(context1, "targets"))))
-                        .then(
-                            Commands.literal("title")
-                                .then(
-                                    Commands.argument("title", ComponentArgument.textComponent(context))
-                                        .executes(
-                                            context1 -> showTitle(
-                                                context1.getSource(),
-                                                EntityArgument.getPlayers(context1, "targets"),
-                                                ComponentArgument.getComponent(context1, "title"),
-                                                "title",
-                                                ClientboundSetTitleTextPacket::new
-                                            )
-                                        )
-                                )
-                        )
-                        .then(
-                            Commands.literal("subtitle")
-                                .then(
-                                    Commands.argument("title", ComponentArgument.textComponent(context))
-                                        .executes(
-                                            context1 -> showTitle(
-                                                context1.getSource(),
-                                                EntityArgument.getPlayers(context1, "targets"),
-                                                ComponentArgument.getComponent(context1, "title"),
-                                                "subtitle",
-                                                ClientboundSetSubtitleTextPacket::new
-                                            )
-                                        )
-                                )
-                        )
-                        .then(
-                            Commands.literal("actionbar")
-                                .then(
-                                    Commands.argument("title", ComponentArgument.textComponent(context))
-                                        .executes(
-                                            context1 -> showTitle(
-                                                context1.getSource(),
-                                                EntityArgument.getPlayers(context1, "targets"),
-                                                ComponentArgument.getComponent(context1, "title"),
-                                                "actionbar",
-                                                ClientboundSetActionBarTextPacket::new
-                                            )
-                                        )
-                                )
-                        )
-                        .then(
-                            Commands.literal("times")
-                                .then(
-                                    Commands.argument("fadeIn", TimeArgument.time())
-                                        .then(
-                                            Commands.argument("stay", TimeArgument.time())
-                                                .then(
-                                                    Commands.argument("fadeOut", TimeArgument.time())
-                                                        .executes(
-                                                            context1 -> setTimes(
-                                                                context1.getSource(),
-                                                                EntityArgument.getPlayers(context1, "targets"),
-                                                                IntegerArgumentType.getInteger(context1, "fadeIn"),
-                                                                IntegerArgumentType.getInteger(context1, "stay"),
-                                                                IntegerArgumentType.getInteger(context1, "fadeOut")
-                                                            )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int clearTitle(CommandSourceStack source, Collection<ServerPlayer> targets) {
-        ClientboundClearTitlesPacket clientboundClearTitlesPacket = new ClientboundClearTitlesPacket(false);
-
-        for (ServerPlayer serverPlayer : targets) {
-            serverPlayer.connection.send(clientboundClearTitlesPacket);
-        }
-
-        if (targets.size() == 1) {
-            source.sendSuccess(() -> Component.translatable("commands.title.cleared.single", targets.iterator().next().getDisplayName()), true);
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.title.cleared.multiple", targets.size()), true);
-        }
-
-        return targets.size();
-    }
-
-    private static int resetTitle(CommandSourceStack source, Collection<ServerPlayer> targets) {
-        ClientboundClearTitlesPacket clientboundClearTitlesPacket = new ClientboundClearTitlesPacket(true);
-
-        for (ServerPlayer serverPlayer : targets) {
-            serverPlayer.connection.send(clientboundClearTitlesPacket);
-        }
-
-        if (targets.size() == 1) {
-            source.sendSuccess(() -> Component.translatable("commands.title.reset.single", targets.iterator().next().getDisplayName()), true);
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.title.reset.multiple", targets.size()), true);
-        }
-
-        return targets.size();
-    }
-
-    private static int showTitle(
-        CommandSourceStack source, Collection<ServerPlayer> targets, Component title, String titleType, Function<Component, Packet<?>> packetGetter
-    ) throws CommandSyntaxException {
-        for (ServerPlayer serverPlayer : targets) {
-            serverPlayer.connection.send(packetGetter.apply(ComponentUtils.updateForEntity(source, title, serverPlayer, 0)));
-        }
-
-        if (targets.size() == 1) {
-            source.sendSuccess(() -> Component.translatable("commands.title.show." + titleType + ".single", targets.iterator().next().getDisplayName()), true);
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.title.show." + titleType + ".multiple", targets.size()), true);
-        }
-
-        return targets.size();
-    }
-
-    private static int setTimes(CommandSourceStack source, Collection<ServerPlayer> target, int fade, int stay, int fadeOut) {
-        ClientboundSetTitlesAnimationPacket clientboundSetTitlesAnimationPacket = new ClientboundSetTitlesAnimationPacket(fade, stay, fadeOut);
-
-        for (ServerPlayer serverPlayer : target) {
-            serverPlayer.connection.send(clientboundSetTitlesAnimationPacket);
-        }
-
-        if (target.size() == 1) {
-            source.sendSuccess(() -> Component.translatable("commands.title.times.single", target.iterator().next().getDisplayName()), true);
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.title.times.multiple", target.size()), true);
-        }
-
-        return target.size();
-    }
-}
diff --git a/net/minecraft/server/commands/TransferCommand.java b/net/minecraft/server/commands/TransferCommand.java
deleted file mode 100644
index 2ea4350c9a055dfdceae17c2f41c261a49c2e492..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/TransferCommand.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import com.mojang.brigadier.arguments.StringArgumentType;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import java.util.Collection;
-import java.util.List;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.arguments.EntityArgument;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.protocol.common.ClientboundTransferPacket;
-import net.minecraft.server.level.ServerPlayer;
-
-public class TransferCommand {
-    private static final SimpleCommandExceptionType ERROR_NO_PLAYERS = new SimpleCommandExceptionType(
-        Component.translatable("commands.transfer.error.no_players")
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("transfer")
-                .requires(commandSourceStack -> commandSourceStack.hasPermission(3))
-                .then(
-                    Commands.argument("hostname", StringArgumentType.string())
-                        .executes(
-                            commandContext -> transfer(
-                                commandContext.getSource(),
-                                StringArgumentType.getString(commandContext, "hostname"),
-                                25565,
-                                List.of(commandContext.getSource().getPlayerOrException())
-                            )
-                        )
-                        .then(
-                            Commands.argument("port", IntegerArgumentType.integer(1, 65535))
-                                .executes(
-                                    commandContext -> transfer(
-                                        commandContext.getSource(),
-                                        StringArgumentType.getString(commandContext, "hostname"),
-                                        IntegerArgumentType.getInteger(commandContext, "port"),
-                                        List.of(commandContext.getSource().getPlayerOrException())
-                                    )
-                                )
-                                .then(
-                                    Commands.argument("players", EntityArgument.players())
-                                        .executes(
-                                            commandContext -> transfer(
-                                                commandContext.getSource(),
-                                                StringArgumentType.getString(commandContext, "hostname"),
-                                                IntegerArgumentType.getInteger(commandContext, "port"),
-                                                EntityArgument.getPlayers(commandContext, "players")
-                                            )
-                                        )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int transfer(CommandSourceStack source, String hostname, int port, Collection<ServerPlayer> players) throws CommandSyntaxException {
-        if (players.isEmpty()) {
-            throw ERROR_NO_PLAYERS.create();
-        } else {
-            for (ServerPlayer serverPlayer : players) {
-                serverPlayer.connection.send(new ClientboundTransferPacket(hostname, port));
-            }
-
-            if (players.size() == 1) {
-                source.sendSuccess(
-                    () -> Component.translatable("commands.transfer.success.single", players.iterator().next().getDisplayName(), hostname, port), true
-                );
-            } else {
-                source.sendSuccess(() -> Component.translatable("commands.transfer.success.multiple", players.size(), hostname, port), true);
-            }
-
-            return players.size();
-        }
-    }
-}
diff --git a/net/minecraft/server/commands/WardenSpawnTrackerCommand.java b/net/minecraft/server/commands/WardenSpawnTrackerCommand.java
deleted file mode 100644
index ec1afb7c157fe41a068988da0e729f7916315475..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/WardenSpawnTrackerCommand.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.google.common.collect.ImmutableList;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.arguments.IntegerArgumentType;
-import java.util.Collection;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.network.chat.Component;
-import net.minecraft.world.entity.monster.warden.WardenSpawnTracker;
-import net.minecraft.world.entity.player.Player;
-
-public class WardenSpawnTrackerCommand {
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("warden_spawn_tracker")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.literal("clear")
-                        .executes(context -> resetTracker(context.getSource(), ImmutableList.of(context.getSource().getPlayerOrException())))
-                )
-                .then(
-                    Commands.literal("set")
-                        .then(
-                            Commands.argument("warning_level", IntegerArgumentType.integer(0, 4))
-                                .executes(
-                                    context -> setWarningLevel(
-                                        context.getSource(),
-                                        ImmutableList.of(context.getSource().getPlayerOrException()),
-                                        IntegerArgumentType.getInteger(context, "warning_level")
-                                    )
-                                )
-                        )
-                )
-        );
-    }
-
-    private static int setWarningLevel(CommandSourceStack source, Collection<? extends Player> targets, int warningLevel) {
-        for (Player player : targets) {
-            player.getWardenSpawnTracker().ifPresent(wardenSpawnTracker -> wardenSpawnTracker.setWarningLevel(warningLevel));
-        }
-
-        if (targets.size() == 1) {
-            source.sendSuccess(
-                () -> Component.translatable("commands.warden_spawn_tracker.set.success.single", targets.iterator().next().getDisplayName()), true
-            );
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.warden_spawn_tracker.set.success.multiple", targets.size()), true);
-        }
-
-        return targets.size();
-    }
-
-    private static int resetTracker(CommandSourceStack source, Collection<? extends Player> targets) {
-        for (Player player : targets) {
-            player.getWardenSpawnTracker().ifPresent(WardenSpawnTracker::reset);
-        }
-
-        if (targets.size() == 1) {
-            source.sendSuccess(
-                () -> Component.translatable("commands.warden_spawn_tracker.clear.success.single", targets.iterator().next().getDisplayName()), true
-            );
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.warden_spawn_tracker.clear.success.multiple", targets.size()), true);
-        }
-
-        return targets.size();
-    }
-}
diff --git a/net/minecraft/server/commands/WeatherCommand.java b/net/minecraft/server/commands/WeatherCommand.java
index 9b14b6218b2673e9b13b749b566e3b8a6a8d9c7d..ba6ef4fab25ebd944aa245ab63800fb5b901e4ce 100644
--- a/net/minecraft/server/commands/WeatherCommand.java
+++ b/net/minecraft/server/commands/WeatherCommand.java
@@ -18,7 +18,7 @@ public class WeatherCommand {
                 .requires(source -> source.hasPermission(2))
                 .then(
                     Commands.literal("clear")
-                        .executes(context -> setClear(context.getSource(), -1))
+                        .executes(context -> setClear(context.getSource(), DEFAULT_TIME))
                         .then(
                             Commands.argument("duration", TimeArgument.time(1))
                                 .executes(context -> setClear(context.getSource(), IntegerArgumentType.getInteger(context, "duration")))
@@ -26,7 +26,7 @@ public class WeatherCommand {
                 )
                 .then(
                     Commands.literal("rain")
-                        .executes(context -> setRain(context.getSource(), -1))
+                        .executes(context -> setRain(context.getSource(), DEFAULT_TIME))
                         .then(
                             Commands.argument("duration", TimeArgument.time(1))
                                 .executes(context -> setRain(context.getSource(), IntegerArgumentType.getInteger(context, "duration")))
@@ -34,7 +34,7 @@ public class WeatherCommand {
                 )
                 .then(
                     Commands.literal("thunder")
-                        .executes(context -> setThunder(context.getSource(), -1))
+                        .executes(context -> setThunder(context.getSource(), DEFAULT_TIME))
                         .then(
                             Commands.argument("duration", TimeArgument.time(1))
                                 .executes(context -> setThunder(context.getSource(), IntegerArgumentType.getInteger(context, "duration")))
@@ -44,7 +44,7 @@ public class WeatherCommand {
     }
 
     private static int getDuration(CommandSourceStack source, int time, IntProvider timeProvider) {
-        return time == -1 ? timeProvider.sample(source.getLevel().getRandom()) : time; // CraftBukkit - SPIGOT-7680: per-world
+        return time == DEFAULT_TIME ? timeProvider.sample(source.getLevel().getRandom()) : time; // CraftBukkit - SPIGOT-7680: per-world
     }
 
     private static int setClear(CommandSourceStack source, int time) {
diff --git a/net/minecraft/server/commands/WhitelistCommand.java b/net/minecraft/server/commands/WhitelistCommand.java
deleted file mode 100644
index 62ba3570060515b1fdaf4fb893a4dc2dea3a202d..0000000000000000000000000000000000000000
--- a/net/minecraft/server/commands/WhitelistCommand.java
+++ /dev/null
@@ -1,154 +0,0 @@
-package net.minecraft.server.commands;
-
-import com.mojang.authlib.GameProfile;
-import com.mojang.brigadier.CommandDispatcher;
-import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
-import java.util.Collection;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
-import net.minecraft.commands.SharedSuggestionProvider;
-import net.minecraft.commands.arguments.GameProfileArgument;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.players.PlayerList;
-import net.minecraft.server.players.UserWhiteList;
-import net.minecraft.server.players.UserWhiteListEntry;
-
-public class WhitelistCommand {
-    private static final SimpleCommandExceptionType ERROR_ALREADY_ENABLED = new SimpleCommandExceptionType(
-        Component.translatable("commands.whitelist.alreadyOn")
-    );
-    private static final SimpleCommandExceptionType ERROR_ALREADY_DISABLED = new SimpleCommandExceptionType(
-        Component.translatable("commands.whitelist.alreadyOff")
-    );
-    private static final SimpleCommandExceptionType ERROR_ALREADY_WHITELISTED = new SimpleCommandExceptionType(
-        Component.translatable("commands.whitelist.add.failed")
-    );
-    private static final SimpleCommandExceptionType ERROR_NOT_WHITELISTED = new SimpleCommandExceptionType(
-        Component.translatable("commands.whitelist.remove.failed")
-    );
-
-    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("whitelist")
-                .requires(source -> source.hasPermission(3))
-                .then(Commands.literal("on").executes(context -> enableWhitelist(context.getSource())))
-                .then(Commands.literal("off").executes(context -> disableWhitelist(context.getSource())))
-                .then(Commands.literal("list").executes(context -> showList(context.getSource())))
-                .then(
-                    Commands.literal("add")
-                        .then(
-                            Commands.argument("targets", GameProfileArgument.gameProfile())
-                                .suggests(
-                                    (context, builder) -> {
-                                        PlayerList playerList = context.getSource().getServer().getPlayerList();
-                                        return SharedSuggestionProvider.suggest(
-                                            playerList.getPlayers()
-                                                .stream()
-                                                .filter(player -> !playerList.getWhiteList().isWhiteListed(player.getGameProfile()))
-                                                .map(player -> player.getGameProfile().getName()),
-                                            builder
-                                        );
-                                    }
-                                )
-                                .executes(context -> addPlayers(context.getSource(), GameProfileArgument.getGameProfiles(context, "targets")))
-                        )
-                )
-                .then(
-                    Commands.literal("remove")
-                        .then(
-                            Commands.argument("targets", GameProfileArgument.gameProfile())
-                                .suggests(
-                                    (context, builder) -> SharedSuggestionProvider.suggest(
-                                        context.getSource().getServer().getPlayerList().getWhiteListNames(), builder
-                                    )
-                                )
-                                .executes(context -> removePlayers(context.getSource(), GameProfileArgument.getGameProfiles(context, "targets")))
-                        )
-                )
-                .then(Commands.literal("reload").executes(context -> reload(context.getSource())))
-        );
-    }
-
-    private static int reload(CommandSourceStack source) {
-        source.getServer().getPlayerList().reloadWhiteList();
-        source.sendSuccess(() -> Component.translatable("commands.whitelist.reloaded"), true);
-        source.getServer().kickUnlistedPlayers(source);
-        return 1;
-    }
-
-    private static int addPlayers(CommandSourceStack source, Collection<GameProfile> players) throws CommandSyntaxException {
-        UserWhiteList whiteList = source.getServer().getPlayerList().getWhiteList();
-        int i = 0;
-
-        for (GameProfile gameProfile : players) {
-            if (!whiteList.isWhiteListed(gameProfile)) {
-                UserWhiteListEntry userWhiteListEntry = new UserWhiteListEntry(gameProfile);
-                whiteList.add(userWhiteListEntry);
-                source.sendSuccess(() -> Component.translatable("commands.whitelist.add.success", Component.literal(gameProfile.getName())), true);
-                i++;
-            }
-        }
-
-        if (i == 0) {
-            throw ERROR_ALREADY_WHITELISTED.create();
-        } else {
-            return i;
-        }
-    }
-
-    private static int removePlayers(CommandSourceStack source, Collection<GameProfile> players) throws CommandSyntaxException {
-        UserWhiteList whiteList = source.getServer().getPlayerList().getWhiteList();
-        int i = 0;
-
-        for (GameProfile gameProfile : players) {
-            if (whiteList.isWhiteListed(gameProfile)) {
-                UserWhiteListEntry userWhiteListEntry = new UserWhiteListEntry(gameProfile);
-                whiteList.remove(userWhiteListEntry);
-                source.sendSuccess(() -> Component.translatable("commands.whitelist.remove.success", Component.literal(gameProfile.getName())), true);
-                i++;
-            }
-        }
-
-        if (i == 0) {
-            throw ERROR_NOT_WHITELISTED.create();
-        } else {
-            source.getServer().kickUnlistedPlayers(source);
-            return i;
-        }
-    }
-
-    private static int enableWhitelist(CommandSourceStack source) throws CommandSyntaxException {
-        PlayerList playerList = source.getServer().getPlayerList();
-        if (playerList.isUsingWhitelist()) {
-            throw ERROR_ALREADY_ENABLED.create();
-        } else {
-            playerList.setUsingWhiteList(true);
-            source.sendSuccess(() -> Component.translatable("commands.whitelist.enabled"), true);
-            source.getServer().kickUnlistedPlayers(source);
-            return 1;
-        }
-    }
-
-    private static int disableWhitelist(CommandSourceStack source) throws CommandSyntaxException {
-        PlayerList playerList = source.getServer().getPlayerList();
-        if (!playerList.isUsingWhitelist()) {
-            throw ERROR_ALREADY_DISABLED.create();
-        } else {
-            playerList.setUsingWhiteList(false);
-            source.sendSuccess(() -> Component.translatable("commands.whitelist.disabled"), true);
-            return 1;
-        }
-    }
-
-    private static int showList(CommandSourceStack source) {
-        String[] whiteListNames = source.getServer().getPlayerList().getWhiteListNames();
-        if (whiteListNames.length == 0) {
-            source.sendSuccess(() -> Component.translatable("commands.whitelist.none"), false);
-        } else {
-            source.sendSuccess(() -> Component.translatable("commands.whitelist.list", whiteListNames.length, String.join(", ", whiteListNames)), false);
-        }
-
-        return whiteListNames.length;
-    }
-}
diff --git a/net/minecraft/server/commands/data/DataCommands.java b/net/minecraft/server/commands/data/DataCommands.java
index 4bbbfefc81fd58f030a80cbf751ff746cc650e30..826d1a462a38909f7330ba82eec4d01eb52fc5f6 100644
--- a/net/minecraft/server/commands/data/DataCommands.java
+++ b/net/minecraft/server/commands/data/DataCommands.java
@@ -24,7 +24,6 @@ import net.minecraft.commands.Commands;
 import net.minecraft.commands.arguments.CompoundTagArgument;
 import net.minecraft.commands.arguments.NbtPathArgument;
 import net.minecraft.commands.arguments.NbtTagArgument;
-import net.minecraft.nbt.CollectionTag;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NumericTag;
 import net.minecraft.nbt.StringTag;
@@ -347,7 +346,7 @@ public class DataCommands {
             throw ERROR_MERGE_UNCHANGED.create();
         } else {
             dataAccessor.setData(data);
-            source.getSource().sendSuccess(() -> dataAccessor.getModifiedSuccess(), true);
+            source.getSource().sendSuccess(dataAccessor::getModifiedSuccess, true);
             return i;
         }
     }
@@ -359,7 +358,7 @@ public class DataCommands {
             throw ERROR_MERGE_UNCHANGED.create();
         } else {
             accessor.setData(data);
-            source.sendSuccess(() -> accessor.getModifiedSuccess(), true);
+            source.sendSuccess(accessor::getModifiedSuccess, true);
             return i;
         }
     }
@@ -378,18 +377,18 @@ public class DataCommands {
     private static int getData(CommandSourceStack source, DataAccessor accessor, NbtPathArgument.NbtPath path) throws CommandSyntaxException {
         Tag singleTag = getSingleTag(path, accessor);
         int floor;
-        if (singleTag instanceof NumericTag) {
-            floor = Mth.floor(((NumericTag)singleTag).getAsDouble());
-        } else if (singleTag instanceof CollectionTag) {
-            floor = ((CollectionTag)singleTag).size();
-        } else if (singleTag instanceof CompoundTag) {
-            floor = ((CompoundTag)singleTag).size();
-        } else {
-            if (!(singleTag instanceof StringTag)) {
-                throw ERROR_GET_NON_EXISTENT.create(path.toString());
-            }
+        switch (singleTag) {
+            case net.minecraft.nbt.NumericTag numericTag ->
+                floor = net.minecraft.util.Mth.floor(numericTag.getAsDouble());
+            case net.minecraft.nbt.CollectionTag collectionTag -> floor = collectionTag.size();
+            case net.minecraft.nbt.CompoundTag compoundTag -> floor = compoundTag.size();
+            default -> {
+                if (!(singleTag instanceof net.minecraft.nbt.StringTag)) {
+                    throw ERROR_GET_NON_EXISTENT.create(path.toString());
+                }
 
-            floor = singleTag.getAsString().length();
+                floor = singleTag.getAsString().length();
+            }
         }
 
         source.sendSuccess(() -> accessor.getPrintSuccess(singleTag), false);
@@ -423,7 +422,7 @@ public class DataCommands {
                 throw ERROR_MERGE_UNCHANGED.create();
             } else {
                 accessor.setData(compoundTag);
-                source.sendSuccess(() -> accessor.getModifiedSuccess(), true);
+                source.sendSuccess(accessor::getModifiedSuccess, true);
                 return 1;
             }
         }
diff --git a/net/minecraft/server/dedicated/DedicatedServer.java b/net/minecraft/server/dedicated/DedicatedServer.java
index d2db6e3a4af13984b0a790fb38e83c253914a973..7ed32a62b254cebb5e3902045dd9d891c541ad37 100644
--- a/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/net/minecraft/server/dedicated/DedicatedServer.java
@@ -1,26 +1,20 @@
 package net.minecraft.server.dedicated;
 
-import com.google.common.collect.Lists;
 import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
-import java.io.BufferedReader;
 import java.io.IOException;
-import java.io.InputStreamReader;
 import java.io.Writer;
 import java.net.InetAddress;
 import java.net.Proxy;
 import java.net.URI;
-import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
 import java.util.Optional;
 import javax.annotation.Nullable;
 import net.minecraft.DefaultUncaughtExceptionHandler;
-import net.minecraft.DefaultUncaughtExceptionHandlerWithName;
 import net.minecraft.SharedConstants;
 import net.minecraft.SystemReport;
 import net.minecraft.Util;
@@ -41,9 +35,6 @@ import net.minecraft.server.network.TextFilter;
 import net.minecraft.server.packs.repository.PackRepository;
 import net.minecraft.server.players.GameProfileCache;
 import net.minecraft.server.players.OldUsersConverter;
-import net.minecraft.server.rcon.RconConsoleSource;
-import net.minecraft.server.rcon.thread.QueryThreadGs4;
-import net.minecraft.server.rcon.thread.RconThread;
 import net.minecraft.util.Mth;
 import net.minecraft.util.debugchart.DebugSampleSubscriptionTracker;
 import net.minecraft.util.debugchart.RemoteDebugSampleType;
@@ -64,11 +55,6 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
     private static final int CONVERSION_RETRY_DELAY_MS = 5000;
     private static final int CONVERSION_RETRIES = 2;
     private final java.util.Queue<ConsoleInput> serverCommandQueue = new java.util.concurrent.ConcurrentLinkedQueue<>(); // Paper - Perf: use a proper queue
-    @Nullable
-    private QueryThreadGs4 queryThreadGs4;
-    // private final RconConsoleSource rconConsoleSource; // CraftBukkit - remove field
-    @Nullable
-    private RconThread rconThread;
     public DedicatedServerSettings settings;
     @Nullable
     private MinecraftServerGui gui;
@@ -327,24 +313,6 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
                 this.getGameRules().getRule(GameRules.RULE_ANNOUNCE_ADVANCEMENTS).set(properties.announcePlayerAchievements, this.overworld()); // CraftBukkit - per-world
             }
 
-            if (properties.enableQuery) {
-                LOGGER.info("Starting GS4 status listener");
-                this.queryThreadGs4 = QueryThreadGs4.create(this);
-            }
-
-            if (properties.enableRcon) {
-                LOGGER.info("Starting remote control listener");
-                this.rconThread = RconThread.create(this);
-            }
-
-            if (false && this.getMaxTickLength() > 0L) { // Spigot - disable
-                Thread thread1 = new Thread(new ServerWatchdog(this));
-                thread1.setUncaughtExceptionHandler(new DefaultUncaughtExceptionHandlerWithName(LOGGER));
-                thread1.setName("Server Watchdog");
-                thread1.setDaemon(true);
-                thread1.start();
-            }
-
             if (properties.enableJmxMonitoring) {
                 MinecraftServerStatistics.registerJmxMonitoring(this);
                 LOGGER.info("JMX monitoring enabled");
@@ -410,14 +378,6 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             this.gui.close();
         }
 
-        if (this.rconThread != null) {
-            this.rconThread.stopNonBlocking(); // Paper - don't wait for remote connections
-        }
-
-        if (this.queryThreadGs4 != null) {
-            // this.remoteStatusListener.stop(); // Paper - don't wait for remote connections
-        }
-
         this.hasFullyShutdown = true; // Paper - Improved watchdog support
         System.exit(this.abnormalExit ? 70 : 0); // CraftBukkit // Paper - Improved watchdog support
     }
@@ -545,10 +505,6 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
     public boolean isUnderSpawnProtection(ServerLevel level, BlockPos pos, Player player) {
         if (level.dimension() != Level.OVERWORLD) {
             return false;
-        } else if (this.getPlayerList().getOps().isEmpty()) {
-            return false;
-        } else if (this.getPlayerList().isOp(player.getGameProfile())) {
-            return false;
         } else if (this.getSpawnProtectionRadius() <= 0) {
             return false;
         } else {
@@ -586,11 +542,6 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         this.settings.update(dedicatedServerProperties -> dedicatedServerProperties.playerIdleTimeout.update(this.registryAccess(), idleTimeout));
     }
 
-    @Override
-    public boolean shouldRconBroadcast() {
-        return this.getProperties().broadcastRconToOps;
-    }
-
     @Override
     public boolean shouldInformAdmins() {
         return this.getProperties().broadcastConsoleToOps;
@@ -622,50 +573,6 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
     }
 
     protected boolean convertOldUsers() {
-        boolean flag = false;
-
-        for (int i = 0; !flag && i <= 2; i++) {
-            if (i > 0) {
-                LOGGER.warn("Encountered a problem while converting the user banlist, retrying in a few seconds");
-                this.waitForRetry();
-            }
-
-            flag = OldUsersConverter.convertUserBanlist(this);
-        }
-
-        boolean flag1 = false;
-
-        for (int var7 = 0; !flag1 && var7 <= 2; var7++) {
-            if (var7 > 0) {
-                LOGGER.warn("Encountered a problem while converting the ip banlist, retrying in a few seconds");
-                this.waitForRetry();
-            }
-
-            flag1 = OldUsersConverter.convertIpBanlist(this);
-        }
-
-        boolean flag2 = false;
-
-        for (int var8 = 0; !flag2 && var8 <= 2; var8++) {
-            if (var8 > 0) {
-                LOGGER.warn("Encountered a problem while converting the op list, retrying in a few seconds");
-                this.waitForRetry();
-            }
-
-            flag2 = OldUsersConverter.convertOpsList(this);
-        }
-
-        boolean flag3 = false;
-
-        for (int var9 = 0; !flag3 && var9 <= 2; var9++) {
-            if (var9 > 0) {
-                LOGGER.warn("Encountered a problem while converting the whitelist, retrying in a few seconds");
-                this.waitForRetry();
-            }
-
-            flag3 = OldUsersConverter.convertWhiteList(this);
-        }
-
         boolean flag4 = false;
 
         for (int var10 = 0; !flag4 && var10 <= 2; var10++) {
@@ -677,7 +584,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             flag4 = OldUsersConverter.convertPlayers(this);
         }
 
-        return flag || flag1 || flag2 || flag3 || flag4;
+        return flag4;
     }
 
     private void waitForRetry() {
@@ -730,24 +637,6 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         throw new UnsupportedOperationException("Not supported - remote source required.");
     }
 
-    public String runCommand(RconConsoleSource rconConsoleSource, String s) {
-        if (s.isBlank()) return ""; // Paper - Do not process empty rcon commands
-
-        rconConsoleSource.prepareForCommand();
-        this.executeBlocking(() -> {
-            CommandSourceStack wrapper = rconConsoleSource.createCommandSourceStack();
-            org.bukkit.event.server.RemoteServerCommandEvent event = new org.bukkit.event.server.RemoteServerCommandEvent(rconConsoleSource.getBukkitSender(wrapper), s);
-            this.server.getPluginManager().callEvent(event);
-            if (event.isCancelled()) {
-                return;
-            }
-            ConsoleInput serverCommand = new ConsoleInput(event.getCommand(), wrapper);
-            this.server.dispatchServerCommand(event.getSender(), serverCommand);
-        });
-        return rconConsoleSource.getCommandResponse();
-        // CraftBukkit end
-    }
-
     public void storeUsingWhiteList(boolean isStoreUsingWhiteList) {
         this.settings.update(properties -> properties.whiteList.update(this.registryAccess(), isStoreUsingWhiteList));
     }
diff --git a/net/minecraft/server/dedicated/DedicatedServerProperties.java b/net/minecraft/server/dedicated/DedicatedServerProperties.java
index f6518e29f805018c72222f5aaa7b662071665b65..56ad07d6a6712b3dd08e8567a15774212ca14137 100644
--- a/net/minecraft/server/dedicated/DedicatedServerProperties.java
+++ b/net/minecraft/server/dedicated/DedicatedServerProperties.java
@@ -63,11 +63,6 @@ public class DedicatedServerProperties extends Settings<DedicatedServerPropertie
     public final int serverPort = this.get("server-port", 25565);
     @Nullable
     public final Boolean announcePlayerAchievements = this.getLegacyBoolean("announce-player-achievements");
-    public final boolean enableQuery = this.get("enable-query", false);
-    public final int queryPort = this.get("query.port", 25565);
-    public final boolean enableRcon = this.get("enable-rcon", false);
-    public final int rconPort = this.get("rcon.port", 25575);
-    public final String rconPassword = this.get("rcon.password", "");
     public final boolean hardcore = this.get("hardcore", false);
     public final boolean allowNether = this.get("allow-nether", true);
     public final boolean spawnMonsters = this.get("spawn-monsters", true);
@@ -83,7 +78,6 @@ public class DedicatedServerProperties extends Settings<DedicatedServerPropertie
     public final int simulationDistance = this.get("simulation-distance", 10);
     public final int maxPlayers = this.get("max-players", 20);
     public final int networkCompressionThreshold = this.get("network-compression-threshold", 256);
-    public final boolean broadcastRconToOps = this.get("broadcast-rcon-to-ops", true);
     public final boolean broadcastConsoleToOps = this.get("broadcast-console-to-ops", true);
     public final int maxWorldSize = this.get("max-world-size", property -> Mth.clamp(property, 1, 29999984), 29999984);
     public final boolean syncChunkWrites = this.get("sync-chunk-writes", true) && Boolean.getBoolean("Paper.enable-sync-chunk-writes"); // Paper - Hide sync chunk writes behind flag
@@ -104,7 +98,6 @@ public class DedicatedServerProperties extends Settings<DedicatedServerPropertie
     private final DedicatedServerProperties.WorldDimensionData worldDimensionData;
     public final WorldOptions worldOptions;
     public boolean acceptsTransfers = this.get("accepts-transfers", false);
-    public final String rconIp; // Paper - Configurable rcon ip
 
     // CraftBukkit start
     public DedicatedServerProperties(Properties properties, joptsimple.OptionSet optionset) {
@@ -130,10 +123,6 @@ public class DedicatedServerProperties extends Settings<DedicatedServerPropertie
             this.get("initial-enabled-packs", String.join(",", WorldDataConfiguration.DEFAULT.dataPacks().getEnabled())),
             this.get("initial-disabled-packs", String.join(",", WorldDataConfiguration.DEFAULT.dataPacks().getDisabled()))
         );
-        // Paper start - Configurable rcon ip
-        final String rconIp = this.getStringRaw("rcon.ip");
-        this.rconIp = rconIp == null ? this.serverIp : rconIp;
-        // Paper end - Configurable rcon ip
     }
 
     // CraftBukkit start
diff --git a/net/minecraft/server/players/BanListEntry.java b/net/minecraft/server/players/BanListEntry.java
deleted file mode 100644
index e111adec2116f922fe67ee434635e50c60dad15c..0000000000000000000000000000000000000000
--- a/net/minecraft/server/players/BanListEntry.java
+++ /dev/null
@@ -1,101 +0,0 @@
-package net.minecraft.server.players;
-
-import com.google.gson.JsonObject;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-import javax.annotation.Nullable;
-import net.minecraft.network.chat.Component;
-
-public abstract class BanListEntry<T> extends StoredUserEntry<T> {
-    public static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z", Locale.ROOT);
-    public static final String EXPIRES_NEVER = "forever";
-    protected final Date created;
-    protected final String source;
-    @Nullable
-    protected final Date expires;
-    protected final String reason;
-
-    public BanListEntry(@Nullable T user, @Nullable Date created, @Nullable String source, @Nullable Date expires, @Nullable String reason) {
-        super(user);
-        this.created = created == null ? new Date() : created;
-        this.source = source == null ? "(Unknown)" : source;
-        this.expires = expires;
-        this.reason = reason == null ? "Banned by an operator." : reason;
-    }
-
-    protected BanListEntry(@Nullable T user, JsonObject entryData) {
-        super(BanListEntry.checkExpiry(user, entryData)); // CraftBukkit
-
-        Date date;
-        try {
-            date = entryData.has("created") ? DATE_FORMAT.parse(entryData.get("created").getAsString()) : new Date();
-        } catch (ParseException var7) {
-            date = new Date();
-        }
-
-        this.created = date;
-        this.source = entryData.has("source") ? entryData.get("source").getAsString() : "(Unknown)";
-
-        Date date1;
-        try {
-            date1 = entryData.has("expires") ? DATE_FORMAT.parse(entryData.get("expires").getAsString()) : null;
-        } catch (ParseException var6) {
-            date1 = null;
-        }
-
-        this.expires = date1;
-        this.reason = entryData.has("reason") ? entryData.get("reason").getAsString() : "Banned by an operator.";
-    }
-
-    public Date getCreated() {
-        return this.created;
-    }
-
-    public String getSource() {
-        return this.source;
-    }
-
-    @Nullable
-    public Date getExpires() {
-        return this.expires;
-    }
-
-    public String getReason() {
-        return this.reason;
-    }
-
-    public abstract Component getDisplayName();
-
-    @Override
-    boolean hasExpired() {
-        return this.expires != null && this.expires.before(new Date());
-    }
-
-    @Override
-    protected void serialize(JsonObject data) {
-        data.addProperty("created", DATE_FORMAT.format(this.created));
-        data.addProperty("source", this.source);
-        data.addProperty("expires", this.expires == null ? "forever" : DATE_FORMAT.format(this.expires));
-        data.addProperty("reason", this.reason);
-    }
-
-    // CraftBukkit start
-    private static <T> T checkExpiry(T object, JsonObject jsonobject) {
-        Date expires = null;
-
-        try {
-            expires = jsonobject.has("expires") ? BanListEntry.DATE_FORMAT.parse(jsonobject.get("expires").getAsString()) : null;
-        } catch (ParseException ex) {
-            // Guess we don't have a date
-        }
-
-        if (expires == null || expires.after(new Date())) {
-            return object;
-        } else {
-            return null;
-        }
-    }
-    // CraftBukkit end
-}
diff --git a/net/minecraft/server/players/GameProfileCache.java b/net/minecraft/server/players/GameProfileCache.java
index 6fb3712f33a84a3612752dcfd9e97d67066f610e..e53561c160272b7a942f2c170d1d1edfd3d176fb 100644
--- a/net/minecraft/server/players/GameProfileCache.java
+++ b/net/minecraft/server/players/GameProfileCache.java
@@ -1,6 +1,5 @@
 package net.minecraft.server.players;
 
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.io.Files;
diff --git a/net/minecraft/server/players/IpBanList.java b/net/minecraft/server/players/IpBanList.java
deleted file mode 100644
index b41c44f5d3ba7d1ebfd21e5ab980f32ac59311ce..0000000000000000000000000000000000000000
--- a/net/minecraft/server/players/IpBanList.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package net.minecraft.server.players;
-
-import com.google.gson.JsonObject;
-import java.io.File;
-import java.net.SocketAddress;
-import javax.annotation.Nullable;
-
-public class IpBanList extends StoredUserList<String, IpBanListEntry> {
-    public IpBanList(File file) {
-        super(file);
-    }
-
-    @Override
-    protected StoredUserEntry<String> createEntry(JsonObject entryData) {
-        return new IpBanListEntry(entryData);
-    }
-
-    public boolean isBanned(SocketAddress address) {
-        String ipFromAddress = this.getIpFromAddress(address);
-        return this.contains(ipFromAddress);
-    }
-
-    public boolean isBanned(String address) {
-        return this.contains(address);
-    }
-
-    @Nullable
-    public IpBanListEntry get(SocketAddress address) {
-        String ipFromAddress = this.getIpFromAddress(address);
-        return this.get(ipFromAddress);
-    }
-
-    private String getIpFromAddress(SocketAddress address) {
-        String string = address.toString();
-        if (string.contains("/")) {
-            string = string.substring(string.indexOf(47) + 1);
-        }
-
-        if (string.contains(":")) {
-            string = string.substring(0, string.indexOf(58));
-        }
-
-        return string;
-    }
-}
diff --git a/net/minecraft/server/players/IpBanListEntry.java b/net/minecraft/server/players/IpBanListEntry.java
deleted file mode 100644
index 6b1473010728b7399ee8977982b66e2670eac587..0000000000000000000000000000000000000000
--- a/net/minecraft/server/players/IpBanListEntry.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package net.minecraft.server.players;
-
-import com.google.gson.JsonObject;
-import java.util.Date;
-import javax.annotation.Nullable;
-import net.minecraft.network.chat.Component;
-
-public class IpBanListEntry extends BanListEntry<String> {
-    public IpBanListEntry(String ip) {
-        this(ip, null, null, null, null);
-    }
-
-    public IpBanListEntry(String ip, @Nullable Date created, @Nullable String source, @Nullable Date expires, @Nullable String reason) {
-        super(ip, created, source, expires, reason);
-    }
-
-    @Override
-    public Component getDisplayName() {
-        return Component.literal(String.valueOf(this.getUser()));
-    }
-
-    public IpBanListEntry(JsonObject entryData) {
-        super(createIpInfo(entryData), entryData);
-    }
-
-    private static String createIpInfo(JsonObject json) {
-        return json.has("ip") ? json.get("ip").getAsString() : null;
-    }
-
-    @Override
-    protected void serialize(JsonObject data) {
-        if (this.getUser() != null) {
-            data.addProperty("ip", this.getUser());
-            super.serialize(data);
-        }
-    }
-}
diff --git a/net/minecraft/server/players/OldUsersConverter.java b/net/minecraft/server/players/OldUsersConverter.java
index 7dbcd9d96f052bb10127ad2b061154c23cc9ffd4..f754063a237cef2e5b9b276b369ae573cfba699b 100644
--- a/net/minecraft/server/players/OldUsersConverter.java
+++ b/net/minecraft/server/players/OldUsersConverter.java
@@ -1,21 +1,14 @@
 package net.minecraft.server.players;
 
 import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import com.google.common.io.Files;
 import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.ProfileLookupCallback;
 import com.mojang.authlib.yggdrasil.ProfileNotFoundException;
 import com.mojang.logging.LogUtils;
 import java.io.File;
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.text.ParseException;
 import java.util.Collection;
-import java.util.Date;
 import java.util.List;
 import java.util.Locale;
-import java.util.Map;
 import java.util.Optional;
 import java.util.UUID;
 import javax.annotation.Nullable;
@@ -31,24 +24,6 @@ import org.slf4j.Logger;
 
 public class OldUsersConverter {
     static final Logger LOGGER = LogUtils.getLogger();
-    public static final File OLD_IPBANLIST = new File("banned-ips.txt");
-    public static final File OLD_USERBANLIST = new File("banned-players.txt");
-    public static final File OLD_OPLIST = new File("ops.txt");
-    public static final File OLD_WHITELIST = new File("white-list.txt");
-
-    static List<String> readOldListFormat(File inFile, Map<String, String[]> read) throws IOException {
-        List<String> lines = Files.readLines(inFile, StandardCharsets.UTF_8);
-
-        for (String string : lines) {
-            string = string.trim();
-            if (!string.startsWith("#") && string.length() >= 1) {
-                String[] parts = string.split("\\|");
-                read.put(parts[0].toLowerCase(Locale.ROOT), parts);
-            }
-        }
-
-        return lines;
-    }
 
     private static void lookupPlayers(MinecraftServer server, Collection<String> names, ProfileLookupCallback callback) {
         String[] strings = names.stream().filter(name -> !StringUtil.isNullOrEmpty(name)).toArray(String[]::new);
@@ -62,185 +37,6 @@ public class OldUsersConverter {
         }
     }
 
-    public static boolean convertUserBanlist(final MinecraftServer server) {
-        final UserBanList userBanList = new UserBanList(PlayerList.USERBANLIST_FILE);
-        if (OLD_USERBANLIST.exists() && OLD_USERBANLIST.isFile()) {
-            if (userBanList.getFile().exists()) {
-                try {
-                    userBanList.load();
-                } catch (IOException var6) {
-                    LOGGER.warn("Could not load existing file {}", userBanList.getFile().getName()); // CraftBukkit - don't print stacktrace
-                }
-            }
-
-            try {
-                final Map<String, String[]> map = Maps.newHashMap();
-                readOldListFormat(OLD_USERBANLIST, map);
-                ProfileLookupCallback profileLookupCallback = new ProfileLookupCallback() {
-                    @Override
-                    public void onProfileLookupSucceeded(GameProfile gameProfile) {
-                        server.getProfileCache().add(gameProfile);
-                        String[] strings = map.get(gameProfile.getName().toLowerCase(Locale.ROOT));
-                        if (strings == null) {
-                            OldUsersConverter.LOGGER.warn("Could not convert user banlist entry for {}", gameProfile.getName());
-                            throw new OldUsersConverter.ConversionError("Profile not in the conversionlist");
-                        } else {
-                            Date date = strings.length > 1 ? OldUsersConverter.parseDate(strings[1], null) : null;
-                            String string = strings.length > 2 ? strings[2] : null;
-                            Date date1 = strings.length > 3 ? OldUsersConverter.parseDate(strings[3], null) : null;
-                            String string1 = strings.length > 4 ? strings[4] : null;
-                            userBanList.add(new UserBanListEntry(gameProfile, date, string, date1, string1));
-                        }
-                    }
-
-                    @Override
-                    public void onProfileLookupFailed(String profileName, Exception exception) {
-                        OldUsersConverter.LOGGER.warn("Could not lookup user banlist entry for {}", profileName, exception);
-                        if (!(exception instanceof ProfileNotFoundException)) {
-                            throw new OldUsersConverter.ConversionError("Could not request user " + profileName + " from backend systems", exception);
-                        }
-                    }
-                };
-                lookupPlayers(server, map.keySet(), profileLookupCallback);
-                userBanList.save();
-                renameOldFile(OLD_USERBANLIST);
-                return true;
-            } catch (IOException var4) {
-                LOGGER.warn("Could not read old user banlist to convert it!", (Throwable)var4);
-                return false;
-            } catch (OldUsersConverter.ConversionError var5) {
-                LOGGER.error("Conversion failed, please try again later", (Throwable)var5);
-                return false;
-            }
-        } else {
-            return true;
-        }
-    }
-
-    public static boolean convertIpBanlist(MinecraftServer server) {
-        IpBanList ipBanList = new IpBanList(PlayerList.IPBANLIST_FILE);
-        if (OLD_IPBANLIST.exists() && OLD_IPBANLIST.isFile()) {
-            if (ipBanList.getFile().exists()) {
-                try {
-                    ipBanList.load();
-                } catch (IOException var11) {
-                    LOGGER.warn("Could not load existing file {}", ipBanList.getFile().getName()); // CraftBukkit - don't print stacktrace
-                }
-            }
-
-            try {
-                Map<String, String[]> map = Maps.newHashMap();
-                readOldListFormat(OLD_IPBANLIST, map);
-
-                for (String string : map.keySet()) {
-                    String[] strings = map.get(string);
-                    Date date = strings.length > 1 ? parseDate(strings[1], null) : null;
-                    String string1 = strings.length > 2 ? strings[2] : null;
-                    Date date1 = strings.length > 3 ? parseDate(strings[3], null) : null;
-                    String string2 = strings.length > 4 ? strings[4] : null;
-                    ipBanList.add(new IpBanListEntry(string, date, string1, date1, string2));
-                }
-
-                ipBanList.save();
-                renameOldFile(OLD_IPBANLIST);
-                return true;
-            } catch (IOException var10) {
-                LOGGER.warn("Could not parse old ip banlist to convert it!", (Throwable)var10);
-                return false;
-            }
-        } else {
-            return true;
-        }
-    }
-
-    public static boolean convertOpsList(final MinecraftServer server) {
-        final ServerOpList serverOpList = new ServerOpList(PlayerList.OPLIST_FILE);
-        if (OLD_OPLIST.exists() && OLD_OPLIST.isFile()) {
-            if (serverOpList.getFile().exists()) {
-                try {
-                    serverOpList.load();
-                } catch (IOException var6) {
-                    LOGGER.warn("Could not load existing file {}", serverOpList.getFile().getName()); // CraftBukkit - don't print stacktrace
-                }
-            }
-
-            try {
-                List<String> lines = Files.readLines(OLD_OPLIST, StandardCharsets.UTF_8);
-                ProfileLookupCallback profileLookupCallback = new ProfileLookupCallback() {
-                    @Override
-                    public void onProfileLookupSucceeded(GameProfile gameProfile) {
-                        server.getProfileCache().add(gameProfile);
-                        serverOpList.add(new ServerOpListEntry(gameProfile, server.getOperatorUserPermissionLevel(), false));
-                    }
-
-                    @Override
-                    public void onProfileLookupFailed(String profileName, Exception exception) {
-                        OldUsersConverter.LOGGER.warn("Could not lookup oplist entry for {}", profileName, exception);
-                        if (!(exception instanceof ProfileNotFoundException)) {
-                            throw new OldUsersConverter.ConversionError("Could not request user " + profileName + " from backend systems", exception);
-                        }
-                    }
-                };
-                lookupPlayers(server, lines, profileLookupCallback);
-                serverOpList.save();
-                renameOldFile(OLD_OPLIST);
-                return true;
-            } catch (IOException var4) {
-                LOGGER.warn("Could not read old oplist to convert it!", (Throwable)var4);
-                return false;
-            } catch (OldUsersConverter.ConversionError var5) {
-                LOGGER.error("Conversion failed, please try again later", (Throwable)var5);
-                return false;
-            }
-        } else {
-            return true;
-        }
-    }
-
-    public static boolean convertWhiteList(final MinecraftServer server) {
-        final UserWhiteList userWhiteList = new UserWhiteList(PlayerList.WHITELIST_FILE);
-        if (OLD_WHITELIST.exists() && OLD_WHITELIST.isFile()) {
-            if (userWhiteList.getFile().exists()) {
-                try {
-                    userWhiteList.load();
-                } catch (IOException var6) {
-                    LOGGER.warn("Could not load existing file {}", userWhiteList.getFile().getName()); // CraftBukkit - don't print stacktrace
-                }
-            }
-
-            try {
-                List<String> lines = Files.readLines(OLD_WHITELIST, StandardCharsets.UTF_8);
-                ProfileLookupCallback profileLookupCallback = new ProfileLookupCallback() {
-                    @Override
-                    public void onProfileLookupSucceeded(GameProfile gameProfile) {
-                        server.getProfileCache().add(gameProfile);
-                        userWhiteList.add(new UserWhiteListEntry(gameProfile));
-                    }
-
-                    @Override
-                    public void onProfileLookupFailed(String profileName, Exception exception) {
-                        OldUsersConverter.LOGGER.warn("Could not lookup user whitelist entry for {}", profileName, exception);
-                        if (!(exception instanceof ProfileNotFoundException)) {
-                            throw new OldUsersConverter.ConversionError("Could not request user " + profileName + " from backend systems", exception);
-                        }
-                    }
-                };
-                lookupPlayers(server, lines, profileLookupCallback);
-                userWhiteList.save();
-                renameOldFile(OLD_WHITELIST);
-                return true;
-            } catch (IOException var4) {
-                LOGGER.warn("Could not read old whitelist to convert it!", (Throwable)var4);
-                return false;
-            } catch (OldUsersConverter.ConversionError var5) {
-                LOGGER.error("Conversion failed, please try again later", (Throwable)var5);
-                return false;
-            }
-        } else {
-            return true;
-        }
-    }
-
     @Nullable
     public static UUID convertMobOwnerIfNecessary(final MinecraftServer server, String username) {
         if (!StringUtil.isNullOrEmpty(username) && username.length() <= 16) {
@@ -262,7 +58,7 @@ public class OldUsersConverter {
                     }
                 };
                 lookupPlayers(server, Lists.newArrayList(username), profileLookupCallback);
-                return !list.isEmpty() ? list.get(0).getId() : null;
+                return !list.isEmpty() ? list.getFirst().getId() : null;
             } else {
                 return UUIDUtil.createOfflinePlayerUUID(username);
             }
@@ -294,7 +90,7 @@ public class OldUsersConverter {
             }
 
             try {
-                final String[] strings = list.toArray(new String[list.size()]);
+                final String[] strings = list.toArray(new String[0]);
                 ProfileLookupCallback profileLookupCallback = new ProfileLookupCallback() {
                     @Override
                     public void onProfileLookupSucceeded(GameProfile gameProfile) {
@@ -374,7 +170,7 @@ public class OldUsersConverter {
                 lookupPlayers(server, Lists.newArrayList(strings), profileLookupCallback);
                 return true;
             } catch (OldUsersConverter.ConversionError var12) {
-                LOGGER.error("Conversion failed, please try again later", (Throwable)var12);
+                LOGGER.error("Conversion failed, please try again later", var12);
                 return false;
             }
         } else {
@@ -393,61 +189,14 @@ public class OldUsersConverter {
     }
 
     public static boolean serverReadyAfterUserconversion(MinecraftServer server) {
-        boolean flag = areOldUserlistsRemoved();
-        return flag && areOldPlayersConverted(server);
-    }
-
-    private static boolean areOldUserlistsRemoved() {
-        boolean flag = false;
-        if (OLD_USERBANLIST.exists() && OLD_USERBANLIST.isFile()) {
-            flag = true;
-        }
-
-        boolean flag1 = false;
-        if (OLD_IPBANLIST.exists() && OLD_IPBANLIST.isFile()) {
-            flag1 = true;
-        }
-
-        boolean flag2 = false;
-        if (OLD_OPLIST.exists() && OLD_OPLIST.isFile()) {
-            flag2 = true;
-        }
-
-        boolean flag3 = false;
-        if (OLD_WHITELIST.exists() && OLD_WHITELIST.isFile()) {
-            flag3 = true;
-        }
-
-        if (!flag && !flag1 && !flag2 && !flag3) {
-            return true;
-        } else {
-            LOGGER.warn("**** FAILED TO START THE SERVER AFTER ACCOUNT CONVERSION!");
-            LOGGER.warn("** please remove the following files and restart the server:");
-            if (flag) {
-                LOGGER.warn("* {}", OLD_USERBANLIST.getName());
-            }
-
-            if (flag1) {
-                LOGGER.warn("* {}", OLD_IPBANLIST.getName());
-            }
-
-            if (flag2) {
-                LOGGER.warn("* {}", OLD_OPLIST.getName());
-            }
-
-            if (flag3) {
-                LOGGER.warn("* {}", OLD_WHITELIST.getName());
-            }
-
-            return false;
-        }
+        return areOldPlayersConverted(server);
     }
 
     private static boolean areOldPlayersConverted(MinecraftServer server) {
         File worldPlayersDirectory = getWorldPlayersDirectory(server);
         if (!worldPlayersDirectory.exists()
             || !worldPlayersDirectory.isDirectory()
-            || worldPlayersDirectory.list().length <= 0 && worldPlayersDirectory.delete()) {
+            || worldPlayersDirectory.list().length == 0 && worldPlayersDirectory.delete()) {
             return true;
         } else {
             LOGGER.warn("**** DETECTED OLD PLAYER DIRECTORY IN THE WORLD SAVE");
@@ -461,22 +210,6 @@ public class OldUsersConverter {
         return server.getWorldPath(LevelResource.PLAYER_OLD_DATA_DIR).toFile();
     }
 
-    private static void renameOldFile(File convertedFile) {
-        File file = new File(convertedFile.getName() + ".converted");
-        convertedFile.renameTo(file);
-    }
-
-    static Date parseDate(String input, Date defaultValue) {
-        Date date;
-        try {
-            date = BanListEntry.DATE_FORMAT.parse(input);
-        } catch (ParseException var4) {
-            date = defaultValue;
-        }
-
-        return date;
-    }
-
     static class ConversionError extends RuntimeException {
         ConversionError(String message, Throwable cause) {
             super(message, cause);
diff --git a/net/minecraft/server/players/PlayerList.java b/net/minecraft/server/players/PlayerList.java
index c9dbe659374e3ce140316116e05110567e44b810..7133951378ac3aaf8f926c0a413db43a780af992 100644
--- a/net/minecraft/server/players/PlayerList.java
+++ b/net/minecraft/server/players/PlayerList.java
@@ -9,7 +9,6 @@ import com.mojang.serialization.Dynamic;
 import java.io.File;
 import java.net.SocketAddress;
 import java.nio.file.Path;
-import java.text.SimpleDateFormat;
 import java.time.Instant;
 import java.util.EnumSet;
 import java.util.List;
@@ -102,40 +101,27 @@ import net.minecraft.world.scores.Team;
 import org.slf4j.Logger;
 
 public abstract class PlayerList {
-    public static final File USERBANLIST_FILE = new File("banned-players.json");
-    public static final File IPBANLIST_FILE = new File("banned-ips.json");
-    public static final File OPLIST_FILE = new File("ops.json");
-    public static final File WHITELIST_FILE = new File("whitelist.json");
     public static final Component CHAT_FILTERED_FULL = Component.translatable("chat.filtered_full");
     public static final Component DUPLICATE_LOGIN_DISCONNECT_MESSAGE = Component.translatable("multiplayer.disconnect.duplicate_login");
     private static final Logger LOGGER = LogUtils.getLogger();
-    private static final int SEND_PLAYER_INFO_INTERVAL = 600;
-    private static final SimpleDateFormat BAN_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd 'at' HH:mm:ss z");
-    private final MinecraftServer server;
-    public final List<ServerPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
-    private final Map<UUID, ServerPlayer> playersByUUID = Maps.newHashMap();
-    private final UserBanList bans = new UserBanList(USERBANLIST_FILE);
-    private final IpBanList ipBans = new IpBanList(IPBANLIST_FILE);
-    private final ServerOpList ops = new ServerOpList(OPLIST_FILE);
-    private final UserWhiteList whitelist = new UserWhiteList(WHITELIST_FILE);
+    public final List<ServerPlayer> players = new java.util.concurrent.CopyOnWriteArrayList<>(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
     // CraftBukkit start
     // private final Map<UUID, ServerStatsCounter> stats = Maps.newHashMap();
     // private final Map<UUID, PlayerAdvancements> advancements = Maps.newHashMap();
     // CraftBukkit end
     public final PlayerDataStorage playerIo;
-    private boolean doWhiteList;
+    private final MinecraftServer server;
+    private final Map<UUID, ServerPlayer> playersByUUID = Maps.newHashMap();
     private final LayeredRegistryAccess<RegistryLayer> registries;
+    private final Map<String, ServerPlayer> playersByName = new java.util.HashMap<>();
     public int maxPlayers;
+    public @Nullable String collideRuleTeamName; // Paper - Configurable player collision
     private int viewDistance;
     private int simulationDistance;
     private boolean allowCommandsForAllPlayers;
-    private static final boolean ALLOW_LOGOUTIVATOR = false;
     private int sendAllPlayerInfoIn;
-
     // CraftBukkit start
-    private org.bukkit.craftbukkit.CraftServer cserver;
-    private final Map<String,ServerPlayer> playersByName = new java.util.HashMap<>();
-    public @Nullable String collideRuleTeamName; // Paper - Configurable player collision
+    private final org.bukkit.craftbukkit.CraftServer cserver;
 
     public PlayerList(MinecraftServer server, LayeredRegistryAccess<RegistryLayer> registries, PlayerDataStorage playerIo, int maxPlayers) {
         this.cserver = server.server = new org.bukkit.craftbukkit.CraftServer((net.minecraft.server.dedicated.DedicatedServer) server, this);
@@ -176,7 +162,8 @@ public abstract class PlayerList {
         // Paper start - move logic in Entity to here, to use bukkit supplied world UUID & reset to main world spawn if no valid world is found
         ResourceKey<Level> resourceKey = null; // Paper
         boolean[] invalidPlayerWorld = {false};
-        bukkitData: if (optional.isPresent()) {
+        bukkitData:
+        if (optional.isPresent()) {
             // The main way for bukkit worlds to store the world is the world UUID despite mojang adding custom worlds
             final org.bukkit.World bWorld;
             if (optional.get().contains("WorldUUIDMost") && optional.get().contains("WorldUUIDLeast")) {
@@ -194,16 +181,16 @@ public abstract class PlayerList {
             }
         }
         if (resourceKey == null) { // only run the vanilla logic if we haven't found a world from the bukkit data
-        // Below is the vanilla way of getting the dimension, this is for migration from vanilla servers
-        resourceKey = optional.<ResourceKey<Level>>flatMap(
-                compoundTag -> {
-                    com.mojang.serialization.DataResult<ResourceKey<Level>> dataResult = DimensionType.parseLegacy(new Dynamic<>(NbtOps.INSTANCE, compoundTag.get("Dimension")));
-                    final Optional<ResourceKey<Level>> result = dataResult.resultOrPartial(LOGGER::error);
-                    invalidPlayerWorld[0] = result.isEmpty(); // reset to main world spawn if no valid world is found
-                    return result;
-                }
-            )
-            .orElse(Level.OVERWORLD); // revert to vanilla default main world, this isn't an "invalid world" since no player data existed
+            // Below is the vanilla way of getting the dimension, this is for migration from vanilla servers
+            resourceKey = optional.flatMap(
+                    compoundTag -> {
+                        com.mojang.serialization.DataResult<ResourceKey<Level>> dataResult = DimensionType.parseLegacy(new Dynamic<>(NbtOps.INSTANCE, compoundTag.get("Dimension")));
+                        final Optional<ResourceKey<Level>> result = dataResult.resultOrPartial(LOGGER::error);
+                        invalidPlayerWorld[0] = result.isEmpty(); // reset to main world spawn if no valid world is found
+                        return result;
+                    }
+                )
+                .orElse(Level.OVERWORLD); // revert to vanilla default main world, this isn't an "invalid world" since no player data existed
         }
         // Paper end
         ServerLevel level = this.server.getLevel(resourceKey);
@@ -298,7 +285,7 @@ public abstract class PlayerList {
 
         // CraftBukkit start
         mutableComponent.withStyle(ChatFormatting.YELLOW);
-        Component joinMessage = mutableComponent; // Paper - Adventure
+        Component joinMessage; // Paper - Adventure
         serverGamePacketListenerImpl.teleport(player.getX(), player.getY(), player.getZ(), player.getYRot(), player.getXRot());
         ServerStatus status = this.server.getStatus();
         if (status != null && !cookie.transferred()) {
@@ -342,26 +329,25 @@ public abstract class PlayerList {
         ClientboundPlayerInfoUpdatePacket packet = ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(List.of(player)); // Paper - Add Listing API for Player
 
         final List<ServerPlayer> onlinePlayers = Lists.newArrayListWithExpectedSize(this.players.size() - 1); // Paper - Use single player info update packet on join
-        for (int i = 0; i < this.players.size(); ++i) {
-            ServerPlayer entityplayer1 = (ServerPlayer) this.players.get(i);
+        for (net.minecraft.server.level.ServerPlayer serverPlayer : this.players) {
 
-            if (entityplayer1.getBukkitEntity().canSee(bukkitPlayer)) {
-                // Paper start - Add Listing API for Player
-                if (entityplayer1.getBukkitEntity().isListed(bukkitPlayer)) {
-                // Paper end - Add Listing API for Player
-                entityplayer1.connection.send(packet);
+            if (serverPlayer.getBukkitEntity().canSee(bukkitPlayer)) {
                 // Paper start - Add Listing API for Player
+                if (serverPlayer.getBukkitEntity().isListed(bukkitPlayer)) {
+                    // Paper end - Add Listing API for Player
+                    serverPlayer.connection.send(packet);
+                    // Paper start - Add Listing API for Player
                 } else {
-                    entityplayer1.connection.send(ClientboundPlayerInfoUpdatePacket.createSinglePlayerInitializing(player, false));
+                    serverPlayer.connection.send(net.minecraft.network.protocol.game.ClientboundPlayerInfoUpdatePacket.createSinglePlayerInitializing(player, false));
                 }
                 // Paper end - Add Listing API for Player
             }
 
-            if (entityplayer1 == player || !bukkitPlayer.canSee(entityplayer1.getBukkitEntity())) { // Paper - Use single player info update packet on join; Don't include joining player
+            if (serverPlayer == player || !bukkitPlayer.canSee(serverPlayer.getBukkitEntity())) { // Paper - Use single player info update packet on join; Don't include joining player
                 continue;
             }
 
-            onlinePlayers.add(entityplayer1); // Paper - Use single player info update packet on join
+            onlinePlayers.add(serverPlayer); // Paper - Use single player info update packet on join
         }
         // Paper start - Use single player info update packet on join
         if (!onlinePlayers.isEmpty()) {
@@ -370,7 +356,7 @@ public abstract class PlayerList {
         // Paper end - Use single player info update packet on join
         player.sentListPacket = true;
         player.supressTrackerForLogin = false; // Paper - Fire PlayerJoinEvent when Player is actually ready
-        ((ServerLevel)player.level()).getChunkSource().chunkMap.addEntity(player); // Paper - Fire PlayerJoinEvent when Player is actually ready; track entity now
+        ((ServerLevel) player.level()).getChunkSource().chunkMap.addEntity(player); // Paper - Fire PlayerJoinEvent when Player is actually ready; track entity now
         // CraftBukkit end
 
         //player.refreshEntityData(player); // CraftBukkit - BungeeCord#2321, send complete data to self on spawn // Paper - THIS IS NOT NEEDED ANYMORE
@@ -400,10 +386,10 @@ public abstract class PlayerList {
         // Paper start - Send empty chunk, so players aren't stuck in the world loading screen with our chunk system not sending chunks when dead
         if (player.isDeadOrDying()) {
             net.minecraft.core.Holder<net.minecraft.world.level.biome.Biome> plains = serverLevel.registryAccess().lookupOrThrow(net.minecraft.core.registries.Registries.BIOME)
-                    .getOrThrow(net.minecraft.world.level.biome.Biomes.PLAINS);
+                .getOrThrow(net.minecraft.world.level.biome.Biomes.PLAINS);
             player.connection.send(new net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket(
-                    new net.minecraft.world.level.chunk.EmptyLevelChunk(serverLevel, player.chunkPosition(), plains),
-                    serverLevel.getLightEngine(), (java.util.BitSet)null, (java.util.BitSet) null, true) // Paper - Anti-Xray
+                new net.minecraft.world.level.chunk.EmptyLevelChunk(serverLevel, player.chunkPosition(), plains),
+                serverLevel.getLightEngine(), null, null, true) // Paper - Anti-Xray
             );
         }
         // Paper end - Send empty chunk
@@ -499,6 +485,7 @@ public abstract class PlayerList {
         // Paper start - Fix kick event leave message not being sent
         return this.remove(player, net.kyori.adventure.text.Component.translatable("multiplayer.player.left", net.kyori.adventure.text.format.NamedTextColor.YELLOW, io.papermc.paper.configuration.GlobalConfiguration.get().messages.useDisplayNameInQuitMessage ? player.getBukkitEntity().displayName() : io.papermc.paper.adventure.PaperAdventure.asAdventure(player.getDisplayName())));
     }
+
     public net.kyori.adventure.text.Component remove(ServerPlayer player, net.kyori.adventure.text.Component leaveMessage) {
         // Paper end - Fix kick event leave message not being sent
         ServerLevel serverLevel = player.serverLevel();
@@ -513,7 +500,8 @@ public abstract class PlayerList {
         this.cserver.getPluginManager().callEvent(playerQuitEvent);
         player.getBukkitEntity().disconnect(playerQuitEvent.getQuitMessage());
 
-        if (this.server.isSameThread()) player.doTick(); // SPIGOT-924 // Paper - Improved watchdog support; don't tick during emergency shutdowns
+        if (this.server.isSameThread())
+            player.doTick(); // SPIGOT-924 // Paper - Improved watchdog support; don't tick during emergency shutdowns
         // CraftBukkit end
 
         // Paper start - Configurable player collision; Remove from collideRule team if needed
@@ -584,9 +572,7 @@ public abstract class PlayerList {
         // CraftBukkit start
         // this.broadcastAll(new ClientboundPlayerInfoRemovePacket(List.of(player.getUUID())));
         ClientboundPlayerInfoRemovePacket packet = new ClientboundPlayerInfoRemovePacket(List.of(player.getUUID()));
-        for (int i = 0; i < this.players.size(); i++) {
-            ServerPlayer otherPlayer = (ServerPlayer) this.players.get(i);
-
+        for (net.minecraft.server.level.ServerPlayer otherPlayer : this.players) {
             if (otherPlayer.getBukkitEntity().canSee(player.getBukkitEntity())) {
                 otherPlayer.connection.send(packet);
             } else {
@@ -601,22 +587,19 @@ public abstract class PlayerList {
 
     // CraftBukkit start - Whole method, SocketAddress to LoginListener, added hostname to signature, return EntityPlayer
     public ServerPlayer canPlayerLogin(net.minecraft.server.network.ServerLoginPacketListenerImpl loginlistener, GameProfile gameProfile) {
-        // if (this.bans.isBanned(gameProfile)) {
-        //     UserBanListEntry userBanListEntry = this.bans.get(gameProfile);
-        // Moved from processLogin
         UUID uuid = gameProfile.getId();
         List<ServerPlayer> list = Lists.newArrayList();
 
         ServerPlayer entityplayer;
 
-        for (int i = 0; i < this.players.size(); ++i) {
-            entityplayer = (ServerPlayer) this.players.get(i);
+        for (net.minecraft.server.level.ServerPlayer serverPlayer : this.players) {
+            entityplayer = serverPlayer;
             if (entityplayer.getUUID().equals(uuid) || (io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode() && entityplayer.getGameProfile().getName().equalsIgnoreCase(gameProfile.getName()))) { // Paper - validate usernames
                 list.add(entityplayer);
             }
         }
 
-        java.util.Iterator iterator = list.iterator();
+        java.util.Iterator<net.minecraft.server.level.ServerPlayer> iterator = list.iterator();
 
         while (iterator.hasNext()) {
             entityplayer = (ServerPlayer) iterator.next();
@@ -634,40 +617,8 @@ public abstract class PlayerList {
         org.bukkit.entity.Player player = entity.getBukkitEntity();
         org.bukkit.event.player.PlayerLoginEvent event = new org.bukkit.event.player.PlayerLoginEvent(player, loginlistener.connection.hostname, ((java.net.InetSocketAddress) socketAddress).getAddress(), ((java.net.InetSocketAddress) loginlistener.connection.channel.remoteAddress()).getAddress());
 
-        // Paper start - Fix MC-158900
-        UserBanListEntry userBanListEntry;
-        if (this.bans.isBanned(gameProfile) && (userBanListEntry = this.bans.get(gameProfile)) != null) {
-            // Paper end - Fix MC-158900
-            MutableComponent mutableComponent = Component.translatable("multiplayer.disconnect.banned.reason", userBanListEntry.getReason());
-            if (userBanListEntry.getExpires() != null) {
-                mutableComponent.append(
-                    Component.translatable("multiplayer.disconnect.banned.expiration", BAN_DATE_FORMAT.format(userBanListEntry.getExpires()))
-                );
-            }
-
-            // return mutableComponent;
-            event.disallow(org.bukkit.event.player.PlayerLoginEvent.Result.KICK_BANNED, io.papermc.paper.adventure.PaperAdventure.asAdventure(mutableComponent)); // Paper - Adventure
-        } else if (!this.isWhiteListed(gameProfile, event)) { // Paper - ProfileWhitelistVerifyEvent
-            // return Component.translatable("multiplayer.disconnect.not_whitelisted");
-            //event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.whitelistMessage)); // Spigot // Paper - Adventure - moved to isWhitelisted
-        } else if (this.ipBans.isBanned(socketAddress) && getIpBans().get(socketAddress) != null && !this.getIpBans().get(socketAddress).hasExpired()) { // Paper - fix NPE with temp ip bans
-            IpBanListEntry ipBanListEntry = this.ipBans.get(socketAddress);
-            MutableComponent mutableComponent = Component.translatable("multiplayer.disconnect.banned_ip.reason", ipBanListEntry.getReason());
-            if (ipBanListEntry.getExpires() != null) {
-                mutableComponent.append(
-                    Component.translatable("multiplayer.disconnect.banned_ip.expiration", BAN_DATE_FORMAT.format(ipBanListEntry.getExpires()))
-                );
-            }
-
-            // return mutableComponent;
-            event.disallow(org.bukkit.event.player.PlayerLoginEvent.Result.KICK_BANNED, io.papermc.paper.adventure.PaperAdventure.asAdventure(mutableComponent)); // Paper - Adventure
-        } else {
-            // return this.players.size() >= this.maxPlayers && !this.canBypassPlayerLimit(gameProfile)
-            //     ? Component.translatable("multiplayer.disconnect.server_full")
-            //     : null;
-            if (this.players.size() >= this.maxPlayers && !this.canBypassPlayerLimit(gameProfile)) {
-                event.disallow(org.bukkit.event.player.PlayerLoginEvent.Result.KICK_FULL, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.serverFullMessage)); // Spigot // Paper - Adventure
-            }
+        if (this.players.size() >= this.maxPlayers && !this.canBypassPlayerLimit(gameProfile)) {
+            event.disallow(org.bukkit.event.player.PlayerLoginEvent.Result.KICK_FULL, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.serverFullMessage)); // Spigot // Paper - Adventure
         }
         this.cserver.getPluginManager().callEvent(event);
         if (event.getResult() != org.bukkit.event.player.PlayerLoginEvent.Result.ALLOWED) {
@@ -713,6 +664,7 @@ public abstract class PlayerList {
     public ServerPlayer respawn(ServerPlayer player, boolean keepInventory, Entity.RemovalReason reason, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason eventReason) {
         return this.respawn(player, keepInventory, reason, eventReason, null);
     }
+
     public ServerPlayer respawn(ServerPlayer player, boolean keepInventory, Entity.RemovalReason reason, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason eventReason, org.bukkit.Location location) {
         player.stopRiding(); // CraftBukkit
         this.players.remove(player);
@@ -748,11 +700,12 @@ public abstract class PlayerList {
             teleportTransition = player.findRespawnPositionAndUseSpawnBlock(!keepInventory, TeleportTransition.DO_NOTHING, eventReason);
 
             if (!keepInventory) player.reset(); // SPIGOT-4785
-           // Paper start - Add PlayerPostRespawnEvent
-           if (teleportTransition == null) return player; // Early exit, mirrors belows early return for disconnected players in respawn event
-           isRespawn = true;
-           location = org.bukkit.craftbukkit.util.CraftLocation.toBukkit(teleportTransition.position(), teleportTransition.newLevel().getWorld(), teleportTransition.yRot(), teleportTransition.xRot());
-           // Paper end - Add PlayerPostRespawnEvent
+            // Paper start - Add PlayerPostRespawnEvent
+            if (teleportTransition == null)
+                return player; // Early exit, mirrors belows early return for disconnected players in respawn event
+            isRespawn = true;
+            location = org.bukkit.craftbukkit.util.CraftLocation.toBukkit(teleportTransition.position(), teleportTransition.newLevel().getWorld(), teleportTransition.yRot(), teleportTransition.xRot());
+            // Paper end - Add PlayerPostRespawnEvent
         } else {
             teleportTransition = new TeleportTransition(((org.bukkit.craftbukkit.CraftWorld) location.getWorld()).getHandle(), org.bukkit.craftbukkit.util.CraftLocation.toVec3D(location), Vec3.ZERO, location.getYaw(), location.getPitch(), TeleportTransition.DO_NOTHING);
         }
@@ -774,7 +727,7 @@ public abstract class PlayerList {
             serverPlayer.setRespawnPosition(null, null, 0f, false, false, com.destroystokyo.paper.event.player.PlayerSetSpawnEvent.Cause.PLAYER_RESPAWN); // CraftBukkit - SPIGOT-5988: Clear respawn location when obstructed // Paper - PlayerSetSpawnEvent
         }
 
-        byte b = (byte)(keepInventory ? 1 : 0);
+        byte b = (byte) (keepInventory ? 1 : 0);
         ServerLevel serverLevel = serverPlayer.serverLevel();
         LevelData levelData = serverLevel.getLevelData();
         serverPlayer.connection.send(new ClientboundRespawnPacket(serverPlayer.createCommonSpawnInfo(serverLevel), b));
@@ -862,6 +815,7 @@ public abstract class PlayerList {
         // Paper start - collect packets
         this.sendActiveEffects(entity, connection::send);
     }
+
     public void sendActiveEffects(LivingEntity entity, java.util.function.Consumer<Packet<? super net.minecraft.network.protocol.game.ClientGamePacketListener>> packetConsumer) {
         // Paper end - collect packets
         for (MobEffectInstance mobEffectInstance : entity.getActiveEffects()) {
@@ -870,12 +824,12 @@ public abstract class PlayerList {
     }
 
     public void sendPlayerPermissionLevel(ServerPlayer player) {
-    // Paper start - avoid recalculating permissions if possible
+        // Paper start - avoid recalculating permissions if possible
         this.sendPlayerPermissionLevel(player, true);
     }
 
     public void sendPlayerPermissionLevel(ServerPlayer player, boolean recalculatePermissions) {
-    // Paper end - avoid recalculating permissions if possible
+        // Paper end - avoid recalculating permissions if possible
         GameProfile gameProfile = player.getGameProfile();
         int profilePermissions = this.server.getProfilePermissions(gameProfile);
         this.sendPlayerPermissionLevel(player, profilePermissions, recalculatePermissions); // Paper - avoid recalculating permissions if possible
@@ -896,12 +850,11 @@ public abstract class PlayerList {
 
     // CraftBukkit start - add a world/entity limited version
     public void broadcastAll(Packet packet, net.minecraft.world.entity.player.Player entityhuman) {
-        for (int i = 0; i < this.players.size(); ++i) {
-            ServerPlayer entityplayer =  this.players.get(i);
+        for (net.minecraft.server.level.ServerPlayer entityplayer : this.players) {
             if (entityhuman != null && !entityplayer.getBukkitEntity().canSee(entityhuman.getBukkitEntity())) {
                 continue;
             }
-            ((ServerPlayer) this.players.get(i)).connection.send(packet);
+            entityplayer.connection.send(packet);
         }
     }
 
@@ -944,8 +897,7 @@ public abstract class PlayerList {
         if (team == null) {
             this.broadcastSystemMessage(message, false);
         } else {
-            for (int i = 0; i < this.players.size(); i++) {
-                ServerPlayer serverPlayer = this.players.get(i);
+            for (net.minecraft.server.level.ServerPlayer serverPlayer : this.players) {
                 if (serverPlayer.getTeam() != team) {
                     serverPlayer.sendSystemMessage(message);
                 }
@@ -963,34 +915,11 @@ public abstract class PlayerList {
         return strings;
     }
 
-    public UserBanList getBans() {
-        return this.bans;
-    }
-
-    public IpBanList getIpBans() {
-        return this.ipBans;
-    }
-
-    public void op(GameProfile profile) {
-        this.ops.add(new ServerOpListEntry(profile, this.server.getOperatorUserPermissionLevel(), this.ops.canBypassPlayerLimit(profile)));
-        ServerPlayer player = this.getPlayer(profile.getId());
-        if (player != null) {
-            this.sendPlayerPermissionLevel(player);
-        }
-    }
-
-    public void deop(GameProfile profile) {
-        this.ops.remove(profile);
-        ServerPlayer player = this.getPlayer(profile.getId());
-        if (player != null) {
-            this.sendPlayerPermissionLevel(player);
-        }
-    }
-
     private void sendPlayerPermissionLevel(ServerPlayer player, int permLevel) {
         // Paper start - Add sendOpLevel API
         this.sendPlayerPermissionLevel(player, permLevel, true);
     }
+
     public void sendPlayerPermissionLevel(ServerPlayer player, int permLevel, boolean recalculatePermissions) {
         // Paper end - Add sendOpLevel API
         if (player.connection != null) {
@@ -1000,57 +929,28 @@ public abstract class PlayerList {
             } else if (permLevel >= 4) {
                 b = 28;
             } else {
-                b = (byte)(24 + permLevel);
+                b = (byte) (24 + permLevel);
             }
 
             player.connection.send(new ClientboundEntityEventPacket(player, b));
         }
 
         if (recalculatePermissions) { // Paper - Add sendOpLevel API
-        player.getBukkitEntity().recalculatePermissions(); // CraftBukkit
-        this.server.getCommands().sendCommands(player);
+            player.getBukkitEntity().recalculatePermissions(); // CraftBukkit
+            this.server.getCommands().sendCommands(player);
         } // Paper - Add sendOpLevel API
     }
 
-    public boolean isWhiteListed(GameProfile profile) {
-        // Paper start - ProfileWhitelistVerifyEvent
-        return this.isWhiteListed(profile, null);
-    }
-    public boolean isWhiteListed(GameProfile gameprofile, @Nullable org.bukkit.event.player.PlayerLoginEvent loginEvent) {
-        boolean isOp = this.ops.contains(gameprofile);
-        boolean isWhitelisted = !this.doWhiteList || isOp || this.whitelist.contains(gameprofile);
-        final com.destroystokyo.paper.event.profile.ProfileWhitelistVerifyEvent event;
-
-        final net.kyori.adventure.text.Component configuredMessage = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.whitelistMessage);
-        event = new com.destroystokyo.paper.event.profile.ProfileWhitelistVerifyEvent(com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitMirror(gameprofile), this.doWhiteList, isWhitelisted, isOp, configuredMessage);
-        event.callEvent();
-        if (!event.isWhitelisted()) {
-            if (loginEvent != null) {
-                loginEvent.disallow(org.bukkit.event.player.PlayerLoginEvent.Result.KICK_WHITELIST, event.kickMessage() == null ? configuredMessage : event.kickMessage());
-            }
-            return false;
-        }
-        return true;
-        // Paper end - ProfileWhitelistVerifyEvent
-    }
-
-    public boolean isOp(GameProfile profile) {
-        return this.ops.contains(profile)
-            || this.server.isSingleplayerOwner(profile) && this.server.getWorldData().isAllowCommands()
-            || this.allowCommandsForAllPlayers;
-    }
-
     @Nullable
     public ServerPlayer getPlayerByName(String username) {
         return this.playersByName.get(username.toLowerCase(java.util.Locale.ROOT)); // Spigot
     }
 
     public void broadcast(@Nullable Player except, double x, double y, double z, double radius, ResourceKey<Level> dimension, Packet<?> packet) {
-        for (int i = 0; i < this.players.size(); i++) {
-            ServerPlayer serverPlayer = this.players.get(i);
+        for (net.minecraft.server.level.ServerPlayer serverPlayer : this.players) {
             // CraftBukkit start - Test if player receiving packet can see the source of the packet
             if (except != null && !serverPlayer.getBukkitEntity().canSee(except.getBukkitEntity())) {
-               continue;
+                continue;
             }
             // CraftBukkit end
             if (serverPlayer != except && serverPlayer.level().dimension() == dimension) {
@@ -1070,36 +970,20 @@ public abstract class PlayerList {
     }
 
     public void saveAll(final int interval) {
-        io.papermc.paper.util.MCUtil.ensureMain("Save Players" , () -> { // Paper - Ensure main
-        int numSaved = 0;
-        final long now = MinecraftServer.currentTick;
-        for (int i = 0; i < this.players.size(); i++) {
-            final ServerPlayer player = this.players.get(i);
-            if (interval == -1 || now - player.lastSave >= interval) {
-                this.save(player);
-                if (interval != -1 && ++numSaved >= io.papermc.paper.configuration.GlobalConfiguration.get().playerAutoSave.maxPerTick()) {
-                    break;
+        io.papermc.paper.util.MCUtil.ensureMain("Save Players", () -> { // Paper - Ensure main
+            int numSaved = 0;
+            final long now = MinecraftServer.currentTick;
+            for (final net.minecraft.server.level.ServerPlayer player : this.players) {
+                if (interval == -1 || now - player.lastSave >= interval) {
+                    this.save(player);
+                    if (interval != -1 && ++numSaved >= io.papermc.paper.configuration.GlobalConfiguration.get().playerAutoSave.maxPerTick()) {
+                        break;
+                    }
                 }
+                // Paper end - Incremental chunk and player saving
             }
-            // Paper end - Incremental chunk and player saving
-        }
-        return null; }); // Paper - ensure main
-    }
-
-    public UserWhiteList getWhiteList() {
-        return this.whitelist;
-    }
-
-    public String[] getWhiteListNames() {
-        return this.whitelist.getUserList();
-    }
-
-    public ServerOpList getOps() {
-        return this.ops;
-    }
-
-    public String[] getOpNames() {
-        return this.ops.getUserList();
+            return null;
+        }); // Paper - ensure main
     }
 
     public void reloadWhiteList() {
@@ -1138,7 +1022,7 @@ public abstract class PlayerList {
         // CraftBukkit start - from GameRules
         int i = player.serverLevel().getGameRules().getBoolean(GameRules.RULE_REDUCEDDEBUGINFO) ? 22 : 23;
         player.connection.send(new ClientboundEntityEventPacket(player, (byte) i));
-        float immediateRespawn = player.serverLevel().getGameRules().getBoolean(GameRules.RULE_DO_IMMEDIATE_RESPAWN) ? 1.0F: 0.0F;
+        float immediateRespawn = player.serverLevel().getGameRules().getBoolean(GameRules.RULE_DO_IMMEDIATE_RESPAWN) ? 1.0F : 0.0F;
         player.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.IMMEDIATE_RESPAWN, immediateRespawn));
         // CraftBukkit end
     }
@@ -1151,15 +1035,6 @@ public abstract class PlayerList {
         return this.maxPlayers;
     }
 
-    public boolean isUsingWhitelist() {
-        return this.doWhiteList;
-    }
-
-    public void setUsingWhiteList(boolean whitelistEnabled) {
-        new com.destroystokyo.paper.event.server.WhitelistToggleEvent(whitelistEnabled).callEvent(); // Paper - WhitelistToggleEvent
-        this.doWhiteList = whitelistEnabled;
-    }
-
     public List<ServerPlayer> getPlayersWithAddress(String address) {
         List<ServerPlayer> list = Lists.newArrayList();
 
@@ -1176,10 +1051,32 @@ public abstract class PlayerList {
         return this.viewDistance;
     }
 
+    public void setViewDistance(int viewDistance) {
+        this.viewDistance = viewDistance;
+        //this.broadcastAll(new ClientboundSetChunkCacheRadiusPacket(viewDistance)); // Paper - rewrite chunk system
+
+        for (ServerLevel serverLevel : this.server.getAllLevels()) {
+            if (serverLevel != null) {
+                serverLevel.getChunkSource().setViewDistance(viewDistance);
+            }
+        }
+    }
+
     public int getSimulationDistance() {
         return this.simulationDistance;
     }
 
+    public void setSimulationDistance(int simulationDistance) {
+        this.simulationDistance = simulationDistance;
+        //this.broadcastAll(new ClientboundSetSimulationDistancePacket(simulationDistance));  // Paper - rewrite chunk system
+
+        for (ServerLevel serverLevel : this.server.getAllLevels()) {
+            if (serverLevel != null) {
+                serverLevel.getChunkSource().setSimulationDistance(simulationDistance);
+            }
+        }
+    }
+
     public MinecraftServer getServer() {
         return this.server;
     }
@@ -1189,10 +1086,6 @@ public abstract class PlayerList {
         return null;
     }
 
-    public void setAllowCommandsForAllPlayers(boolean allowCommandsForAllPlayers) {
-        this.allowCommandsForAllPlayers = allowCommandsForAllPlayers;
-    }
-
     public void removeAll() {
         // Paper start - Extract method to allow for restarting flag
         this.removeAll(false);
@@ -1202,8 +1095,10 @@ public abstract class PlayerList {
         // Paper end
         // CraftBukkit start - disconnect safely
         for (ServerPlayer player : this.players) {
-            if (isRestarting) player.connection.disconnect(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.restartMessage), org.bukkit.event.player.PlayerKickEvent.Cause.UNKNOWN); else // Paper - kick event cause (cause is never used here)
-            player.connection.disconnect(java.util.Objects.requireNonNullElseGet(this.server.server.shutdownMessage(), net.kyori.adventure.text.Component::empty)); // CraftBukkit - add custom shutdown message // Paper - Adventure
+            if (isRestarting)
+                player.connection.disconnect(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.restartMessage), org.bukkit.event.player.PlayerKickEvent.Cause.UNKNOWN);
+            else // Paper - kick event cause (cause is never used here)
+                player.connection.disconnect(java.util.Objects.requireNonNullElseGet(this.server.server.shutdownMessage(), net.kyori.adventure.text.Component::empty)); // CraftBukkit - add custom shutdown message // Paper - Adventure
         }
         // CraftBukkit end
 
@@ -1215,6 +1110,7 @@ public abstract class PlayerList {
         }
         // Paper end - Configurable player collision
     }
+    // CraftBukkit end
 
     // CraftBukkit start
     public void broadcastMessage(Component[] iChatBaseComponents) {
@@ -1222,7 +1118,6 @@ public abstract class PlayerList {
             this.broadcastSystemMessage(component, false);
         }
     }
-    // CraftBukkit end
 
     public void broadcastSystemMessage(Component message, boolean bypassHiddenChat) {
         this.broadcastSystemMessage(message, serverPlayer -> message, bypassHiddenChat);
@@ -1247,6 +1142,7 @@ public abstract class PlayerList {
         // Paper start
         this.broadcastChatMessage(message, sender, boundChatType, null);
     }
+
     public void broadcastChatMessage(PlayerChatMessage message, ServerPlayer sender, ChatType.Bound boundChatType, @Nullable Function<net.kyori.adventure.audience.Audience, Component> unsignedFunction) {
         // Paper end
         this.broadcastChatMessage(message, sender::shouldFilterMessageTo, sender, boundChatType, unsignedFunction); // Paper
@@ -1258,6 +1154,7 @@ public abstract class PlayerList {
         // Paper start
         this.broadcastChatMessage(message, shouldFilterMessageTo, sender, boundChatType, null);
     }
+
     public void broadcastChatMessage(PlayerChatMessage message, Predicate<ServerPlayer> shouldFilterMessageTo, @Nullable ServerPlayer sender, ChatType.Bound boundChatType, @Nullable Function<net.kyori.adventure.audience.Audience, Component> unsignedFunction) {
         // Paper end
         boolean flag = this.verifyChatTrusted(message);
@@ -1330,28 +1227,6 @@ public abstract class PlayerList {
         return playerAdvancements;
     }
 
-    public void setViewDistance(int viewDistance) {
-        this.viewDistance = viewDistance;
-        //this.broadcastAll(new ClientboundSetChunkCacheRadiusPacket(viewDistance)); // Paper - rewrite chunk system
-
-        for (ServerLevel serverLevel : this.server.getAllLevels()) {
-            if (serverLevel != null) {
-                serverLevel.getChunkSource().setViewDistance(viewDistance);
-            }
-        }
-    }
-
-    public void setSimulationDistance(int simulationDistance) {
-        this.simulationDistance = simulationDistance;
-        //this.broadcastAll(new ClientboundSetSimulationDistancePacket(simulationDistance));  // Paper - rewrite chunk system
-
-        for (ServerLevel serverLevel : this.server.getAllLevels()) {
-            if (serverLevel != null) {
-                serverLevel.getChunkSource().setSimulationDistance(simulationDistance);
-            }
-        }
-    }
-
     public List<ServerPlayer> getPlayers() {
         return this.players;
     }
@@ -1371,6 +1246,7 @@ public abstract class PlayerList {
         this.reloadTagData();
         this.reloadRecipes();
     }
+
     public void reloadAdvancementData() {
         // Paper end - API for updating recipes on clients
         // CraftBukkit start
@@ -1385,6 +1261,7 @@ public abstract class PlayerList {
 
         // Paper start - API for updating recipes on clients
     }
+
     public void reloadTagData() {
         this.broadcastAll(new ClientboundUpdateTagsPacket(TagNetworkSerialization.serializeTagsToNetwork(this.registries)));
         // CraftBukkit start
diff --git a/net/minecraft/server/players/ServerOpList.java b/net/minecraft/server/players/ServerOpList.java
deleted file mode 100644
index 9fd953d3908d18e8609918f00646875a6682c01e..0000000000000000000000000000000000000000
--- a/net/minecraft/server/players/ServerOpList.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package net.minecraft.server.players;
-
-import com.google.gson.JsonObject;
-import com.mojang.authlib.GameProfile;
-import java.io.File;
-import java.util.Objects;
-
-public class ServerOpList extends StoredUserList<GameProfile, ServerOpListEntry> {
-    public ServerOpList(File file) {
-        super(file);
-    }
-
-    @Override
-    protected StoredUserEntry<GameProfile> createEntry(JsonObject entryData) {
-        return new ServerOpListEntry(entryData);
-    }
-
-    @Override
-    public String[] getUserList() {
-        return this.getEntries().stream().map(StoredUserEntry::getUser).filter(Objects::nonNull).map(GameProfile::getName).toArray(String[]::new);
-    }
-
-    public boolean canBypassPlayerLimit(GameProfile profile) {
-        ServerOpListEntry serverOpListEntry = this.get(profile);
-        return serverOpListEntry != null && serverOpListEntry.getBypassesPlayerLimit();
-    }
-
-    @Override
-    protected String getKeyForUser(GameProfile obj) {
-        return obj.getId().toString();
-    }
-}
diff --git a/net/minecraft/server/players/ServerOpListEntry.java b/net/minecraft/server/players/ServerOpListEntry.java
deleted file mode 100644
index aa2663be118b628257e16e3da309e8a3b4f9ad71..0000000000000000000000000000000000000000
--- a/net/minecraft/server/players/ServerOpListEntry.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package net.minecraft.server.players;
-
-import com.google.gson.JsonObject;
-import com.mojang.authlib.GameProfile;
-import java.util.UUID;
-import javax.annotation.Nullable;
-
-public class ServerOpListEntry extends StoredUserEntry<GameProfile> {
-    private final int level;
-    private final boolean bypassesPlayerLimit;
-
-    public ServerOpListEntry(GameProfile user, int level, boolean bypassesPlayerLimit) {
-        super(user);
-        this.level = level;
-        this.bypassesPlayerLimit = bypassesPlayerLimit;
-    }
-
-    public ServerOpListEntry(JsonObject user) {
-        super(createGameProfile(user));
-        this.level = user.has("level") ? user.get("level").getAsInt() : 0;
-        this.bypassesPlayerLimit = user.has("bypassesPlayerLimit") && user.get("bypassesPlayerLimit").getAsBoolean();
-    }
-
-    public int getLevel() {
-        return this.level;
-    }
-
-    public boolean getBypassesPlayerLimit() {
-        return this.bypassesPlayerLimit;
-    }
-
-    @Override
-    protected void serialize(JsonObject data) {
-        if (this.getUser() != null) {
-            data.addProperty("uuid", this.getUser().getId().toString());
-            data.addProperty("name", this.getUser().getName());
-            data.addProperty("level", this.level);
-            data.addProperty("bypassesPlayerLimit", this.bypassesPlayerLimit);
-        }
-    }
-
-    @Nullable
-    private static GameProfile createGameProfile(JsonObject profileData) {
-        if (profileData.has("uuid") && profileData.has("name")) {
-            String asString = profileData.get("uuid").getAsString();
-
-            UUID uuid;
-            try {
-                uuid = UUID.fromString(asString);
-            } catch (Throwable var4) {
-                return null;
-            }
-
-            return new GameProfile(uuid, profileData.get("name").getAsString());
-        } else {
-            return null;
-        }
-    }
-}
diff --git a/net/minecraft/server/players/StoredUserList.java b/net/minecraft/server/players/StoredUserList.java
deleted file mode 100644
index d445e8f126f077d8419c52fa5436ea963a1a42a4..0000000000000000000000000000000000000000
--- a/net/minecraft/server/players/StoredUserList.java
+++ /dev/null
@@ -1,135 +0,0 @@
-package net.minecraft.server.players;
-
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import com.google.common.io.Files;
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.JsonArray;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
-import com.mojang.logging.LogUtils;
-import java.io.BufferedReader;
-import java.io.BufferedWriter;
-import java.io.File;
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import javax.annotation.Nullable;
-import net.minecraft.Util;
-import net.minecraft.util.GsonHelper;
-import org.slf4j.Logger;
-
-public abstract class StoredUserList<K, V extends StoredUserEntry<K>> {
-    private static final Logger LOGGER = LogUtils.getLogger();
-    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
-    private final File file;
-    private final Map<String, V> map = Maps.newConcurrentMap(); // Paper - Use ConcurrentHashMap in JsonList
-
-    public StoredUserList(File file) {
-        this.file = file;
-    }
-
-    public File getFile() {
-        return this.file;
-    }
-
-    public void add(V entry) {
-        this.map.put(this.getKeyForUser(entry.getUser()), entry);
-
-        try {
-            this.save();
-        } catch (IOException var3) {
-            LOGGER.warn("Could not save the list after adding a user.", (Throwable)var3);
-        }
-    }
-
-    @Nullable
-    public V get(K obj) {
-        // Paper start - Use ConcurrentHashMap in JsonList
-        return this.map.computeIfPresent(this.getKeyForUser(obj), (k, v) -> {
-            return v.hasExpired() ? null : v;
-        });
-        // Paper end - Use ConcurrentHashMap in JsonList
-    }
-
-    public void remove(K user) {
-        this.map.remove(this.getKeyForUser(user));
-
-        try {
-            this.save();
-        } catch (IOException var3) {
-            LOGGER.warn("Could not save the list after removing a user.", (Throwable)var3);
-        }
-    }
-
-    public void remove(StoredUserEntry<K> entry) {
-        this.remove(entry.getUser());
-    }
-
-    public String[] getUserList() {
-        return this.map.keySet().toArray(new String[0]);
-    }
-
-    public boolean isEmpty() {
-        return this.map.isEmpty(); // Paper - Use ConcurrentHashMap in JsonList
-    }
-
-    protected String getKeyForUser(K obj) {
-        return obj.toString();
-    }
-
-    protected boolean contains(K entry) {
-        this.removeExpired(); // CraftBukkit - SPIGOT-7589: Consistently remove expired entries to mirror .get(...)
-        return this.map.containsKey(this.getKeyForUser(entry));
-    }
-
-    private void removeExpired() {
-        this.map.values().removeIf(StoredUserEntry::hasExpired); // Paper - Use ConcurrentHashMap in JsonList
-    }
-
-    protected abstract StoredUserEntry<K> createEntry(JsonObject entryData);
-
-    public Collection<V> getEntries() {
-        return this.map.values();
-    }
-
-    public void save() throws IOException {
-        this.removeExpired(); // Paper - remove expired values before saving
-        JsonArray jsonArray = new JsonArray();
-        this.map.values().stream().map(storedEntry -> Util.make(new JsonObject(), storedEntry::serialize)).forEach(jsonArray::add);
-
-        try (BufferedWriter writer = Files.newWriter(this.file, StandardCharsets.UTF_8)) {
-            GSON.toJson(jsonArray, GSON.newJsonWriter(writer));
-        }
-    }
-
-    public void load() throws IOException {
-        if (this.file.exists()) {
-            try (BufferedReader reader = Files.newReader(this.file, StandardCharsets.UTF_8)) {
-                this.map.clear();
-                JsonArray jsonArray = GSON.fromJson(reader, JsonArray.class);
-                if (jsonArray == null) {
-                    return;
-                }
-
-                for (JsonElement jsonElement : jsonArray) {
-                    JsonObject jsonObject = GsonHelper.convertToJsonObject(jsonElement, "entry");
-                    StoredUserEntry<K> storedUserEntry = this.createEntry(jsonObject);
-                    if (storedUserEntry.getUser() != null) {
-                        this.map.put(this.getKeyForUser(storedUserEntry.getUser()), (V)storedUserEntry);
-                    }
-                }
-            // Spigot start
-            } catch (com.google.gson.JsonParseException | NullPointerException ex) {
-                File backup = new File(this.file + ".backup");
-                LOGGER.warn("Unable to read file {}, backing it up to {} and creating new copy.", this.file, backup, ex);
-                this.file.renameTo(backup);
-                this.file.delete();
-            }
-            // Spigot end
-        }
-    }
-}
diff --git a/net/minecraft/server/players/UserBanList.java b/net/minecraft/server/players/UserBanList.java
deleted file mode 100644
index 58af25f8f935d7a2423d1f9f68966de6507c3851..0000000000000000000000000000000000000000
--- a/net/minecraft/server/players/UserBanList.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package net.minecraft.server.players;
-
-import com.google.gson.JsonObject;
-import com.mojang.authlib.GameProfile;
-import java.io.File;
-import java.util.Objects;
-
-public class UserBanList extends StoredUserList<GameProfile, UserBanListEntry> {
-    public UserBanList(File file) {
-        super(file);
-    }
-
-    @Override
-    protected StoredUserEntry<GameProfile> createEntry(JsonObject entryData) {
-        return new UserBanListEntry(entryData);
-    }
-
-    public boolean isBanned(GameProfile profile) {
-        return this.contains(profile);
-    }
-
-    @Override
-    public String[] getUserList() {
-        return this.getEntries().stream().map(StoredUserEntry::getUser).filter(Objects::nonNull).map(GameProfile::getName).toArray(String[]::new);
-    }
-
-    @Override
-    protected String getKeyForUser(GameProfile obj) {
-        return obj.getId().toString();
-    }
-}
diff --git a/net/minecraft/server/players/UserBanListEntry.java b/net/minecraft/server/players/UserBanListEntry.java
deleted file mode 100644
index 960a078a10ce738e36e56fa887b40f087563c297..0000000000000000000000000000000000000000
--- a/net/minecraft/server/players/UserBanListEntry.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package net.minecraft.server.players;
-
-import com.google.gson.JsonObject;
-import com.mojang.authlib.GameProfile;
-import java.util.Date;
-import java.util.UUID;
-import javax.annotation.Nullable;
-import net.minecraft.network.chat.Component;
-
-public class UserBanListEntry extends BanListEntry<GameProfile> {
-    public UserBanListEntry(@Nullable GameProfile user) {
-        this(user, null, null, null, null);
-    }
-
-    public UserBanListEntry(@Nullable GameProfile profile, @Nullable Date created, @Nullable String source, @Nullable Date expires, @Nullable String reason) {
-        super(profile, created, source, expires, reason);
-    }
-
-    public UserBanListEntry(JsonObject entryData) {
-        super(createGameProfile(entryData), entryData);
-    }
-
-    @Override
-    protected void serialize(JsonObject data) {
-        if (this.getUser() != null) {
-            data.addProperty("uuid", this.getUser().getId().toString());
-            data.addProperty("name", this.getUser().getName());
-            super.serialize(data);
-        }
-    }
-
-    @Override
-    public Component getDisplayName() {
-        GameProfile gameProfile = this.getUser();
-        return gameProfile != null ? Component.literal(gameProfile.getName()) : Component.translatable("commands.banlist.entry.unknown");
-    }
-
-    @Nullable
-    private static GameProfile createGameProfile(JsonObject json) {
-        // Spigot start
-        // this whole method has to be reworked to account for the fact Bukkit only accepts UUID bans and gives no way for usernames to be stored!
-        UUID uuid = null;
-        String name = null;
-        if (json.has("uuid")) {
-            String asString = json.get("uuid").getAsString();
-
-            try {
-                uuid = UUID.fromString(asString);
-            } catch (Throwable var4) {
-            }
-
-        }
-        if (json.has("name")) {
-            name = json.get("name").getAsString();
-        }
-        if (uuid != null || name != null) {
-            return new GameProfile(uuid, name);
-        } else {
-            return null;
-        }
-        // Spigot end
-    }
-}
diff --git a/net/minecraft/server/players/UserWhiteList.java b/net/minecraft/server/players/UserWhiteList.java
deleted file mode 100644
index 98b0e3f0642ff7109c73972622a29a89678d70ba..0000000000000000000000000000000000000000
--- a/net/minecraft/server/players/UserWhiteList.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package net.minecraft.server.players;
-
-import com.google.gson.JsonObject;
-import com.mojang.authlib.GameProfile;
-import java.io.File;
-import java.util.Objects;
-
-public class UserWhiteList extends StoredUserList<GameProfile, UserWhiteListEntry> {
-    public UserWhiteList(File file) {
-        super(file);
-    }
-
-    @Override
-    protected StoredUserEntry<GameProfile> createEntry(JsonObject entryData) {
-        return new UserWhiteListEntry(entryData);
-    }
-
-    public boolean isWhiteListed(GameProfile profile) {
-        return this.contains(profile);
-    }
-
-    @Override
-    public String[] getUserList() {
-        return this.getEntries().stream().map(StoredUserEntry::getUser).filter(Objects::nonNull).map(GameProfile::getName).toArray(String[]::new);
-    }
-
-    @Override
-    protected String getKeyForUser(GameProfile obj) {
-        return obj.getId().toString();
-    }
-    // Paper start - Add whitelist events
-    @Override
-    public void add(UserWhiteListEntry entry) {
-        if (!new io.papermc.paper.event.server.WhitelistStateUpdateEvent(com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitCopy(entry.getUser()), io.papermc.paper.event.server.WhitelistStateUpdateEvent.WhitelistStatus.ADDED).callEvent()) {
-            return;
-        }
-
-        super.add(entry);
-    }
-
-    @Override
-    public void remove(GameProfile profile) {
-        if (!new io.papermc.paper.event.server.WhitelistStateUpdateEvent(com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitCopy(profile), io.papermc.paper.event.server.WhitelistStateUpdateEvent.WhitelistStatus.REMOVED).callEvent()) {
-            return;
-        }
-
-        super.remove(profile);
-    }
-    // Paper end - Add whitelist events
-}
diff --git a/net/minecraft/server/players/UserWhiteListEntry.java b/net/minecraft/server/players/UserWhiteListEntry.java
deleted file mode 100644
index 92b31d1b033f8daf15616050bfc16cd0caef57a4..0000000000000000000000000000000000000000
--- a/net/minecraft/server/players/UserWhiteListEntry.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package net.minecraft.server.players;
-
-import com.google.gson.JsonObject;
-import com.mojang.authlib.GameProfile;
-import java.util.UUID;
-
-public class UserWhiteListEntry extends StoredUserEntry<GameProfile> {
-    public UserWhiteListEntry(GameProfile user) {
-        super(user);
-    }
-
-    public UserWhiteListEntry(JsonObject user) {
-        super(createGameProfile(user));
-    }
-
-    @Override
-    protected void serialize(JsonObject data) {
-        if (this.getUser() != null) {
-            data.addProperty("uuid", this.getUser().getId() == null ? "" : this.getUser().getId().toString());
-            data.addProperty("name", this.getUser().getName());
-        }
-    }
-
-    private static GameProfile createGameProfile(JsonObject json) {
-        if (json.has("uuid") && json.has("name")) {
-            String asString = json.get("uuid").getAsString();
-
-            UUID uuid;
-            try {
-                uuid = UUID.fromString(asString);
-            } catch (Throwable var4) {
-                return null;
-            }
-
-            return new GameProfile(uuid, json.get("name").getAsString());
-        } else {
-            return null;
-        }
-    }
-}
diff --git a/net/minecraft/server/rcon/NetworkDataOutputStream.java b/net/minecraft/server/rcon/NetworkDataOutputStream.java
deleted file mode 100644
index 03db8c023b58c167b210856bf758ecc74d4138ae..0000000000000000000000000000000000000000
--- a/net/minecraft/server/rcon/NetworkDataOutputStream.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package net.minecraft.server.rcon;
-
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-
-public class NetworkDataOutputStream {
-    private final ByteArrayOutputStream outputStream;
-    private final DataOutputStream dataOutputStream;
-
-    public NetworkDataOutputStream(int capacity) {
-        this.outputStream = new ByteArrayOutputStream(capacity);
-        this.dataOutputStream = new DataOutputStream(this.outputStream);
-    }
-
-    public void writeBytes(byte[] data) throws IOException {
-        this.dataOutputStream.write(data, 0, data.length);
-    }
-
-    public void writeString(String data) throws IOException {
-        this.dataOutputStream.writeBytes(data);
-        this.dataOutputStream.write(0);
-    }
-
-    public void write(int data) throws IOException {
-        this.dataOutputStream.write(data);
-    }
-
-    public void writeShort(short data) throws IOException {
-        this.dataOutputStream.writeShort(Short.reverseBytes(data));
-    }
-
-    public void writeInt(int data) throws IOException {
-        this.dataOutputStream.writeInt(Integer.reverseBytes(data));
-    }
-
-    public void writeFloat(float data) throws IOException {
-        this.dataOutputStream.writeInt(Integer.reverseBytes(Float.floatToIntBits(data)));
-    }
-
-    public byte[] toByteArray() {
-        return this.outputStream.toByteArray();
-    }
-
-    public void reset() {
-        this.outputStream.reset();
-    }
-}
diff --git a/net/minecraft/server/rcon/PktUtils.java b/net/minecraft/server/rcon/PktUtils.java
deleted file mode 100644
index f12c1b8ff2f00f359723d628ae954b67b1c94785..0000000000000000000000000000000000000000
--- a/net/minecraft/server/rcon/PktUtils.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package net.minecraft.server.rcon;
-
-import java.nio.charset.StandardCharsets;
-
-public class PktUtils {
-    public static final int MAX_PACKET_SIZE = 1460;
-    public static final char[] HEX_CHAR = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
-
-    public static String stringFromByteArray(byte[] input, int offset, int length) {
-        int i = length - 1;
-        int i1 = offset > i ? i : offset;
-
-        while (0 != input[i1] && i1 < i) {
-            i1++;
-        }
-
-        return new String(input, offset, i1 - offset, StandardCharsets.UTF_8);
-    }
-
-    public static int intFromByteArray(byte[] input, int offset) {
-        return intFromByteArray(input, offset, input.length);
-    }
-
-    public static int intFromByteArray(byte[] input, int offset, int length) {
-        return 0 > length - offset - 4
-            ? 0
-            : input[offset + 3] << 24 | (input[offset + 2] & 0xFF) << 16 | (input[offset + 1] & 0xFF) << 8 | input[offset] & 0xFF;
-    }
-
-    public static int intFromNetworkByteArray(byte[] input, int offset, int length) {
-        return 0 > length - offset - 4
-            ? 0
-            : input[offset] << 24 | (input[offset + 1] & 0xFF) << 16 | (input[offset + 2] & 0xFF) << 8 | input[offset + 3] & 0xFF;
-    }
-
-    public static String toHexString(byte input) {
-        return "" + HEX_CHAR[(input & 240) >>> 4] + HEX_CHAR[input & 15];
-    }
-}
diff --git a/net/minecraft/server/rcon/RconConsoleSource.java b/net/minecraft/server/rcon/RconConsoleSource.java
deleted file mode 100644
index 1fddeb10c5947c52840e55ca66c50dd4ad5425b9..0000000000000000000000000000000000000000
--- a/net/minecraft/server/rcon/RconConsoleSource.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package net.minecraft.server.rcon;
-
-import net.minecraft.commands.CommandSource;
-import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.network.chat.Component;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.world.phys.Vec2;
-import net.minecraft.world.phys.Vec3;
-
-public class RconConsoleSource implements CommandSource {
-    private static final String RCON = "Rcon";
-    private static final Component RCON_COMPONENT = Component.literal("Rcon");
-    private final StringBuffer buffer = new StringBuffer();
-    private final MinecraftServer server;
-    // CraftBukkit start
-    public final java.net.SocketAddress socketAddress;
-    private final org.bukkit.craftbukkit.command.CraftRemoteConsoleCommandSender remoteConsole = new org.bukkit.craftbukkit.command.CraftRemoteConsoleCommandSender(this);
-
-    public RconConsoleSource(MinecraftServer server, java.net.SocketAddress socketAddress) {
-        this.socketAddress = socketAddress;
-        // CraftBukkit end
-        this.server = server;
-    }
-
-    public void prepareForCommand() {
-        this.buffer.setLength(0);
-    }
-
-    public String getCommandResponse() {
-        return this.buffer.toString();
-    }
-
-    public CommandSourceStack createCommandSourceStack() {
-        ServerLevel serverLevel = this.server.overworld();
-        return new CommandSourceStack(
-            this, Vec3.atLowerCornerOf(serverLevel.getSharedSpawnPos()), Vec2.ZERO, serverLevel, 4, "Rcon", RCON_COMPONENT, this.server, null
-        );
-    }
-
-    // CraftBukkit start - Send a String
-    public void sendMessage(String message) {
-        this.buffer.append(message);
-    }
-
-    @Override
-    public org.bukkit.command.CommandSender getBukkitSender(CommandSourceStack wrapper) {
-        return this.remoteConsole;
-    }
-    // CraftBukkit end
-
-    @Override
-    public void sendSystemMessage(Component component) {
-        this.buffer.append(component.getString());
-    }
-
-    @Override
-    public boolean acceptsSuccess() {
-        return true;
-    }
-
-    @Override
-    public boolean acceptsFailure() {
-        return true;
-    }
-
-    @Override
-    public boolean shouldInformAdmins() {
-        return this.server.shouldRconBroadcast();
-    }
-}
diff --git a/net/minecraft/server/rcon/package-info.java b/net/minecraft/server/rcon/package-info.java
deleted file mode 100644
index d16efa6e6dbec9bc67094c82a887a9b2e72110bd..0000000000000000000000000000000000000000
--- a/net/minecraft/server/rcon/package-info.java
+++ /dev/null
@@ -1,8 +0,0 @@
-@ParametersAreNonnullByDefault
-@MethodsReturnNonnullByDefault
-@FieldsAreNonnullByDefault
-package net.minecraft.server.rcon;
-
-import javax.annotation.ParametersAreNonnullByDefault;
-import net.minecraft.FieldsAreNonnullByDefault;
-import net.minecraft.MethodsReturnNonnullByDefault;
diff --git a/net/minecraft/server/rcon/thread/GenericThread.java b/net/minecraft/server/rcon/thread/GenericThread.java
deleted file mode 100644
index 08a65cf9d8f64a42df0accc3463cc7077c096b3c..0000000000000000000000000000000000000000
--- a/net/minecraft/server/rcon/thread/GenericThread.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package net.minecraft.server.rcon.thread;
-
-import com.mojang.logging.LogUtils;
-import java.util.concurrent.atomic.AtomicInteger;
-import javax.annotation.Nullable;
-import net.minecraft.DefaultUncaughtExceptionHandlerWithName;
-import org.slf4j.Logger;
-
-public abstract class GenericThread implements Runnable {
-    private static final Logger LOGGER = LogUtils.getLogger();
-    private static final AtomicInteger UNIQUE_THREAD_ID = new AtomicInteger(0);
-    private static final int MAX_STOP_WAIT = 5;
-    protected volatile boolean running;
-    protected final String name;
-    @Nullable
-    protected Thread thread;
-
-    protected GenericThread(String name) {
-        this.name = name;
-    }
-
-    public synchronized boolean start() {
-        if (this.running) {
-            return true;
-        } else {
-            this.running = true;
-            this.thread = new Thread(this, this.name + " #" + UNIQUE_THREAD_ID.incrementAndGet());
-            this.thread.setUncaughtExceptionHandler(new DefaultUncaughtExceptionHandlerWithName(LOGGER));
-            this.thread.start();
-            LOGGER.info("Thread {} started", this.name);
-            return true;
-        }
-    }
-
-    public synchronized void stop() {
-        this.running = false;
-        if (null != this.thread) {
-            int i = 0;
-
-            while (this.thread.isAlive()) {
-                try {
-                    this.thread.join(1000L);
-                    if (++i >= 5) {
-                        LOGGER.warn("Waited {} seconds attempting force stop!", i);
-                    } else if (this.thread.isAlive()) {
-                        LOGGER.warn("Thread {} ({}) failed to exit after {} second(s)", this, this.thread.getState(), i, new Exception("Stack:"));
-                        this.thread.interrupt();
-                    }
-                } catch (InterruptedException var3) {
-                }
-            }
-
-            LOGGER.info("Thread {} stopped", this.name);
-            this.thread = null;
-        }
-    }
-
-    public boolean isRunning() {
-        return this.running;
-    }
-}
diff --git a/net/minecraft/server/rcon/thread/QueryThreadGs4.java b/net/minecraft/server/rcon/thread/QueryThreadGs4.java
deleted file mode 100644
index 0b8d279a53196f3998b1f6901738ca8e02ef7311..0000000000000000000000000000000000000000
--- a/net/minecraft/server/rcon/thread/QueryThreadGs4.java
+++ /dev/null
@@ -1,368 +0,0 @@
-package net.minecraft.server.rcon.thread;
-
-import com.google.common.collect.Maps;
-import com.mojang.logging.LogUtils;
-import java.io.IOException;
-import java.net.DatagramPacket;
-import java.net.DatagramSocket;
-import java.net.InetAddress;
-import java.net.PortUnreachableException;
-import java.net.SocketAddress;
-import java.net.SocketTimeoutException;
-import java.net.UnknownHostException;
-import java.nio.charset.StandardCharsets;
-import java.util.Date;
-import java.util.Locale;
-import java.util.Map;
-import javax.annotation.Nullable;
-import net.minecraft.Util;
-import net.minecraft.server.ServerInterface;
-import net.minecraft.server.rcon.NetworkDataOutputStream;
-import net.minecraft.server.rcon.PktUtils;
-import net.minecraft.util.RandomSource;
-import org.slf4j.Logger;
-
-public class QueryThreadGs4 extends GenericThread {
-    private static final Logger LOGGER = LogUtils.getLogger();
-    private static final String GAME_TYPE = "SMP";
-    private static final String GAME_ID = "MINECRAFT";
-    private static final long CHALLENGE_CHECK_INTERVAL = 30000L;
-    private static final long RESPONSE_CACHE_TIME = 5000L;
-    private long lastChallengeCheck;
-    private final int port;
-    private final int serverPort;
-    private final int maxPlayers;
-    private final String serverName;
-    private final String worldName;
-    private DatagramSocket socket;
-    private final byte[] buffer = new byte[1460];
-    private String hostIp;
-    private String serverIp;
-    private final Map<SocketAddress, QueryThreadGs4.RequestChallenge> validChallenges;
-    private final NetworkDataOutputStream rulesResponse;
-    private long lastRulesResponse;
-    private final ServerInterface serverInterface;
-
-    private QueryThreadGs4(ServerInterface serverInterface, int port) {
-        super("Query Listener");
-        this.serverInterface = serverInterface;
-        this.port = port;
-        this.serverIp = serverInterface.getServerIp();
-        this.serverPort = serverInterface.getServerPort();
-        this.serverName = serverInterface.getServerName();
-        this.maxPlayers = serverInterface.getMaxPlayers();
-        this.worldName = serverInterface.getLevelIdName();
-        this.lastRulesResponse = 0L;
-        this.hostIp = "0.0.0.0";
-        if (!this.serverIp.isEmpty() && !this.hostIp.equals(this.serverIp)) {
-            this.hostIp = this.serverIp;
-        } else {
-            this.serverIp = "0.0.0.0";
-
-            try {
-                InetAddress localHost = InetAddress.getLocalHost();
-                this.hostIp = localHost.getHostAddress();
-            } catch (UnknownHostException var4) {
-                LOGGER.warn("Unable to determine local host IP, please set server-ip in server.properties", (Throwable)var4);
-            }
-        }
-
-        this.rulesResponse = new NetworkDataOutputStream(1460);
-        this.validChallenges = Maps.newHashMap();
-    }
-
-    @Nullable
-    public static QueryThreadGs4 create(ServerInterface serverInterface) {
-        int i = serverInterface.getProperties().queryPort;
-        if (0 < i && 65535 >= i) {
-            QueryThreadGs4 queryThreadGs4 = new QueryThreadGs4(serverInterface, i);
-            return !queryThreadGs4.start() ? null : queryThreadGs4;
-        } else {
-            LOGGER.warn("Invalid query port {} found in server.properties (queries disabled)", i);
-            return null;
-        }
-    }
-
-    private void sendTo(byte[] data, DatagramPacket requestPacket) throws IOException {
-        this.socket.send(new DatagramPacket(data, data.length, requestPacket.getSocketAddress()));
-    }
-
-    private boolean processPacket(DatagramPacket requestPacket) throws IOException {
-        byte[] data = requestPacket.getData();
-        int length = requestPacket.getLength();
-        SocketAddress socketAddress = requestPacket.getSocketAddress();
-        LOGGER.debug("Packet len {} [{}]", length, socketAddress);
-        if (3 <= length && -2 == data[0] && -3 == data[1]) {
-            LOGGER.debug("Packet '{}' [{}]", PktUtils.toHexString(data[2]), socketAddress);
-            switch (data[2]) {
-                case 0:
-                    if (!this.validChallenge(requestPacket)) {
-                        LOGGER.debug("Invalid challenge [{}]", socketAddress);
-                        return false;
-                    } else if (15 == length) {
-                        this.sendTo(this.buildRuleResponse(requestPacket), requestPacket);
-                        LOGGER.debug("Rules [{}]", socketAddress);
-                    } else {
-                        NetworkDataOutputStream networkDataOutputStream = new NetworkDataOutputStream(1460);
-                        networkDataOutputStream.write(0);
-                        networkDataOutputStream.writeBytes(this.getIdentBytes(requestPacket.getSocketAddress()));
-                        // Paper start
-                        com.destroystokyo.paper.event.server.GS4QueryEvent.QueryType queryType =
-                            com.destroystokyo.paper.event.server.GS4QueryEvent.QueryType.BASIC;
-                        com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse queryResponse = com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.builder()
-                            .motd(this.serverName)
-                            .map(this.worldName)
-                            .currentPlayers(this.serverInterface.getPlayerCount())
-                            .maxPlayers(this.maxPlayers)
-                            .port(this.serverPort)
-                            .hostname(this.hostIp)
-                            .gameVersion(this.serverInterface.getServerVersion())
-                            .serverVersion(org.bukkit.Bukkit.getServer().getName() + " on " + org.bukkit.Bukkit.getServer().getBukkitVersion())
-                            .build();
-                        com.destroystokyo.paper.event.server.GS4QueryEvent queryEvent =
-                            new com.destroystokyo.paper.event.server.GS4QueryEvent(queryType, requestPacket.getAddress(), queryResponse);
-                        queryEvent.callEvent();
-                        queryResponse = queryEvent.getResponse();
-
-                        networkDataOutputStream.writeString(queryResponse.getMotd());
-                        networkDataOutputStream.writeString("SMP");
-                        networkDataOutputStream.writeString(queryResponse.getMap());
-                        networkDataOutputStream.writeString(Integer.toString(queryResponse.getCurrentPlayers()));
-                        networkDataOutputStream.writeString(Integer.toString(queryResponse.getMaxPlayers()));
-                        networkDataOutputStream.writeShort((short) queryResponse.getPort());
-                        networkDataOutputStream.writeString(queryResponse.getHostname());
-                        // Paper end
-                        this.sendTo(networkDataOutputStream.toByteArray(), requestPacket);
-                        LOGGER.debug("Status [{}]", socketAddress);
-                    }
-                default:
-                    return true;
-                case 9:
-                    this.sendChallenge(requestPacket);
-                    LOGGER.debug("Challenge [{}]", socketAddress);
-                    return true;
-            }
-        } else {
-            LOGGER.debug("Invalid packet [{}]", socketAddress);
-            return false;
-        }
-    }
-
-    private byte[] buildRuleResponse(DatagramPacket requestPacket) throws IOException {
-        long millis = Util.getMillis();
-        if (millis < this.lastRulesResponse + 5000L) {
-            byte[] bytes = this.rulesResponse.toByteArray();
-            byte[] identBytes = this.getIdentBytes(requestPacket.getSocketAddress());
-            bytes[1] = identBytes[0];
-            bytes[2] = identBytes[1];
-            bytes[3] = identBytes[2];
-            bytes[4] = identBytes[3];
-            return bytes;
-        } else {
-            this.lastRulesResponse = millis;
-            this.rulesResponse.reset();
-            this.rulesResponse.write(0);
-            this.rulesResponse.writeBytes(this.getIdentBytes(requestPacket.getSocketAddress()));
-            this.rulesResponse.writeString("splitnum");
-            this.rulesResponse.write(128);
-            this.rulesResponse.write(0);
-            // Paper start
-            // Pack plugins
-            java.util.List<com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.PluginInformation> plugins = java.util.Collections.emptyList();
-            org.bukkit.plugin.Plugin[] bukkitPlugins;
-            if (((net.minecraft.server.dedicated.DedicatedServer) this.serverInterface).server.getQueryPlugins() && (bukkitPlugins = org.bukkit.Bukkit.getPluginManager().getPlugins()).length > 0) {
-                plugins = java.util.stream.Stream.of(bukkitPlugins)
-                    .map(plugin -> com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.PluginInformation.of(plugin.getName(), plugin.getDescription().getVersion()))
-                    .collect(java.util.stream.Collectors.toList());
-            }
-
-            com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse queryResponse = com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.builder()
-                .motd(this.serverName)
-                .map(this.worldName)
-                .currentPlayers(this.serverInterface.getPlayerCount())
-                .maxPlayers(this.maxPlayers)
-                .port(this.serverPort)
-                .hostname(this.hostIp)
-                .plugins(plugins)
-                .players(this.serverInterface.getPlayerNames())
-                .gameVersion(this.serverInterface.getServerVersion())
-                .serverVersion(org.bukkit.Bukkit.getServer().getName() + " on " + org.bukkit.Bukkit.getServer().getBukkitVersion())
-                .build();
-            com.destroystokyo.paper.event.server.GS4QueryEvent.QueryType queryType =
-                com.destroystokyo.paper.event.server.GS4QueryEvent.QueryType.FULL;
-            com.destroystokyo.paper.event.server.GS4QueryEvent queryEvent =
-                new com.destroystokyo.paper.event.server.GS4QueryEvent(queryType, requestPacket.getAddress(), queryResponse);
-            queryEvent.callEvent();
-            queryResponse = queryEvent.getResponse();
-            this.rulesResponse.writeString("hostname");
-            this.rulesResponse.writeString(queryResponse.getMotd());
-            this.rulesResponse.writeString("gametype");
-            this.rulesResponse.writeString("SMP");
-            this.rulesResponse.writeString("game_id");
-            this.rulesResponse.writeString("MINECRAFT");
-            this.rulesResponse.writeString("version");
-            this.rulesResponse.writeString(queryResponse.getGameVersion());
-            this.rulesResponse.writeString("plugins");
-            java.lang.StringBuilder pluginsString = new java.lang.StringBuilder();
-            pluginsString.append(queryResponse.getServerVersion());
-            if (!queryResponse.getPlugins().isEmpty()) {
-                pluginsString.append(": ");
-                java.util.Iterator<com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.PluginInformation> iter = queryResponse.getPlugins().iterator();
-                while (iter.hasNext()) {
-                    com.destroystokyo.paper.event.server.GS4QueryEvent.QueryResponse.PluginInformation info = iter.next();
-                    pluginsString.append(info.getName());
-                    if (info.getVersion() != null) {
-                        pluginsString.append(' ').append(info.getVersion().replace(";", ","));
-                    }
-                    if (iter.hasNext()) {
-                        pluginsString.append(';').append(' ');
-                    }
-                }
-            }
-            this.rulesResponse.writeString(pluginsString.toString());
-            this.rulesResponse.writeString("map");
-            this.rulesResponse.writeString(queryResponse.getMap());
-            this.rulesResponse.writeString("numplayers");
-            this.rulesResponse.writeString(Integer.toString(queryResponse.getCurrentPlayers()));
-            this.rulesResponse.writeString("maxplayers");
-            this.rulesResponse.writeString(Integer.toString(queryResponse.getMaxPlayers()));
-            this.rulesResponse.writeString("hostport");
-            this.rulesResponse.writeString(Integer.toString(queryResponse.getPort()));
-            this.rulesResponse.writeString("hostip");
-            this.rulesResponse.writeString(queryResponse.getHostname());
-            this.rulesResponse.write(0);
-            this.rulesResponse.write(1);
-            this.rulesResponse.writeString("player_");
-            this.rulesResponse.write(0);
-            String[] playerNames = queryResponse.getPlayers().toArray(String[]::new);
-
-            for (String string : playerNames) {
-                this.rulesResponse.writeString(string);
-            }
-
-            this.rulesResponse.write(0);
-            return this.rulesResponse.toByteArray();
-        }
-    }
-
-    private byte[] getIdentBytes(SocketAddress address) {
-        return this.validChallenges.get(address).getIdentBytes();
-    }
-
-    private Boolean validChallenge(DatagramPacket requestPacket) {
-        SocketAddress socketAddress = requestPacket.getSocketAddress();
-        if (!this.validChallenges.containsKey(socketAddress)) {
-            return false;
-        } else {
-            byte[] data = requestPacket.getData();
-            return this.validChallenges.get(socketAddress).getChallenge() == PktUtils.intFromNetworkByteArray(data, 7, requestPacket.getLength());
-        }
-    }
-
-    private void sendChallenge(DatagramPacket requestPacket) throws IOException {
-        QueryThreadGs4.RequestChallenge requestChallenge = new QueryThreadGs4.RequestChallenge(requestPacket);
-        this.validChallenges.put(requestPacket.getSocketAddress(), requestChallenge);
-        this.sendTo(requestChallenge.getChallengeBytes(), requestPacket);
-    }
-
-    private void pruneChallenges() {
-        if (this.running) {
-            long millis = Util.getMillis();
-            if (millis >= this.lastChallengeCheck + 30000L) {
-                this.lastChallengeCheck = millis;
-                this.validChallenges.values().removeIf(challenge -> challenge.before(millis));
-            }
-        }
-    }
-
-    @Override
-    public void run() {
-        LOGGER.info("Query running on {}:{}", this.serverIp, this.port);
-        this.lastChallengeCheck = Util.getMillis();
-        DatagramPacket datagramPacket = new DatagramPacket(this.buffer, this.buffer.length);
-
-        try {
-            while (this.running) {
-                try {
-                    this.socket.receive(datagramPacket);
-                    this.pruneChallenges();
-                    this.processPacket(datagramPacket);
-                } catch (SocketTimeoutException var8) {
-                    this.pruneChallenges();
-                } catch (PortUnreachableException var9) {
-                } catch (IOException var10) {
-                    this.recoverSocketError(var10);
-                }
-            }
-        } finally {
-            LOGGER.debug("closeSocket: {}:{}", this.serverIp, this.port);
-            this.socket.close();
-        }
-    }
-
-    @Override
-    public boolean start() {
-        return this.running || this.initSocket() && super.start();
-    }
-
-    private void recoverSocketError(Exception exception) {
-        if (this.running) {
-            LOGGER.warn("Unexpected exception", (Throwable)exception);
-            if (!this.initSocket()) {
-                LOGGER.error("Failed to recover from exception, shutting down!");
-                this.running = false;
-            }
-        }
-    }
-
-    private boolean initSocket() {
-        try {
-            this.socket = new DatagramSocket(this.port, InetAddress.getByName(this.serverIp));
-            this.socket.setSoTimeout(500);
-            return true;
-        } catch (Exception var2) {
-            LOGGER.warn("Unable to initialise query system on {}:{}", this.serverIp, this.port, var2);
-            return false;
-        }
-    }
-
-    static class RequestChallenge {
-        private final long time = new Date().getTime();
-        private final int challenge;
-        private final byte[] identBytes;
-        private final byte[] challengeBytes;
-        private final String ident;
-
-        public RequestChallenge(DatagramPacket datagramPacket) {
-            byte[] data = datagramPacket.getData();
-            this.identBytes = new byte[4];
-            this.identBytes[0] = data[3];
-            this.identBytes[1] = data[4];
-            this.identBytes[2] = data[5];
-            this.identBytes[3] = data[6];
-            this.ident = new String(this.identBytes, StandardCharsets.UTF_8);
-            this.challenge = RandomSource.create().nextInt(16777216);
-            this.challengeBytes = String.format(Locale.ROOT, "\t%s%d\u0000", this.ident, this.challenge).getBytes(StandardCharsets.UTF_8);
-        }
-
-        public Boolean before(long currentTime) {
-            return this.time < currentTime;
-        }
-
-        public int getChallenge() {
-            return this.challenge;
-        }
-
-        public byte[] getChallengeBytes() {
-            return this.challengeBytes;
-        }
-
-        public byte[] getIdentBytes() {
-            return this.identBytes;
-        }
-
-        public String getIdent() {
-            return this.ident;
-        }
-    }
-}
diff --git a/net/minecraft/server/rcon/thread/RconClient.java b/net/minecraft/server/rcon/thread/RconClient.java
deleted file mode 100644
index 7bfd3e8c3763ef58d86c179cbc9d6768a8c878f6..0000000000000000000000000000000000000000
--- a/net/minecraft/server/rcon/thread/RconClient.java
+++ /dev/null
@@ -1,154 +0,0 @@
-package net.minecraft.server.rcon.thread;
-
-import com.mojang.logging.LogUtils;
-import java.io.BufferedInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.net.Socket;
-import java.nio.charset.StandardCharsets;
-import java.util.Locale;
-import net.minecraft.server.ServerInterface;
-import net.minecraft.server.rcon.PktUtils;
-import org.slf4j.Logger;
-
-public class RconClient extends GenericThread {
-    private static final Logger LOGGER = LogUtils.getLogger();
-    private static final int SERVERDATA_AUTH = 3;
-    private static final int SERVERDATA_EXECCOMMAND = 2;
-    private static final int SERVERDATA_RESPONSE_VALUE = 0;
-    private static final int SERVERDATA_AUTH_RESPONSE = 2;
-    private static final int SERVERDATA_AUTH_FAILURE = -1;
-    private boolean authed;
-    private final Socket client;
-    private final byte[] buf = new byte[1460];
-    private final String rconPassword;
-    // CraftBukkit start
-    private final net.minecraft.server.dedicated.DedicatedServer serverInterface;
-    private final net.minecraft.server.rcon.RconConsoleSource rconConsoleSource;
-    // CraftBukkit end
-
-    RconClient(ServerInterface serverInterface, String rconPassword, Socket client) {
-        super("RCON Client " + client.getInetAddress());
-        this.serverInterface = (net.minecraft.server.dedicated.DedicatedServer) serverInterface; // CraftBukkit
-        this.client = client;
-
-        try {
-            this.client.setSoTimeout(0);
-        } catch (Exception var5) {
-            this.running = false;
-        }
-
-        this.rconPassword = rconPassword;
-        this.rconConsoleSource = new net.minecraft.server.rcon.RconConsoleSource(this.serverInterface, client.getRemoteSocketAddress()); // CraftBukkit
-    }
-
-    @Override
-    public void run() {
-        try {
-            try {
-                while (this.running) {
-                    BufferedInputStream bufferedInputStream = new BufferedInputStream(this.client.getInputStream());
-                    int i = bufferedInputStream.read(this.buf, 0, 1460);
-                    if (10 > i) {
-                        return;
-                    }
-
-                    int i1 = 0;
-                    int i2 = PktUtils.intFromByteArray(this.buf, 0, i);
-                    if (i2 != i - 4) {
-                        return;
-                    }
-
-                    i1 += 4;
-                    int i3 = PktUtils.intFromByteArray(this.buf, i1, i);
-                    i1 += 4;
-                    int i4 = PktUtils.intFromByteArray(this.buf, i1);
-                    i1 += 4;
-                    switch (i4) {
-                        case 2:
-                            if (this.authed) {
-                                String string1 = PktUtils.stringFromByteArray(this.buf, i1, i);
-
-                                try {
-                                    this.sendCmdResponse(i3, this.serverInterface.runCommand(this.rconConsoleSource, string1)); // CraftBukkit
-                                } catch (Exception var15) {
-                                    this.sendCmdResponse(i3, "Error executing: " + string1 + " (" + var15.getMessage() + ")");
-                                }
-                                break;
-                            }
-
-                            this.sendAuthFailure();
-                            break;
-                        case 3:
-                            String string = PktUtils.stringFromByteArray(this.buf, i1, i);
-                            i1 += string.length();
-                            if (!string.isEmpty() && string.equals(this.rconPassword)) {
-                                this.authed = true;
-                                this.send(i3, 2, "");
-                                break;
-                            }
-
-                            this.authed = false;
-                            this.sendAuthFailure();
-                            break;
-                        default:
-                            this.sendCmdResponse(i3, String.format(Locale.ROOT, "Unknown request %s", Integer.toHexString(i4)));
-                    }
-                }
-
-                return;
-            } catch (IOException var16) {
-            } catch (Exception var17) {
-                LOGGER.error("Exception whilst parsing RCON input", (Throwable)var17);
-            }
-        } finally {
-            this.closeSocket();
-            LOGGER.info("Thread {} shutting down", this.name);
-            this.running = false;
-        }
-    }
-
-    private void send(int id, int type, String message) throws IOException {
-        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(1248);
-        DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);
-        byte[] bytes = message.getBytes(StandardCharsets.UTF_8);
-        dataOutputStream.writeInt(Integer.reverseBytes(bytes.length + 10));
-        dataOutputStream.writeInt(Integer.reverseBytes(id));
-        dataOutputStream.writeInt(Integer.reverseBytes(type));
-        dataOutputStream.write(bytes);
-        dataOutputStream.write(0);
-        dataOutputStream.write(0);
-        this.client.getOutputStream().write(byteArrayOutputStream.toByteArray());
-    }
-
-    private void sendAuthFailure() throws IOException {
-        this.send(-1, 2, "");
-    }
-
-    private void sendCmdResponse(int id, String message) throws IOException {
-        int len = message.length();
-
-        do {
-            int i = 4096 <= len ? 4096 : len;
-            this.send(id, 0, message.substring(0, i));
-            message = message.substring(i);
-            len = message.length();
-        } while (0 != len);
-    }
-
-    @Override
-    public void stop() {
-        this.running = false;
-        this.closeSocket();
-        super.stop();
-    }
-
-    private void closeSocket() {
-        try {
-            this.client.close();
-        } catch (IOException var2) {
-            LOGGER.warn("Failed to close socket", (Throwable)var2);
-        }
-    }
-}
diff --git a/net/minecraft/server/rcon/thread/RconThread.java b/net/minecraft/server/rcon/thread/RconThread.java
deleted file mode 100644
index f23cc9ea16618c1d023edf97577501116ae6abea..0000000000000000000000000000000000000000
--- a/net/minecraft/server/rcon/thread/RconThread.java
+++ /dev/null
@@ -1,125 +0,0 @@
-package net.minecraft.server.rcon.thread;
-
-import com.google.common.collect.Lists;
-import com.mojang.logging.LogUtils;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketTimeoutException;
-import java.util.List;
-import javax.annotation.Nullable;
-import net.minecraft.server.ServerInterface;
-import net.minecraft.server.dedicated.DedicatedServerProperties;
-import org.slf4j.Logger;
-
-public class RconThread extends GenericThread {
-    private static final Logger LOGGER = LogUtils.getLogger();
-    private final ServerSocket socket;
-    private final String rconPassword;
-    private final List<RconClient> clients = Lists.newArrayList();
-    private final ServerInterface serverInterface;
-
-    private RconThread(ServerInterface serverInterface, ServerSocket socket, String rconPassword) {
-        super("RCON Listener");
-        this.serverInterface = serverInterface;
-        this.socket = socket;
-        this.rconPassword = rconPassword;
-    }
-
-    private void clearClients() {
-        this.clients.removeIf(rconClient -> !rconClient.isRunning());
-    }
-
-    @Override
-    public void run() {
-        try {
-            while (this.running) {
-                try {
-                    Socket socket = this.socket.accept();
-                    RconClient rconClient = new RconClient(this.serverInterface, this.rconPassword, socket);
-                    rconClient.start();
-                    this.clients.add(rconClient);
-                    this.clearClients();
-                } catch (SocketTimeoutException var7) {
-                    this.clearClients();
-                } catch (IOException var8) {
-                    if (this.running) {
-                        LOGGER.info("IO exception: ", (Throwable)var8);
-                    }
-                }
-            }
-        } finally {
-            this.closeSocket(this.socket);
-        }
-    }
-
-    @Nullable
-    public static RconThread create(ServerInterface serverInterface) {
-        DedicatedServerProperties properties = serverInterface.getProperties();
-        String serverIp = properties.rconIp; // Paper - Configurable rcon ip
-        if (serverIp.isEmpty()) {
-            serverIp = "0.0.0.0";
-        }
-
-        int i = properties.rconPort;
-        if (0 < i && 65535 >= i) {
-            String string = properties.rconPassword;
-            if (string.isEmpty()) {
-                LOGGER.warn("No rcon password set in server.properties, rcon disabled!");
-                return null;
-            } else {
-                try {
-                    ServerSocket serverSocket = new ServerSocket(i, 0, InetAddress.getByName(serverIp));
-                    serverSocket.setSoTimeout(500);
-                    RconThread rconThread = new RconThread(serverInterface, serverSocket, string);
-                    if (!rconThread.start()) {
-                        return null;
-                    } else {
-                        LOGGER.info("RCON running on {}:{}", serverIp, i);
-                        return rconThread;
-                    }
-                } catch (IOException var7) {
-                    LOGGER.warn("Unable to initialise RCON on {}:{}", serverIp, i, var7);
-                    return null;
-                }
-            }
-        } else {
-            LOGGER.warn("Invalid rcon port {} found in server.properties, rcon disabled!", i);
-            return null;
-        }
-    }
-
-    @Override
-    public void stop() {
-        this.running = false;
-        this.closeSocket(this.socket);
-        super.stop();
-
-        for (RconClient rconClient : this.clients) {
-            if (rconClient.isRunning()) {
-                rconClient.stop();
-            }
-        }
-
-        this.clients.clear();
-    }
-    // Paper start - don't wait for remote connections
-    public void stopNonBlocking() {
-        this.running = false;
-        for (RconClient client : this.clients) {
-            client.running = false;
-        }
-    }
-    // Paper end - don't wait for remote connections
-
-    private void closeSocket(ServerSocket socket) {
-        LOGGER.debug("closeSocket: {}", socket);
-
-        try {
-            socket.close();
-        } catch (IOException var3) {
-            LOGGER.warn("Failed to close socket", (Throwable)var3);
-        }
-    }
-}
diff --git a/net/minecraft/server/rcon/thread/package-info.java b/net/minecraft/server/rcon/thread/package-info.java
deleted file mode 100644
index 5bb9a89fb97908eed0c30b84fd8ee540782d3c84..0000000000000000000000000000000000000000
--- a/net/minecraft/server/rcon/thread/package-info.java
+++ /dev/null
@@ -1,8 +0,0 @@
-@ParametersAreNonnullByDefault
-@MethodsReturnNonnullByDefault
-@FieldsAreNonnullByDefault
-package net.minecraft.server.rcon.thread;
-
-import javax.annotation.ParametersAreNonnullByDefault;
-import net.minecraft.FieldsAreNonnullByDefault;
-import net.minecraft.MethodsReturnNonnullByDefault;
